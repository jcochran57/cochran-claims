<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cochran Claims - 3D Multi-Room Property Tool</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Professional property measurement and estimation tool for insurance claims">
    <meta name="theme-color" content="#1e3c72">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Property Tool">
    <!-- <link rel="manifest" href="manifest.json"> --> <!-- Disabled for file:// usage -->
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .top-bar {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 8px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            z-index: 100;
        }

        .branding {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .company-name {
            font-size: 16px;
            font-weight: 700;
        }

        .view-controls {
            display: flex;
            gap: 10px;
        }

        .view-btn {
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-weight: 600;
        }

        .view-btn.active {
            background: white;
            color: #1e3c72;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .left-panel {
            width: 280px;
            background: white;
            border-right: 2px solid #ddd;
            display: flex;
            flex-direction: column;
            transition: margin-left 0.3s ease;
            position: relative;
        }
        
        .left-panel.collapsed {
            margin-left: -280px;
        }
        
        .panel-collapse-btn {
            position: absolute;
            right: -30px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 60px;
            background: #1e3c72;
            border: none;
            border-radius: 0 8px 8px 0;
            color: white;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: background 0.3s ease;
        }
        
        .panel-collapse-btn:hover {
            background: #2a5298;
        }

        .room-manager {
            background: #f9f9f9;
            border-bottom: 2px solid #ddd;
            padding: 15px;
        }

        .room-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .add-room-btn {
            padding: 8px 16px;
            background: #1e3c72;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .room-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .room-item {
            padding: 12px;
            margin-bottom: 6px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .room-item.active {
            background: #1e3c72;
            color: white;
        }

        .room-delete {
            width: 24px;
            height: 24px;
            background: rgba(255,0,0,0.1);
            color: #f44336;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            font-weight: 600;
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
        }

        .wall-entry {
            padding: 12px;
            background: #f9f9f9;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .feature-btn {
            padding: 12px;
            min-height: 44px; /* iOS minimum touch target */
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            font-weight: 600;
            -webkit-tap-highlight-color: rgba(30, 60, 114, 0.3);
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            pointer-events: auto;
            position: relative;
            z-index: 10;
        }
        
        .feature-btn:active {
            transform: scale(0.98);
            background: #f0f0f0;
        }

        .feature-btn.active {
            background: #1e3c72;
            color: white;
        }

        .canvas-area {
            flex: 1;
            position: relative;
            background: #f0f0f0;
        }

        #canvas2D, #canvas3D {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #canvas2D {
            background: white;
            z-index: 1;
        }

        #canvas3D {
            display: none;
            z-index: 2;
        }

        .view-3d #canvas2D {
            display: none;
            pointer-events: none;
            z-index: 0;
        }

        .view-3d #canvas3D {
            display: block;
            pointer-events: auto;
            z-index: 2;
        }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .view-3d .zoom-controls {
            display: none;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            margin: 4px 0;
            background: #1e3c72;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: block;
        }

        /* REMOVED - Stats overlay panel
        .stats-overlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            min-width: 220px;
            z-index: 50;
            display: block;
        }

        .stats-overlay h4 {
            margin: 0 0 12px 0;
            color: #1e3c72;
            font-size: 16px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 14px;
        }

        .stat-value {
            font-weight: 700;
            color: #1e3c72;
        }
        */

        .bottom-toolbar {
            background: white;
            padding: 15px 25px;
            display: flex;
            justify-content: space-between;
            border-top: 2px solid #ddd;
        }

        .btn {
            padding: 12px 20px;
            background: #1e3c72;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin-right: 10px;
            /* iPad/Touch optimizations */
            -webkit-tap-highlight-color: rgba(30, 60, 114, 0.3);
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .btn:active {
            transform: scale(0.98);
            background: #152a52;
        }

        .controls-3d {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 12px;
            display: none;
        }

        .view-3d .controls-3d {
            display: block;
        }

        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            display: none;
            z-index: 10000;
        }

        .toast.active {
            display: block;
        }

        .placement-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            z-index: 10000;
            display: none;
            min-width: 400px;
        }

        .placement-dialog.active {
            display: block;
        }

        .dialog-title {
            font-size: 20px;
            font-weight: 700;
            color: #1e3c72;
            margin-bottom: 20px;
        }

        .dialog-field {
            margin-bottom: 15px;
        }

        .dialog-field label {
            display: block;
            font-weight: 600;
            margin-bottom: 6px;
            font-size: 14px;
        }

        .dialog-field input,
        .dialog-field select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
        }

        .dialog-buttons {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }

        .dialog-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
        }

        .dialog-btn-primary {
            background: #1e3c72;
            color: white;
        }

        .dialog-btn-secondary {
            background: #e0e0e0;
            color: #333;
        }

        .wall-highlight {
            cursor: pointer;
        }

        .wall-highlight:hover {
            opacity: 0.7;
        }

        .instruction-banner {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 60, 114, 0.95);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-weight: 600;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            font-size: 16px;
            animation: pulse 2s ease-in-out infinite;
        }

        .instruction-banner.active {
            display: block;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .mode-indicator {
            display: none !important;  /* Hidden permanently */
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            z-index: 999;
        }

        .mode-indicator.delete-mode {
            background: rgba(76, 175, 80, 0.9);
        }

        .mode-indicator.wall-mode {
            background: rgba(255, 152, 0, 0.9);
        }

        .clear-mode-btn {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: #f44336;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            z-index: 999;
        }

        /* ===== iPad Responsive Design ===== */
        @media screen and (max-width: 1366px) {
            /* Optimize for iPad Landscape & smaller screens */
            
            .left-panel {
                width: 280px; /* Narrower sidebar */
            }
            
            .company-name {
                font-size: 16px;
            }
            
            .top-bar {
                padding: 10px 15px;
            }
            
            .view-btn {
                padding: 8px 15px;
                font-size: 14px;
            }
        }
        
        @media screen and (max-width: 1024px) {
            /* iPad Portrait mode */
            
            .left-panel {
                width: 250px; /* Even narrower */
            }
            
            .panel-content {
                padding: 10px;
                font-size: 13px;
            }
            
            .form-group {
                margin-bottom: 10px;
            }
            
            .form-group label {
                font-size: 12px;
                margin-bottom: 3px;
            }
            
            .form-group input,
            .form-group select {
                font-size: 13px;
                padding: 6px;
            }
            
            .feature-btn {
                padding: 10px 8px;
                font-size: 13px;
            }
            
            h3 {
                font-size: 16px;
                margin-bottom: 10px;
            }
            
            h4 {
                font-size: 13px;
                margin: 15px 0 8px 0;
            }
            
            .btn {
                padding: 10px 15px;
                font-size: 14px;
            }
            
            /* REMOVED - Stats panel no longer exists
            .stats-overlay {
                bottom: 10px;
                right: 10px;
                padding: 12px;
                min-width: 180px;
            }
            
            .stats-overlay h4 {
                font-size: 14px;
                margin-bottom: 8px;
            }
            
            .stat-row {
                font-size: 12px;
                padding: 4px 0;
            }
            */
        }
        
        /* Ensure sidebar scrolls properly */
        .panel-content {
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }
        
        /* Modal Overlay Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        .modal {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        
        .modal h3 {
            margin: 0 0 20px 0;
            color: #1e3c72;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .modal-buttons button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        
        .modal-content h3 {
            margin: 0 0 20px 0;
            color: #1e3c72;
        }

        /* Print styles */
        @media print {
            /* Hide UI elements when printing */
            .top-bar,
            .left-panel,
            .right-panel,
            .view-controls,
            button,
            .stats-panel {
                display: none !important;
            }
            
            /* Make canvas area full page */
            .main-content {
                margin: 0;
                padding: 0;
            }
            
            .canvas-area {
                margin: 0 !important;
                padding: 0 !important;
                box-shadow: none !important;
                width: 100% !important;
                height: 100vh !important;
                page-break-inside: avoid;
            }
            
            #canvas2D {
                page-break-inside: avoid;
            }
            
            /* Set page to landscape for better fit */
            @page {
                size: landscape;
                margin: 0.5in;
            }
            
            body {
                margin: 0;
                padding: 0;
            }
        }

        /* ===== QUANTITY ESTIMATOR STYLES ===== */
        .estimator-panel {
            position: fixed;
            bottom: 80px;
            right: 20px;
            z-index: 30000;
            pointer-events: auto;
        }

        .estimator-toggle {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.3);
            transition: all 0.3s;
            pointer-events: auto;
            position: relative;
            z-index: 30001;
        }

        .estimator-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.5);
        }

        .estimator-menu {
            position: absolute;
            bottom: 55px;
            right: 0;
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 6px 24px rgba(0,0,0,0.15);
            min-width: 280px;
            display: none;
        }

        .estimator-menu.open {
            display: block;
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .estimator-menu h3 {
            margin: 0 0 12px 0;
            color: #333;
            font-size: 15px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }

        .estimate-btn {
            width: 100%;
            display: flex;
            align-items: center;
            background: white;
            border: 2px solid #e0e0e0;
            padding: 10px 12px;
            margin: 8px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 13px;
            font-weight: 600;
        }

        .estimate-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
            transform: translateX(3px);
        }

        .estimate-btn .icon {
            font-size: 20px;
            margin-right: 10px;
        }

        .estimate-btn .text {
            flex: 1;
            text-align: left;
            color: #333;
        }

        .estimator-loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 25000;
        }

        .estimator-loading-content {
            background: white;
            padding: 30px 40px;
            border-radius: 12px;
            text-align: center;
        }

        .estimator-loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: espin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes espin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .estimator-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4caf50;
            color: white;
            padding: 16px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 26000;
            animation: slideIn 0.3s ease-out;
            font-weight: 600;
        }

        .estimator-toast.error {
            background: #f44336;
        }

        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* =================================================================================
           ITEM BUILDER MODAL STYLES
           ================================================================================= */
        
        .item-builder-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .item-builder-container {
            background: white;
            border-radius: 12px;
            width: 95%;
            max-width: 1400px;
            height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        .item-builder-header {
            padding: 20px 30px;
            border-bottom: 2px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px 12px 0 0;
        }
        
        .item-builder-header h2 {
            margin: 0;
            font-size: 24px;
        }
        
        .close-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .close-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: rotate(90deg);
        }
        
        .item-builder-body {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .available-items-panel {
            width: 50%;
            border-right: 2px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow: hidden;
        }
        
        .selected-items-panel {
            width: 50%;
            display: flex;
            flex-direction: column;
            padding: 20px;
            background: #f8f9fa;
            overflow-y: auto;
            max-height: 100%;
        }
        
        .available-items-panel h3,
        .selected-items-panel h3 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #333;
        }
        
        .search-box {
            margin-bottom: 15px;
        }
        
        .search-box input {
            width: 100%;
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s;
        }
        
        .search-box input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .category-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .category-tab {
            padding: 8px 16px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .category-tab:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }
        
        .category-tab.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        
        .items-list {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .available-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 6px 8px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .available-item:hover {
            border-color: #667eea;
            transform: translateX(3px);
            box-shadow: 0 1px 4px rgba(102, 126, 234, 0.2);
        }
        
        .available-item.selected {
            border-color: #4caf50;
            background: #e8f5e9;
        }
        
        .item-name {
            font-weight: 600;
            font-size: 11px;
            color: #333;
            margin-bottom: 2px;
            line-height: 1.2;
        }
        
        .item-details {
            font-size: 10px;
            color: #666;
            display: flex;
            justify-content: space-between;
        }
        
        .item-category-badge {
            display: inline-block;
            padding: 1px 4px;
            border-radius: 8px;
            font-size: 8px;
            font-weight: 600;
            margin-left: 4px;
        }
        
        .category-drywall { background: #e3f2fd; color: #1976d2; }
        .category-framing { background: #fff8e1; color: #f9a825; }
        .category-insulation { background: #fce4ec; color: #c2185b; }
        .category-paint { background: #fff3e0; color: #f57c00; }
        .category-flooring { background: #f3e5f5; color: #7b1fa2; }
        .category-doors { background: #e0f2f1; color: #00796b; }
        .category-electrical { background: #fff9c4; color: #f57f17; }
        .category-plumbing { background: #e1f5fe; color: #0277bd; }
        .category-other { background: #f5f5f5; color: #616161; }
        
        .selected-count {
            background: #667eea;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .selected-items-list {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }
        
        .selected-item {
            background: white;
            border: 2px solid #4caf50;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }
        
        .selected-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .selected-item-name {
            font-weight: 600;
            font-size: 14px;
            color: #333;
        }
        
        .remove-item-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .remove-item-btn:hover {
            background: #d32f2f;
        }
        
        .selected-item-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-group label {
            font-size: 11px;
            color: #666;
            margin-bottom: 4px;
            font-weight: 600;
        }
        
        .control-group input {
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .control-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .estimate-total {
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .total-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 14px;
        }
        
        .total-row.grand-total {
            border-top: 2px solid #667eea;
            margin-top: 8px;
            padding-top: 12px;
            font-weight: 700;
            font-size: 18px;
            color: #667eea;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
        }
        
        .btn-primary,
        .btn-secondary {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
        }
        
        .btn-secondary:hover {
            background: #f0f4ff;
        }
        
        .estimate-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 16px;
            padding: 15px 20px;
        }
        
        .estimate-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        /* ========================================
           XACTIMATE-STYLE MENU SYSTEM
           ======================================== */
        
        /* Top Menu Bar */
        .xactimate-menu-bar {
            display: flex;
            align-items: center;
            background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
            border-bottom: 2px solid #dee2e6;
            padding: 0;
            height: 36px;
            font-family: Arial, sans-serif;
            gap: 2px;
        }
        
        .menu-tab {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            color: #333;
            border-right: 1px solid #ddd;
            transition: all 0.2s;
            user-select: none;
        }
        
        .menu-tab:hover {
            background: rgba(0, 0, 0, 0.05);
        }
        
        .menu-tab.active {
            background: white;
            border-bottom: 3px solid #0066cc;
            color: #0066cc;
            font-weight: 600;
        }
        
        .menu-action-btn {
            padding: 4px 12px;
            font-size: 12px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .menu-action-btn:hover {
            background: #f0f0f0;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* Icon Toolbar */
        .xactimate-toolbar {
            display: flex;
            align-items: center;
            background: linear-gradient(180deg, #ffffff 0%, #f5f5f5 100%);
            border-bottom: 1px solid #d0d0d0;
            padding: 4px 8px;
            gap: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .toolbar-group {
            display: flex;
            gap: 2px;
        }
        
        .toolbar-divider {
            width: 1px;
            height: 48px;
            background: linear-gradient(180deg, transparent 0%, #ccc 20%, #ccc 80%, transparent 100%);
            margin: 0 4px;
        }
        
        .toolbar-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 6px 10px;
            background: white;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 60px;
            gap: 2px;
        }
        
        .toolbar-btn:hover {
            background: #e8f4ff;
            border-color: #0066cc;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0, 102, 204, 0.2);
        }
        
        .toolbar-btn-active {
            background: #ffa500 !important;
            border-color: #ff8c00 !important;
            color: white !important;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .toolbar-btn-active .btn-label {
            color: white !important;
        }
        
        .btn-icon {
            font-size: 20px;
            line-height: 1;
        }
        
        .btn-label {
            font-size: 10px;
            font-weight: 600;
            color: #333;
            white-space: nowrap;
        }
        
        /* Adjust main content to account for new toolbars */
        .main-content {
            height: calc(100vh - 85px) !important;
        }

    </style>
</head>
<body>
    <div class="app-container">
        <!-- Xactimate-style Top Menu Bar -->
        <div class="xactimate-menu-bar">
            <div class="menu-tab active" onclick="showMenuTab('sketch')">Sketch</div>
            <div class="menu-tab" onclick="showMenuTab('project')">Project</div>
            <div class="menu-tab" onclick="showMenuTab('estimate')">Estimate Items</div>
            <div class="menu-tab" onclick="showMenuTab('tools')">Tools</div>
            <div class="menu-tab" onclick="showMenuTab('options')">Options</div>
            <div style="margin-left: auto; display: flex; gap: 10px; align-items: center;">
                <button class="menu-action-btn" onclick="printDrawing()">üñ®Ô∏è Print</button>
                <button class="menu-action-btn" onclick="saveAndReturnToClaims()" style="background: #4CAF50; color: white;">üíæ Save & Exit</button>
                <button class="menu-action-btn" onclick="window.location.href='help.html'">‚ùì Help</button>
            </div>
        </div>
        
        <!-- Xactimate-style Icon Toolbar -->
        <div class="xactimate-toolbar">
            <!-- Room/Shape Tools -->
            <div class="toolbar-group">
                <button class="toolbar-btn" onclick="addNewRoom()" title="Add Room">
                    <span class="btn-icon">üè†</span>
                    <span class="btn-label">Room</span>
                </button>
                <button class="toolbar-btn" onclick="showLidarImport()" title="Import LiDAR">
                    <span class="btn-icon">üì°</span>
                    <span class="btn-label">LiDAR</span>
                </button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <!-- Wall Tools -->
            <div class="toolbar-group">
                <button class="toolbar-btn toolbar-btn-active" onclick="setDrawingMode('wall', event)" title="Draw Wall">
                    <span class="btn-icon">üìè</span>
                    <span class="btn-label">Wall</span>
                </button>
                <button class="toolbar-btn" id="orthoBtn" onclick="toggleOrthoMode()" title="Ortho Mode - Snap to H/V">
                    <span class="btn-icon">‚äû</span>
                    <span class="btn-label">Ortho</span>
                </button>
                <button class="toolbar-btn" onclick="setDrawingMode('break', event)" title="Break Wall">
                    <span class="btn-icon">‚úÇÔ∏è</span>
                    <span class="btn-label">Break</span>
                </button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <!-- Feature Tools -->
            <div class="toolbar-group">
                <button class="toolbar-btn" onclick="setFeatureMode('door', event)" title="Place Door">
                    <span class="btn-icon">üö™</span>
                    <span class="btn-label">Door</span>
                </button>
                <button class="toolbar-btn" onclick="setFeatureMode('window', event)" title="Place Window">
                    <span class="btn-icon">ü™ü</span>
                    <span class="btn-label">Window</span>
                </button>
                <button class="toolbar-btn" onclick="setFeatureMode('opening', event)" title="Place Opening">
                    <span class="btn-icon">‚¨ú</span>
                    <span class="btn-label">Opening</span>
                </button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <!-- Edit Tools -->
            <div class="toolbar-group">
                <button class="toolbar-btn" onclick="enterEditMode()" title="Edit Mode">
                    <span class="btn-icon">üìê</span>
                    <span class="btn-label">Edit</span>
                </button>
                <button class="toolbar-btn" onclick="undo()" title="Undo last change (Ctrl+Z)">
                    <span class="btn-icon">‚Ü∂</span>
                    <span class="btn-label">Undo</span>
                </button>
                <button class="toolbar-btn" onclick="redo()" title="Redo last undone change (Ctrl+Y)">
                    <span class="btn-icon">‚Ü∑</span>
                    <span class="btn-label">Redo</span>
                </button>
                <button class="toolbar-btn" onclick="undoMultiple(5)" title="Undo last 5 changes">
                    <span class="btn-icon">‚Ü∂‚Ü∂</span>
                    <span class="btn-label">Undo 5</span>
                </button>
                <button class="toolbar-btn" onclick="checkRoomQuality()" title="Check Quality">
                    <span class="btn-icon">‚úì</span>
                    <span class="btn-label">Check</span>
                </button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <!-- View Tools -->
            <div class="toolbar-group">
                <button class="toolbar-btn" onclick="switch2D()" title="2D View">
                    <span class="btn-icon">üìê</span>
                    <span class="btn-label">2D</span>
                </button>
                <button class="toolbar-btn" onclick="switch3D()" title="3D View">
                    <span class="btn-icon">üè†</span>
                    <span class="btn-label">3D</span>
                </button>
                <button class="toolbar-btn" onclick="zoomAll()" title="Zoom All - Fit entire drawing">
                    <span class="btn-icon">üîç</span>
                    <span class="btn-label">Zoom All</span>
                </button>
                <button class="toolbar-btn" id="zoomWindowBtn" onclick="startZoomWindow()" title="Zoom Window - Select area to zoom">
                    <span class="btn-icon">‚¨ö</span>
                    <span class="btn-label">Zoom Window</span>
                </button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <!-- Clear Tool -->
            <div class="toolbar-group">
                <button class="toolbar-btn" onclick="clearActiveToolMode()" title="Clear Active Tool (ESC)" style="background: #ffebee; border-color: #ef5350;">
                    <span class="btn-icon">‚ùå</span>
                    <span class="btn-label">Clear</span>
                </button>
            </div>
        </div>
        
        <div class="top-bar" style="display: none;">
            <div class="branding">
                <div class="company-logo">üìê</div>
                <div class="company-name">Cochran Claims - Property Tool</div>
            </div>
            <div class="view-controls">
                <button class="view-btn active" onclick="switch2D()">üìê 2D View</button>
                <button class="view-btn" onclick="switch3D()">üè† 3D View</button>
                <button class="view-btn" id="resetCameraBtn" onclick="resetCamera()" title="Reset camera to default position" style="display: none;">üîÑ Reset Camera</button>
                <button class="view-btn" onclick="printDrawing()" title="Print to printer or save as PDF">üñ®Ô∏è Print</button>
                <button class="view-btn" onclick="saveAndReturnToClaims()" title="Save property data and return to Claims Manager" style="background: #4CAF50; border-color: #4CAF50; color: white;">üíæ Save & Return</button>
            </div>
        </div>

        <!-- LEVEL/FLOOR SELECTOR - PROMINENT -->
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-bottom: 3px solid #5a67d8; padding: 15px 20px; display: flex; align-items: center; gap: 15px; justify-content: center; box-shadow: 0 2px 8px rgba(0,0,0,0.15);">
            <span style="font-weight: 700; color: white; font-size: 16px; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">üìç LEVEL:</span>
            <select id="levelSelector" onchange="switchLevel(this.value)" style="
                padding: 8px 16px;
                font-size: 15px;
                font-weight: 600;
                border: 2px solid white;
                border-radius: 6px;
                background: white;
                color: #667eea;
                cursor: pointer;
                min-width: 160px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            ">
                <!-- Options will be generated here -->
            </select>
            <span id="levelRoomCount" style="font-weight: 600; color: white; font-size: 14px; margin-left: 10px; opacity: 0.9;">
                <!-- Room count will appear here -->
            </span>
        </div>

        <div class="main-content">
            <div class="canvas-area" id="canvasArea" style="width: 100%; margin-left: 0;">
                <canvas id="canvas2D"></canvas>
                <div id="canvas3D"></div>

                <div style="position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.95); padding: 10px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); z-index: 100;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-size: 14px; font-weight: 600;">
                        <input type="checkbox" id="showAllRooms" onchange="toggleShowAllRooms()" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                        <span>üèòÔ∏è Show All Rooms</span>
                    </label>
                    <div id="allRoomsHelp" style="font-size: 11px; color: #666; margin-top: 5px; display: none;">
                        Click and drag rooms to move them
                    </div>
                </div>

                <div class="zoom-controls">
                    <button id="zoomInBtn" class="zoom-btn" onclick="zoomIn()">+</button>
                    <div id="zoomLevel" style="text-align: center; padding: 8px 0;">100%</div>
                    <button id="zoomOutBtn" class="zoom-btn" onclick="zoomOut()">‚àí</button>
                    <button id="resetZoomBtn" class="zoom-btn" onclick="resetZoom()">‚äô</button>
                    <button id="zoomAllBtn" class="zoom-btn" onclick="zoomAll()" title="Zoom to fit room">üîç All</button>
                    <div style="font-size: 10px; text-align: center; margin-top: 8px; color: #666;">
                        üñ±Ô∏è Mouse Wheel = Zoom<br>
                        Shift+Drag = Pan<br>
                        üëÜ Tap buttons for zoom/pan
                    </div>
                </div>

                <div class="controls-3d">
                    <h4>üéÆ 3D Controls</h4>
                    <p style="font-size: 13px; margin-top: 10px;">
                        ‚Ä¢ Drag to rotate<br>
                        ‚Ä¢ Scroll to zoom<br>
                        ‚Ä¢ Shows all rooms
                    </p>
                </div>

                <div class="instruction-banner" id="instructionBanner">
                    Click on a wall to place the feature
                </div>

                <div class="mode-indicator" id="modeIndicator" style="display: none;">
                    üìè EDIT MODE - Click feature to edit/delete
                </div>

                <button class="clear-mode-btn" id="clearModeBtn" onclick="clearAllModes()" style="display: none;">
                    ‚ùå Clear Mode
                </button>
            </div>
        </div>
        
        <!-- BOTTOM RIBBON - Room Tabs (SketchUp style) -->
        <div style="background: white; border-top: 2px solid #999; padding: 10px 20px; display: flex; align-items: center; gap: 15px; box-shadow: 0 -2px 8px rgba(0,0,0,0.1); overflow-x: auto; max-height: 80px;">
            <!-- Left: Room tabs -->
            <div id="roomList" style="display: flex; gap: 8px; flex: 1; overflow-x: auto; flex-wrap: nowrap;">
                <!-- Room tabs will be generated here -->
            </div>
            
            <!-- Right: Add Room button -->
            <button onclick="addNewRoom()" style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; white-space: nowrap; flex-shrink: 0;">
                + Add Room
            </button>
        </div>
    </div>
    </div>

    
    <!-- Missing Wall Modal -->
    <div class="modal-overlay" id="missingWallModal" style="display:none;">
        <div class="modal">
            <h3 id="missingWallModalTitle">üß± Missing Wall</h3>
            <p style="margin:6px 0 12px;color:#666;font-size:13px;">Room: <span id="missingWallRoomName"></span></p>

            <div class="form-group">
                <label for="missingWallSelect">Wall</label>
                <select id="missingWallSelect"></select>
            </div>

            <div class="form-group">
                <label for="missingWallReference">Measure From</label>
                <select id="missingWallReference">
                    <option value="left">Left Corner</option>
                    <option value="right">Right Corner</option>
                </select>
            </div>

            <div style="display:flex;gap:10px;">
                <div class="form-group" style="flex:1;">
                    <label for="missingWallStart" id="missingWallStartLabel">Start (ft from left corner)</label>
                    <input type="number" id="missingWallStart" step="0.1" min="0" value="0">
                </div>
                <div class="form-group" style="flex:1;">
                    <label for="missingWallEnd" id="missingWallEndLabel">End (ft from left corner)</label>
                    <input type="number" id="missingWallEnd" step="0.1" min="0" value="1">
                </div>
            </div>

            <div style="display:flex;gap:10px;">
                <div class="form-group" style="flex:1;">
                    <label for="missingWallHeight">Height (ft)</label>
                    <input type="number" id="missingWallHeight" step="0.5" min="0.5" max="20" value="3">
                </div>
                <div class="form-group" style="flex:1;">
                    <label for="missingWallFloorDist">Distance from Floor (ft)</label>
                    <input type="number" id="missingWallFloorDist" step="0.5" min="0" max="20" value="0">
                </div>
            </div>

            <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:14px;">
                <button class="btn btn-danger" id="missingWallDeleteBtn" onclick="deleteCurrentMissingWall()" style="display:none;">üóëÔ∏è Delete</button>
                <button class="btn btn-primary" onclick="cancelMissingWall()">Cancel</button>
                <button class="btn btn-success" id="missingWallConfirmBtn" onclick="confirmMissingWall()">‚úÖ Save</button>
            </div>
        </div>
    </div>

<div class="toast" id="toast"></div>
    
    <!-- Custom Edit Name Modal -->
    <div id="editNameModal" onclick="if(event.target === this) cancelEditName()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 400px; width: 90%;">
            <h3 style="margin: 0 0 20px 0; color: #1e3c72; font-size: 20px;">‚úèÔ∏è Edit Room Name</h3>
            <input type="text" id="editNameInput" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 20px; box-sizing: border-box;" placeholder="Enter room name">
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="cancelEditName()" style="padding: 10px 20px; font-size: 14px; background: #ccc; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Cancel</button>
                <button onclick="confirmEditName()" style="padding: 10px 20px; font-size: 14px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Save</button>
            </div>
        </div>
    </div>

    <!-- Custom Add Room Modal -->
    <div id="addRoomModal" onclick="if(event.target === this) cancelAddRoom()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 400px; width: 90%;">
            <h3 style="margin: 0 0 20px 0; color: #1e3c72; font-size: 20px;">üè† Add New Room</h3>
            <input type="text" id="addRoomInput" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 20px; box-sizing: border-box;" placeholder="Enter room name">
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="cancelAddRoom()" style="padding: 10px 20px; font-size: 14px; background: #ccc; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Cancel</button>
                <button onclick="confirmAddRoom()" style="padding: 10px 20px; font-size: 14px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Add Room</button>
            </div>
        </div>
    </div>

    <!-- Room Properties Modal -->
    <div id="roomPropertiesModal" onclick="if(event.target === this) closeRoomProperties()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 500px; width: 90%;">
            <h3 style="margin: 0 0 20px 0; color: #1e3c72; font-size: 20px;">üè† Room Properties</h3>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Room Name:</label>
                <input type="text" id="propRoomName" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; box-sizing: border-box;">
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Ceiling Height (ft):</label>
                <input type="number" id="propCeilingHeight" step="0.5" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; box-sizing: border-box;">
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Wall Thickness (inches):</label>
                <input type="number" id="propWallThickness" step="0.5" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; box-sizing: border-box;">
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Level:</label>
                <select id="propRoomLevel" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; box-sizing: border-box;">
                    <option value="Basement">Basement</option>
                    <option value="Main Floor">Main Floor</option>
                    <option value="2nd Floor">2nd Floor</option>
                    <option value="3rd Floor">3rd Floor</option>
                    <option value="Roof">Roof</option>
                </select>
            </div>
            
            <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <strong style="color: #1976d2;">üìä Room Statistics:</strong>
                <div style="margin-top: 10px; color: #666; line-height: 1.6;">
                    <div><strong>Floor Area:</strong> <span id="propFloorArea">--</span> sq ft</div>
                    <div><strong>Perimeter:</strong> <span id="propPerimeter">--</span> ft</div>
                    <div><strong>Walls:</strong> <span id="propWallCount">--</span></div>
                    <div><strong>Doors:</strong> <span id="propDoorCount">--</span></div>
                    <div><strong>Windows:</strong> <span id="propWindowCount">--</span></div>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="closeRoomProperties()" style="padding: 12px 24px; font-size: 14px; background: #ccc; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Cancel</button>
                <button onclick="saveRoomProperties()" style="padding: 12px 24px; font-size: 14px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- LiDAR Import Modal -->
    <div id="lidarImportModal" onclick="if(event.target === this) cancelLidarImport()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 600px; width: 90%;">
            <h3 style="margin: 0 0 10px 0; color: #1e3c72; font-size: 20px;">üì° Import LiDAR Scan</h3>
            <p style="margin: 0 0 20px 0; color: #666; font-size: 14px;">Import floor plan from iPad LiDAR scan (.obj or .csv)</p>
            
            <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #2196F3;">
                <strong style="color: #1976d2;">üì± Supported Formats:</strong>
                <ul style="margin: 10px 0 0 20px; color: #666;">
                    <li><strong>.OBJ</strong> - 3D mesh from apps like Polycam, RoomScan, 3D Scanner</li>
                    <li><strong>.CSV</strong> - Point cloud (X, Y, Z coordinates)</li>
                </ul>
            </div>
            
            <div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ff9800;">
                <strong style="color: #f57c00;">‚ö†Ô∏è Requirements:</strong>
                <ul style="margin: 10px 0 0 20px; color: #666;">
                    <li>Scan should be of a single room's floor plan</li>
                    <li>LiDAR should capture walls clearly</li>
                    <li>Floor should be approximately level</li>
                </ul>
            </div>
            
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Room Name:</label>
            <input type="text" id="lidarRoomName" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 20px; box-sizing: border-box;" placeholder="e.g., Living Room">
            
            <!-- Wall Thickness Settings -->
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #e0e0e0;">
                <strong style="color: #333; display: block; margin-bottom: 12px;">üîß Wall Settings</strong>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; color: #555; font-size: 14px;">Wall Thickness:</label>
                    <select id="lidarWallThickness" style="width: 100%; padding: 10px; font-size: 14px; border: 2px solid #ddd; border-radius: 6px; box-sizing: border-box;">
                        <option value="4">4 inches (standard interior)</option>
                        <option value="6">6 inches (standard exterior)</option>
                        <option value="8">8 inches (thick exterior)</option>
                        <option value="10">10 inches (brick/stone)</option>
                        <option value="12">12 inches (heavy masonry)</option>
                    </select>
                </div>
                
                <div>
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; color: #555; font-size: 14px;">Measurement Mode:</label>
                    <select id="lidarMeasurementMode" style="width: 100%; padding: 10px; font-size: 14px; border: 2px solid #ddd; border-radius: 6px; box-sizing: border-box;">
                        <option value="interior">Interior (as-scanned, for flooring/finishes)</option>
                        <option value="exterior">Exterior (add wall thickness, for structure)</option>
                    </select>
                    <p style="margin: 8px 0 0 0; color: #666; font-size: 12px; line-height: 1.4;">
                        üí° <strong>Interior:</strong> Measures room at scanned surface<br>
                        üí° <strong>Exterior:</strong> Offsets walls outward by half thickness
                    </p>
                </div>
            </div>
            
            <input type="file" id="lidarFileInput" accept=".obj,.csv" style="display: none;" onchange="handleLidarFile(event)">
            
            <button onclick="document.getElementById('lidarFileInput').click()" style="width: 100%; padding: 15px; font-size: 16px; background: #2196F3; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; margin-bottom: 15px;">
                üìÇ Choose LiDAR File
            </button>
            
            <div id="lidarFileInfo" style="display: none; background: #f5f5f5; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span id="lidarFileName" style="color: #333; font-weight: 600;"></span>
                    <span id="lidarFileSize" style="color: #666; font-size: 14px;"></span>
                </div>
                <button id="lidarProcessBtn" onclick="processLidarData()" style="width: 100%; margin-top: 10px; padding: 12px; font-size: 14px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                    ‚úì Process & Create Room
                </button>
            </div>
            
            <div id="lidarProgress" style="display: none; margin-bottom: 15px;">
                <div style="background: #e0e0e0; height: 8px; border-radius: 4px; overflow: hidden;">
                    <div id="lidarProgressBar" style="background: #4CAF50; height: 100%; width: 0%; transition: width 0.3s;"></div>
                </div>
                <p id="lidarProgressText" style="margin-top: 8px; color: #666; font-size: 14px; text-align: center;"></p>
            </div>
            
            <div id="lidarError" style="display: none; background: #ffebee; padding: 12px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid #f44336;">
                <p id="lidarErrorText" style="margin: 0; color: #c62828; font-size: 14px;"></p>
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="cancelLidarImport()" style="padding: 10px 20px; font-size: 14px; background: #ccc; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Custom Position Editor Modal -->
    <div id="positionModal" onclick="if(event.target === this) cancelPosition()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 500px; width: 90%; max-height: 85vh; overflow-y: auto;">
            <h3 style="margin: 0 0 10px 0; color: #1e3c72; font-size: 20px;" id="positionModalTitle">üìè Reposition Door</h3>
            <p style="margin: 0 0 20px 0; color: #666; font-size: 14px;" id="positionModalHelp">Enter the distance from LEFT corner to LEFT EDGE of feature</p>
            
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #e9ecef;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span style="color: #666; font-size: 13px;">Current Wall:</span>
                    <span style="font-weight: 600; color: #1e3c72;" id="positionCurrentWall">Wall 1</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span style="color: #666; font-size: 13px;">Wall Length:</span>
                    <span style="font-weight: 600; color: #1e3c72;" id="positionWallLength">20.0 ft</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span style="color: #666; font-size: 13px;">Feature Width:</span>
                    <span style="font-weight: 600; color: #4A90E2;" id="positionFeatureWidth">3.0 ft</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #666; font-size: 13px;">Current Left Edge:</span>
                    <span style="font-weight: 600; color: #FF6B6B;" id="positionCurrentPos">5.0 ft</span>
                </div>
            </div>
            
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Measure From:</label>
            <select id="positionReferenceCorner" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box;">
                <option value="left">Left Corner</option>
                <option value="right">Right Corner</option>
            </select>
            
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;" id="positionDistanceLabel">Distance to Left Edge (feet):</label>
            <input type="number" id="positionInput" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box;" placeholder="Enter distance in feet" step="0.1" min="0">
            
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Width (inches):</label>
            <input type="number" id="positionWidthInput" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box;" placeholder="Width in inches" step="1" min="12" max="120">

            <div id="positionHeightFields" style="display: none;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;" for="positionHeightInput">Height (inches):</label>
                <input type="number" id="positionHeightInput" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box;" placeholder="Height in inches" step="1" min="12" max="120">

                <div id="positionFloorHeightFields">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Height from Floor (feet):</label>
                    <input type="number" id="positionFloorHeightInput" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box;" placeholder="Distance from floor" step="0.5" min="0" max="10">
                </div>
                
                <div id="positionDoorSwingFields" style="display: none;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Door Type:</label>
                    <select id="doorTypeSelect" style="width: 100%; padding: 12px; font-size: 14px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box; background: white;">
                        <option value="single">üö™ Single Swing</option>
                        <option value="double">üö™üö™ Double Swing</option>
                        <option value="sliding">‚ÜîÔ∏è Sliding Door</option>
                        <option value="french">üé® French Door</option>
                        <option value="bifold">üìÇ Bifold Door</option>
                        <option value="pocket">üö™‚û°Ô∏è Pocket Door</option>
                        <option value="dutch">üö™‚¨ÜÔ∏è Dutch Door</option>
                    </select>
                    
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Hinge Side:</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <button id="hingeLeftBtn" onclick="setDoorHinge('left')" style="flex: 1; padding: 12px; font-size: 14px; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; background: white; font-weight: 600;">
                            ‚¨ÖÔ∏è Left
                        </button>
                        <button id="hingeRightBtn" onclick="setDoorHinge('right')" style="flex: 1; padding: 12px; font-size: 14px; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; background: white; font-weight: 600;">
                            Right ‚û°Ô∏è
                        </button>
                    </div>
                    
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Opens:</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <button id="swingInBtn" onclick="setDoorSwingDirection('in')" style="flex: 1; padding: 12px; font-size: 14px; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; background: white; font-weight: 600;">
                            ‚¨áÔ∏è Into Room
                        </button>
                        <button id="swingOutBtn" onclick="setDoorSwingDirection('out')" style="flex: 1; padding: 12px; font-size: 14px; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; background: white; font-weight: 600;">
                            ‚¨ÜÔ∏è Out of Room
                        </button>
                    </div>
                </div>
                
                <div id="positionWindowTypeFields" style="display: none;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Window Type:</label>
                    <select id="windowTypeSelect" style="width: 100%; padding: 12px; font-size: 14px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box; background: white;">
                        <option value="single-hung">ü™ü Single Hung</option>
                        <option value="double-hung">ü™üü™ü Double Hung</option>
                        <option value="casement">‚Ü™Ô∏è Casement</option>
                        <option value="sliding">‚ÜîÔ∏è Sliding</option>
                        <option value="awning">‚¨ÜÔ∏è Awning</option>
                        <option value="hopper">‚¨áÔ∏è Hopper</option>
                        <option value="bay">üè† Bay Window</option>
                        <option value="bow">üèõÔ∏è Bow Window</option>
                        <option value="picture">üñºÔ∏è Picture Window</option>
                        <option value="skylight">‚òÄÔ∏è Skylight</option>
                        <option value="garden">üåø Garden Window</option>
                    </select>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: space-between;">
                <button onclick="deleteCurrentFeature()" style="padding: 10px 20px; font-size: 14px; background: #f44336; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">üóëÔ∏è Delete</button>
                <div style="display: flex; gap: 10px;">
                    <button onclick="cancelPosition()" style="padding: 10px 20px; font-size: 14px; background: #ccc; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Cancel</button>
                    <button onclick="confirmPosition()" style="padding: 10px 20px; font-size: 14px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Apply Position</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Filename Modal -->
    <div id="filenameModal" onclick="if(event.target === this) cancelFilename()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 500px; width: 90%;">
            <h3 style="margin: 0 0 10px 0; color: #1e3c72; font-size: 20px;" id="filenameModalTitle">üíæ Save Project</h3>
            <p style="margin: 0 0 20px 0; color: #666; font-size: 14px;">Enter a name for your project</p>
            
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Project Name:</label>
            <input type="text" id="filenameInput" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 20px; box-sizing: border-box;" placeholder="e.g., 123 Main Street - Smith Property">
            
            <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 20px; font-size: 13px; color: #666;">
                üí° <strong>Tip:</strong> Use a descriptive name like address or client name for easy identification
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="cancelFilename()" style="padding: 10px 20px; font-size: 14px; background: #ccc; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Cancel</button>
                <button onclick="confirmFilename()" style="padding: 10px 20px; font-size: 14px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;" id="filenameConfirmBtn">Save</button>
            </div>
        </div>
    </div>

    <!-- Wall Editing Toolbar (like Xactimate) -->
    <div id="wallEditingToolbar" style="display: none; position: fixed; top: 80px; left: 50%; transform: translateX(-50%); z-index: 2000; background: linear-gradient(to bottom, #f8f9fa, #e9ecef); border: 2px solid #0066cc; border-radius: 12px; padding: 15px 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); min-width: 800px;">
        <div style="display: flex; align-items: center; gap: 20px; flex-wrap: wrap;">
            <div style="font-weight: bold; color: #0066cc; font-size: 16px; padding-right: 20px; border-right: 2px solid #dee2e6;">
                üìê EDIT MODE
            </div>
            
            <!-- Wall Tools -->
            <div style="display: flex; flex-direction: column; gap: 5px;">
                <div style="font-size: 11px; color: #666; font-weight: bold;">WALLS</div>
                <div style="display: flex; gap: 8px;">
                    <button id="editToolSelect" class="edit-tool-btn active" title="Select & Edit" onclick="setEditTool('select')">
                        <span style="font-size: 20px;">‚ÜñÔ∏è</span><br>
                        <span style="font-size: 10px;">Select</span>
                    </button>
                    <button id="editToolForce90" class="edit-tool-btn" title="Force 90¬∞ Angle" onclick="setEditTool('force90')">
                        <span style="font-size: 20px;">‚äæ</span><br>
                        <span style="font-size: 10px;">Force 90¬∞</span>
                    </button>
                    <button id="editToolAddWall" class="edit-tool-btn" title="Add Wall" onclick="setEditTool('addWall')">
                        <span style="font-size: 20px;">üìè</span><br>
                        <span style="font-size: 10px;">Add Wall</span>
                    </button>
                    <button id="editToolDeleteWall" class="edit-tool-btn" title="Delete Wall" onclick="setEditTool('deleteWall')">
                        <span style="font-size: 20px;">üóëÔ∏è</span><br>
                        <span style="font-size: 10px;">Delete</span>
                    </button>
                    <button id="editToolMoveCorner" class="edit-tool-btn" title="Move Corner" onclick="setEditTool('moveCorner')">
                        <span style="font-size: 20px;">‚ÜîÔ∏è</span><br>
                        <span style="font-size: 10px;">Move</span>
                    </button>
                    <button id="editToolShowAngles" class="edit-tool-btn" title="Show Wall Angles" onclick="toggleShowAngles()">
                        <span style="font-size: 20px;">‚à†</span><br>
                        <span style="font-size: 10px;">Angles</span>
                    </button>
                </div>
            </div>
            
            <!-- Feature Tools -->
            <div style="display: flex; flex-direction: column; gap: 5px; border-left: 2px solid #dee2e6; padding-left: 20px;">
                <div style="font-size: 11px; color: #666; font-weight: bold;">FEATURES</div>
                <div style="display: flex; gap: 8px;">
                    <button id="editToolAddDoor" class="edit-tool-btn" title="Add Door" onclick="setEditTool('addDoor')">
                        <span style="font-size: 20px;">üö™</span><br>
                        <span style="font-size: 10px;">Door</span>
                    </button>
                    <button id="editToolAddWindow" class="edit-tool-btn" title="Add Window" onclick="setEditTool('addWindow')">
                        <span style="font-size: 20px;">ü™ü</span><br>
                        <span style="font-size: 10px;">Window</span>
                    </button>
                    <button id="editToolAddOpening" class="edit-tool-btn" title="Add Opening" onclick="setEditTool('addOpening')">
                        <span style="font-size: 20px;">‚¨ú</span><br>
                        <span style="font-size: 10px;">Opening</span>
                    </button>
                </div>
            </div>
            
            <!-- Room Tools -->
            <div style="display: flex; flex-direction: column; gap: 5px; border-left: 2px solid #dee2e6; padding-left: 20px;">
                <div style="font-size: 11px; color: #666; font-weight: bold;">ROOM</div>
                <div style="display: flex; gap: 8px;">
                    <button id="editToolCeiling" class="edit-tool-btn" title="Set Ceiling Height" onclick="editCeilingHeight()">
                        <span style="font-size: 20px;">üìê</span><br>
                        <span style="font-size: 10px;">Ceiling</span>
                    </button>
                    <button id="editToolOrthogonalize" class="edit-tool-btn" title="Straighten Walls" onclick="orthogonalizeCurrentRoom()">
                        <span style="font-size: 20px;">üìä</span><br>
                        <span style="font-size: 10px;">Straighten</span>
                    </button>
                </div>
            </div>
            
            <!-- Done Button -->
            <button id="editToolDone" onclick="exitEditMode()" style="margin-left: auto; background: #28a745; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 14px; box-shadow: 0 2px 8px rgba(40,167,69,0.3);" onmouseover="this.style.background='#218838'" onmouseout="this.style.background='#28a745'">
                ‚úì DONE EDITING
            </button>
        </div>
        
        <!-- Status Bar -->
        <div id="editStatusBar" style="margin-top: 10px; padding: 8px 12px; background: #fff; border-radius: 6px; font-size: 13px; color: #495057; border: 1px solid #dee2e6;">
            Click a wall to edit its length, or click a corner to move it.
        </div>
    </div>
    
    <style>
        .edit-tool-btn {
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 70px;
            text-align: center;
        }
        
        .edit-tool-btn:hover {
            background: #e9ecef;
            border-color: #0066cc;
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(0,102,204,0.2);
        }
        
        .edit-tool-btn.active {
            background: #0066cc;
            color: white;
            border-color: #0066cc;
            box-shadow: 0 2px 8px rgba(0,102,204,0.3);
        }
        
        .edit-tool-btn:active {
            transform: translateY(0);
        }
        
        #canvas2d.edit-mode {
            cursor: crosshair !important;
        }
        
        #canvas2d.edit-mode.move-cursor {
            cursor: move !important;
        }
        
        #canvas2d.edit-mode.delete-cursor {
            cursor: not-allowed !important;
        }
    </style>

    <!-- Force 90¬∞ Direction Modal -->
    <div id="force90Modal" onclick="if(event.target === this) cancelForce90()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10001; align-items: center; justify-content: center;">
        <div style="background: white; padding: 40px; border-radius: 16px; box-shadow: 0 8px 32px rgba(0,0,0,0.4); max-width: 600px; width: 90%;">
            <h3 style="margin: 0 0 10px 0; color: #1e3c72; font-size: 24px; text-align: center;">‚äæ Force 90¬∞ Angle</h3>
            <p style="margin: 0 0 30px 0; color: #666; font-size: 16px; text-align: center;">Which direction should Wall <span id="force90Wall2"></span> go?</p>
            
            <!-- Visual diagram -->
            <div style="display: flex; justify-content: center; gap: 40px; margin-bottom: 30px;">
                <!-- LEFT option -->
                <div style="text-align: center; padding: 20px; border: 3px solid #e0e0e0; border-radius: 12px; background: #f8f9fa;">
                    <div style="font-size: 18px; font-weight: bold; color: #0066cc; margin-bottom: 15px;">90¬∞ LEFT</div>
                    <div style="font-size: 60px; line-height: 1; color: #0066cc; margin-bottom: 10px;">
                        ‚åê<br>
                        ‚îî
                    </div>
                    <div style="font-size: 12px; color: #666;">Counter-clockwise</div>
                </div>
                
                <!-- RIGHT option -->
                <div style="text-align: center; padding: 20px; border: 3px solid #e0e0e0; border-radius: 12px; background: #f8f9fa;">
                    <div style="font-size: 18px; font-weight: bold; color: #FF9800; margin-bottom: 15px;">90¬∞ RIGHT</div>
                    <div style="font-size: 60px; line-height: 1; color: #FF9800; margin-bottom: 10px;">
                        ¬¨<br>
                        ‚îò
                    </div>
                    <div style="font-size: 12px; color: #666;">Clockwise</div>
                </div>
            </div>
            
            <!-- Explanation -->
            <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 30px; font-size: 14px; color: #1565c0; border-left: 4px solid #0066cc;">
                <strong>Wall <span id="force90Wall1"></span></strong> stays in place.<br>
                <strong>Wall <span id="force90Wall2b"></span></strong> will rotate to be exactly 90¬∞ perpendicular.
            </div>
            
            <!-- Buttons -->
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button onclick="confirmForce90('L')" style="flex: 1; padding: 18px 30px; font-size: 18px; background: #0066cc; color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; box-shadow: 0 4px 12px rgba(0,102,204,0.3); transition: all 0.2s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0,102,204,0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0,102,204,0.3)'">
                    ‚åê 90¬∞ LEFT
                </button>
                <button onclick="confirmForce90('R')" style="flex: 1; padding: 18px 30px; font-size: 18px; background: #FF9800; color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; box-shadow: 0 4px 12px rgba(255,152,0,0.3); transition: all 0.2s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(255,152,0,0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(255,152,0,0.3)'">
                    ¬¨ 90¬∞ RIGHT
                </button>
            </div>
            
            <button onclick="cancelForce90()" style="margin-top: 15px; width: 100%; padding: 12px; font-size: 14px; background: #ccc; color: #666; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">Cancel</button>
        </div>
    </div>

    <!-- Cut Wall Modal -->
    <div id="cutWallModal" onclick="if(event.target === this) cancelCutWall()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000;">
        <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 500px; width: 90%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
            <h3 id="cutWallModalTitle" style="margin: 0 0 10px 0; color: #1e3c72; font-size: 20px;">‚úÇÔ∏è Cut Portion of Wall</h3>
            <p style="margin: 0 0 20px 0; color: #666; font-size: 14px;">Delete a section of wall by specifying dimensions (e.g., for a doorway)</p>
            
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #e9ecef;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span style="color: #666; font-size: 13px;">Room:</span>
                    <span style="font-weight: 600; color: #1e3c72;" id="cutWallRoomName">Living Room</span>
                </div>
            </div>
            
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Select Wall:</label>
            <select id="cutWallSelect" style="width: 100%; padding: 10px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px;">
                <option value="">Choose a wall...</option>
            </select>
            
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Start Distance from Left (feet):</label>
            <input type="number" id="cutWallStart" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box;" placeholder="e.g., 2.0" step="0.1" min="0">
            
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">End Distance from Left (feet):</label>
            <input type="number" id="cutWallEnd" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box;" placeholder="e.g., 5.0" step="0.1" min="0">
            
            <div style="background: #fff3cd; padding: 12px; border-radius: 6px; margin-bottom: 20px; font-size: 13px; color: #856404; border: 1px solid #ffeaa7;">
                üí° <strong>Example:</strong> To cut 3 feet starting at 2 feet, enter Start: 2.0, End: 5.0
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: space-between; align-items: center;">
                <button onclick="deleteCurrentCutWall()" id="cutWallDeleteBtn" style="padding: 10px 20px; font-size: 14px; background: #f44336; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; display: none;">üóëÔ∏è Delete Cut</button>
                <div style="display:flex; gap:10px; justify-content:flex-end; flex:1;">
                    <button onclick="cancelCutWall()" style="padding: 10px 20px; font-size: 14px; background: #ccc; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Cancel</button>
                    <button onclick="confirmCutWall()" id="cutWallConfirmBtn" style="padding: 10px 20px; font-size: 14px; background: #FF5722; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">‚úÇÔ∏è Cut Wall</button>
                </div>
            </div>
        </div>
    </div>


    <!-- Quantity Estimator Panel -->
    <div class="estimator-panel">
        <button class="estimator-toggle" id="estimatorToggle" onclick="toggleEstimatorMenu(); return false;">
            üìä Estimates
            <span id="estimatorLoadingBadge" style="display: inline-block; margin-left: 6px; padding: 2px 5px; background: #ff9800; color: white; font-size: 9px; border-radius: 8px; font-weight: normal;">Loading...</span>
        </button>
        <div class="estimator-menu" id="estimatorMenu">
            <h3>Generate Estimate</h3>
            <button onclick="openEstimateBuilder(); return false;" class="estimate-btn primary">
                <span class="icon">üõ†Ô∏è</span>
                <span class="text">Build New</span>
            </button>
            <button onclick="openLoadSavedEstimate(); return false;" class="estimate-btn secondary" style="background: #2196f3; color: white; border-color: #2196f3;">
                <span class="icon">üìÇ</span>
                <span class="text">Load Saved</span>
            </button>
            <button onclick="openClientInfo(); return false;" class="estimate-btn" style="background: #4caf50; color: white; border-color: #4caf50;">
                <span class="icon">üë§</span>
                <span class="text">Client Info</span>
            </button>
            <div style="border-top: 1px solid #e0e0e0; margin: 10px 0;"></div>
            <button onclick="openDatabaseManager(); return false;" class="estimate-btn" style="background: #ff9800; color: white; border-color: #ff9800;">
                <span class="icon">üíæ</span>
                <span class="text">Manage Database</span>
            </button>
        </div>
    </div>

    <!-- CLIENT INFO MODAL -->
    <div id="clientInfoModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 40000; backdrop-filter: blur(4px);">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 12px; padding: 30px; width: 90%; max-width: 500px; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0; color: #333; font-size: 22px;">üë§ Client Information</h2>
                <button onclick="closeClientInfo()" style="background: none; border: none; font-size: 28px; cursor: pointer; color: #666; padding: 0; width: 32px; height: 32px; line-height: 28px;">√ó</button>
            </div>
            
            <form id="clientInfoForm" onsubmit="saveClientInfo(event); return false;">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #555; font-size: 13px;">Client Name *</label>
                    <input type="text" id="clientName" required style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; box-sizing: border-box;" placeholder="John Smith">
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #555; font-size: 13px;">Company/Business</label>
                    <input type="text" id="clientCompany" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; box-sizing: border-box;" placeholder="ABC Construction">
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #555; font-size: 13px;">Email</label>
                    <input type="email" id="clientEmail" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; box-sizing: border-box;" placeholder="john@example.com">
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #555; font-size: 13px;">Phone</label>
                    <input type="tel" id="clientPhone" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; box-sizing: border-box;" placeholder="(555) 123-4567">
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #555; font-size: 13px;">Property Address *</label>
                    <input type="text" id="clientAddress" required style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; box-sizing: border-box;" placeholder="123 Main St">
                </div>
                
                <div style="display: grid; grid-template-columns: 2fr 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #555; font-size: 13px;">City *</label>
                        <input type="text" id="clientCity" required style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; box-sizing: border-box;" placeholder="Dallas">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #555; font-size: 13px;">State *</label>
                        <input type="text" id="clientState" required style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; box-sizing: border-box;" placeholder="TX" maxlength="2">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #555; font-size: 13px;">ZIP *</label>
                        <input type="text" id="clientZip" required style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; box-sizing: border-box;" placeholder="75201" maxlength="10">
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #555; font-size: 13px;">Notes</label>
                    <textarea id="clientNotes" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; box-sizing: border-box; resize: vertical; min-height: 80px;" placeholder="Additional information..."></textarea>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button type="submit" style="flex: 1; background: #4caf50; color: white; border: none; padding: 12px; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer;">üíæ Save Client Info</button>
                    <button type="button" onclick="closeClientInfo()" style="flex: 0.5; background: #e0e0e0; color: #666; border: none; padding: 12px; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer;">Cancel</button>
                </div>
            </form>
            
            <div id="savedClientInfo" style="display: none; margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 8px; border-left: 4px solid #4caf50;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <strong style="color: #4caf50;">‚úì Saved Client Info:</strong>
                    <button onclick="clearClientInfo()" style="background: #ff5722; color: white; border: none; padding: 4px 10px; border-radius: 4px; font-size: 12px; cursor: pointer;">Clear</button>
                </div>
                <div id="clientInfoDisplay" style="font-size: 13px; color: #555; line-height: 1.6;"></div>
            </div>
        </div>
    </div>

    <!-- DATABASE MANAGER MODAL -->
    <div id="databaseManagerModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 40000; backdrop-filter: blur(4px);">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 12px; padding: 25px; width: 90%; max-width: 900px; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0; color: #333; font-size: 22px;">üíæ Database Manager</h2>
                <button onclick="closeDatabaseManager()" style="background: none; border: none; font-size: 28px; cursor: pointer; color: #666; padding: 0; width: 32px; height: 32px; line-height: 28px;">√ó</button>
            </div>
            
            <!-- Tabs -->
            <div style="display: flex; gap: 5px; margin-bottom: 20px; border-bottom: 2px solid #e0e0e0;">
                <button onclick="switchDbTab('presets')" id="dbTabPresets" class="db-tab active" style="padding: 10px 20px; border: none; background: none; cursor: pointer; font-weight: 600; border-bottom: 3px solid #ff9800;">üìç Price Presets</button>
                <button onclick="switchDbTab('edit')" id="dbTabEdit" class="db-tab" style="padding: 10px 20px; border: none; background: none; cursor: pointer; font-weight: 600; border-bottom: 3px solid transparent;">‚úèÔ∏è Edit Items</button>
                <button onclick="switchDbTab('import')" id="dbTabImport" class="db-tab" style="padding: 10px 20px; border: none; background: none; cursor: pointer; font-weight: 600; border-bottom: 3px solid transparent;">üì• Import</button>
                <button onclick="switchDbTab('add')" id="dbTabAdd" class="db-tab" style="padding: 10px 20px; border: none; background: none; cursor: pointer; font-weight: 600; border-bottom: 3px solid transparent;">‚ûï Add Item</button>
            </div>
            
            <!-- PRESETS TAB -->
            <div id="dbContentPresets" class="db-content">
                <h3 style="margin: 0 0 15px 0; color: #555;">Select Price Preset:</h3>
                <div style="display: grid; gap: 15px;">
                    <div onclick="applyPricePreset('default')" style="padding: 20px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer; transition: all 0.3s;" onmouseover="this.style.borderColor='#ff9800'; this.style.background='#fff8f0'" onmouseout="this.style.borderColor='#e0e0e0'; this.style.background='white'">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <div style="font-size: 40px;">üèóÔ∏è</div>
                            <div style="flex: 1;">
                                <strong style="font-size: 16px; color: #333;">Default National Averages</strong>
                                <p style="margin: 5px 0 0 0; color: #666; font-size: 13px;">General construction costs - good starting point</p>
                            </div>
                            <div id="presetDefaultCheck" style="display: none; color: #4caf50; font-size: 24px;">‚úì</div>
                        </div>
                    </div>
                    
                    <div onclick="applyPricePreset('dallas')" style="padding: 20px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer; transition: all 0.3s;" onmouseover="this.style.borderColor='#ff9800'; this.style.background='#fff8f0'" onmouseout="this.style.borderColor='#e0e0e0'; this.style.background='white'">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <div style="font-size: 40px;">ü§†</div>
                            <div style="flex: 1;">
                                <strong style="font-size: 16px; color: #333;">Dallas, TX Market Rates</strong>
                                <p style="margin: 5px 0 0 0; color: #666; font-size: 13px;">Adjusted for Dallas-Fort Worth area pricing (~15% lower labor)</p>
                            </div>
                            <div id="presetDallasCheck" style="display: none; color: #4caf50; font-size: 24px;">‚úì</div>
                        </div>
                    </div>
                    
                    <div onclick="applyPricePreset('custom')" style="padding: 20px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer; transition: all 0.3s;" onmouseover="this.style.borderColor='#ff9800'; this.style.background='#fff8f0'" onmouseout="this.style.borderColor='#e0e0e0'; this.style.background='white'">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <div style="font-size: 40px;">‚öôÔ∏è</div>
                            <div style="flex: 1;">
                                <strong style="font-size: 16px; color: #333;">My Custom Prices</strong>
                                <p style="margin: 5px 0 0 0; color: #666; font-size: 13px;">Your manually edited or imported pricing</p>
                            </div>
                            <div id="presetCustomCheck" style="display: none; color: #4caf50; font-size: 24px;">‚úì</div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: #e3f2fd; border-left: 4px solid #2196f3; border-radius: 4px;">
                    <strong style="color: #1976d2;">üí° Tip:</strong> Start with a preset, then use "Edit Items" to fine-tune specific prices for your market.
                </div>
            </div>
            
            <!-- EDIT ITEMS TAB -->
            <div id="dbContentEdit" class="db-content" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <input type="text" id="dbSearchItems" placeholder="üîç Search items..." oninput="filterDatabaseItems(this.value)" style="flex: 1; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; margin-right: 10px;">
                    <button onclick="exportDatabase()" style="padding: 8px 16px; background: #4caf50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">üì§ Export CSV</button>
                </div>
                
                <div id="databaseItemsList" style="max-height: 400px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 6px;">
                    <!-- Populated by JavaScript -->
                </div>
                
                <div style="margin-top: 15px; display: flex; gap: 10px;">
                    <button onclick="saveDatabaseChanges()" style="flex: 1; padding: 12px; background: #4caf50; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 15px;">üíæ Save All Changes</button>
                    <button onclick="resetToPreset()" style="padding: 12px 20px; background: #ff5722; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 15px;">üîÑ Reset</button>
                </div>
            </div>
            
            <!-- IMPORT TAB -->
            <div id="dbContentImport" class="db-content" style="display: none;">
                <h3 style="margin: 0 0 15px 0; color: #555;">Import Your Price List</h3>
                
                <div style="padding: 20px; background: #f5f5f5; border-radius: 8px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0; color: #333;">üìã CSV Format:</h4>
                    <p style="margin: 0 0 10px 0; color: #666; font-size: 13px;">Your CSV should have these columns (header row required):</p>
                    <div style="background: white; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 12px; color: #333; margin-bottom: 10px;">
                        name,category,unit,unit_price,description
                    </div>
                    <p style="margin: 0 0 10px 0; color: #666; font-size: 13px;"><strong>Example row:</strong></p>
                    <div style="background: white; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 12px; color: #333;">
                        2x4 Studs 8ft,framing,EA,3.50,Standard 2x4x8 lumber
                    </div>
                    <p style="margin: 10px 0 0 0; color: #666; font-size: 13px;"><strong>Categories:</strong> drywall, framing, insulation, paint, flooring, doors, electrical, plumbing, other</p>
                </div>
                
                <div style="border: 2px dashed #2196f3; border-radius: 8px; padding: 30px; text-align: center; background: #f5f9ff;">
                    <input type="file" id="csvFileInput" accept=".csv,.txt" style="display: none;" onchange="handleCsvImport(event)">
                    <button onclick="document.getElementById('csvFileInput').click()" style="padding: 15px 30px; background: #2196f3; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">
                        üìÅ Choose CSV File
                    </button>
                    <p style="margin: 15px 0 0 0; color: #666; font-size: 13px;">Click to select your price list CSV file</p>
                </div>
                
                <div id="importPreview" style="display: none; margin-top: 20px; padding: 15px; background: #e8f5e9; border-radius: 8px; border-left: 4px solid #4caf50;">
                    <strong style="color: #2e7d32;">‚úì Import Preview:</strong>
                    <div id="importPreviewContent" style="margin-top: 10px; font-size: 13px; color: #555;"></div>
                    <button onclick="confirmImport()" style="margin-top: 15px; padding: 10px 20px; background: #4caf50; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">‚úì Confirm Import</button>
                </div>
            </div>
            
            <!-- ADD ITEM TAB -->
            <div id="dbContentAdd" class="db-content" style="display: none;">
                <h3 style="margin: 0 0 15px 0; color: #555;">Add New Item</h3>
                
                <form id="addItemForm" onsubmit="addNewDatabaseItem(event); return false;">
                    <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #555; font-size: 13px;">Item Name *</label>
                            <input type="text" id="newItemName" required style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #555; font-size: 13px;">Category *</label>
                            <select id="newItemCategory" required style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                                <option value="drywall">Drywall</option>
                                <option value="framing">Framing</option>
                                <option value="insulation">Insulation</option>
                                <option value="paint">Paint</option>
                                <option value="flooring">Flooring</option>
                                <option value="doors">Doors/Windows</option>
                                <option value="electrical">Electrical</option>
                                <option value="plumbing">Plumbing</option>
                                <option value="other">Other</option>
                            </select>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #555; font-size: 13px;">Unit *</label>
                            <input type="text" id="newItemUnit" required placeholder="SF, LF, EA, etc." style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #555; font-size: 13px;">Unit Price * ($)</label>
                            <input type="number" id="newItemPrice" required step="0.01" min="0" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #555; font-size: 13px;">Description</label>
                        <input type="text" id="newItemDescription" placeholder="Brief description of the item" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                    </div>
                    
                    <button type="submit" style="width: 100%; padding: 12px; background: #4caf50; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 15px;">‚ûï Add Item to Database</button>
                </form>
            </div>
        </div>
    </div>

    <!-- ITEM BUILDER MODAL -->
    <div id="itemBuilderModal" class="item-builder-modal" style="display: none;">
        <div class="item-builder-container">
            <div class="item-builder-header">
                <h2>üõ†Ô∏è Build Your Estimate</h2>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button onclick="estimatorIntegration.closeItemBuilder()" 
                            style="padding: 10px 20px; background: rgba(255,255,255,0.2); border: 2px solid white; color: white; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s;"
                            onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'"
                            title="Return to floor plan (your work is saved)">
                        üìê View Floor Plan
                    </button>
                    <button onclick="estimatorIntegration.closeItemBuilder()" class="close-btn" title="Close (work saved)">‚úï</button>
                </div>
            </div>
            
            <div class="item-builder-body">
                <!-- Left Panel: Available Items -->
                <div class="available-items-panel">
                    <h3>üì¶ Available Items</h3>
                    <div class="search-box">
                        <input type="text" id="itemSearch" placeholder="üîç Search items..." oninput="estimatorIntegration.filterItems(this.value)">
                    </div>
                    
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <button onclick="estimatorIntegration.showCategory('favorites')" 
                                style="flex: 1; padding: 8px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                            ‚≠ê Favorites (<span id="favCount">0</span>)
                        </button>
                        <button onclick="estimatorIntegration.showCategory('recent')" 
                                style="flex: 1; padding: 8px; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                            üïê Recent (<span id="recentCount">0</span>)
                        </button>
                        <button onclick="estimatorIntegration.showTemplates()" 
                                style="flex: 1; padding: 8px; background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                            üìã Templates
                        </button>
                    </div>
                    
                    <div class="category-tabs" id="categoryTabs">
                        <button class="category-tab active" onclick="estimatorIntegration.showCategory('all')">All Items</button>
                        <button class="category-tab" onclick="estimatorIntegration.showCategory('drywall')">Drywall</button>
                        <button class="category-tab" onclick="estimatorIntegration.showCategory('framing')">Framing</button>
                        <button class="category-tab" onclick="estimatorIntegration.showCategory('insulation')">Insulation</button>
                        <button class="category-tab" onclick="estimatorIntegration.showCategory('paint')">Paint</button>
                        <button class="category-tab" onclick="estimatorIntegration.showCategory('flooring')">Flooring</button>
                        <button class="category-tab" onclick="estimatorIntegration.showCategory('doors')">Doors/Windows</button>
                        <button class="category-tab" onclick="estimatorIntegration.showCategory('electrical')">Electrical</button>
                        <button class="category-tab" onclick="estimatorIntegration.showCategory('plumbing')">Plumbing</button>
                        <button class="category-tab" onclick="estimatorIntegration.showCategory('roofing')">Roofing</button>
                        <button class="category-tab" onclick="estimatorIntegration.showCategory('hvac')">HVAC</button>
                        <button class="category-tab" onclick="estimatorIntegration.showCategory('exterior')">Exterior</button>
                        <button class="category-tab" onclick="estimatorIntegration.showCategory('cabinets')">Cabinets</button>
                        <button class="category-tab" onclick="estimatorIntegration.showCategory('appliances')">Appliances</button>
                        <button class="category-tab" onclick="estimatorIntegration.showCategory('concrete')">Concrete</button>
                        <button class="category-tab" onclick="estimatorIntegration.showCategory('landscaping')">Landscaping</button>
                        <button class="category-tab" onclick="estimatorIntegration.showCategory('other')">Other</button>
                    </div>
                    
                    <div class="items-list" id="availableItemsList">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>
                
                <!-- Right Panel: Selected Items -->
                <div class="selected-items-panel">
                    <h3>‚úÖ Selected Items for Estimate</h3>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div class="selected-count" id="selectedCount">0 items selected</div>
                        <button onclick="if(confirm('Clear all selected items?')) { estimatorIntegration.clearAllItems(); }"
                                style="padding: 6px 12px; background: #f44336; color: white; border: none; border-radius: 4px; font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.2s;"
                                onmouseover="this.style.background='#d32f2f'" onmouseout="this.style.background='#f44336'"
                                title="Remove all items and start fresh">
                            üóëÔ∏è Clear All
                        </button>
                    </div>
                    
                    <!-- INSURANCE SETTINGS - ALWAYS VISIBLE AT TOP -->
                    <div style="background: #e3f2fd; padding: 10px; border-radius: 6px; margin: 10px 0; border: 2px solid #2196f3;">
                        <div style="font-size: 12px; font-weight: 700; color: #1976d2; margin-bottom: 8px;">üíº Insurance Claim Settings</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                            <div>
                                <label style="display: block; margin-bottom: 3px; font-size: 10px; font-weight: bold; color: #555;">
                                    Depreciation (%)
                                </label>
                                <input type="number" step="0.01" min="0" max="100" value="0.00" id="depreciationInputTop"
                                       onchange="estimatorIntegration.updateDepreciation(this.value); document.getElementById('depreciationInput').value = this.value;"
                                       style="width: 100%; padding: 5px; border: 2px solid #ddd; border-radius: 4px; font-size: 12px; box-sizing: border-box;">
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 3px; font-size: 10px; font-weight: bold; color: #555;">
                                    Deductible ($)
                                </label>
                                <input type="number" step="0.01" min="0" value="0.00" id="deductibleInputTop"
                                       onchange="estimatorIntegration.updateDeductible(this.value); document.getElementById('deductibleInput').value = this.value;"
                                       style="width: 100%; padding: 5px; border: 2px solid #ddd; border-radius: 4px; font-size: 12px; box-sizing: border-box;">
                            </div>
                        </div>
                    </div>
                    
                    <div class="selected-items-list" id="selectedItemsList">
                        <div class="empty-state">
                            <p>üëà Click items from the left to add them to your estimate</p>
                            <p style="font-size: 12px; color: #666;">You can edit quantities and prices after adding</p>
                        </div>
                    </div>
                    
                    <div class="estimate-total" id="estimateTotal">
                        <div class="total-row"><span>Subtotal:</span> <span id="subtotalAmount">$0.00</span></div>
                        <div class="total-row"><span>Tax (<span id="taxRateDisplay">8.00</span>%):</span> <span id="taxAmount">$0.00</span></div>
                        <div class="total-row"><span>O&P (<span id="opRateDisplay">20.00</span>%):</span> <span id="opAmount">$0.00</span></div>
                        <div class="total-row grand-total"><span>TOTAL (RCV):</span> <span id="grandTotal">$0.00</span></div>
                        
                        <div id="insuranceClaimSection" style="border-top: 2px solid #ddd; margin-top: 10px; padding-top: 10px; display: none;">
                            <div style="font-weight: 700; color: #555; margin-bottom: 8px; font-size: 13px;">üíº Insurance Claim:</div>
                            <div class="total-row"><span>Less Depreciation:</span> <span id="depreciationAmount">($0.00)</span></div>
                            <div class="total-row" style="font-weight: 600;"><span>Actual Cash Value:</span> <span id="acvAmount">$0.00</span></div>
                            <div class="total-row"><span>Less Deductible:</span> <span id="deductibleAmount">($0.00)</span></div>
                            <div class="total-row grand-total" style="background: #4caf50; color: white;"><span>Net Claim:</span> <span id="netClaimAmount">$0.00</span></div>
                            <div style="margin-top: 8px; padding: 8px; background: #fff3cd; border-left: 3px solid #ffc107; font-size: 12px;">
                                <strong>Recoverable Depreciation:</strong> <span id="recoverableDepreciation">$0.00</span><br>
                                <strong>Net if Recovered:</strong> <span id="netIfRecovered">$0.00</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="estimate-settings" style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #333;">‚öôÔ∏è Settings</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>
                                <label style="display: block; margin-bottom: 5px; font-size: 12px; font-weight: bold; color: #555;">
                                    Sales Tax Rate (%)
                                </label>
                                <input type="number" step="0.01" min="0" max="20" value="8.00" id="taxRateInput"
                                       onchange="estimatorIntegration.updateTaxRate(this.value)"
                                       style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 5px; font-size: 12px; font-weight: bold; color: #555;">
                                    O&P Rate (%)
                                </label>
                                <input type="number" step="0.01" min="0" max="50" value="20.00" id="opRateInput"
                                       onchange="estimatorIntegration.updateOPRate(this.value)"
                                       style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                            </div>
                        </div>
                        <div style="border-top: 1px solid #ddd; margin: 10px 0; padding-top: 10px;">
                            <h4 style="margin: 0 0 10px 0; font-size: 13px; color: #555;">üíº Insurance Claim Settings</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-size: 12px; font-weight: bold; color: #555;">
                                        Depreciation (%)
                                    </label>
                                    <input type="number" step="0.01" min="0" max="100" value="0.00" id="depreciationInput"
                                           onchange="estimatorIntegration.updateDepreciation(this.value)"
                                           style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                                </div>
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-size: 12px; font-weight: bold; color: #555;">
                                        Deductible ($)
                                    </label>
                                    <input type="number" step="0.01" min="0" value="0.00" id="deductibleInput"
                                           onchange="estimatorIntegration.updateDeductible(this.value)"
                                           style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 8px; font-size: 11px; color: #666;">
                            üí° Tax/O&P for pricing | Depreciation/Deductible for insurance claims
                        </div>
                    </div>
                    
                    <!-- MARKUP/DISCOUNT -->
                    <div style="background: #fff3cd; padding: 12px; border-radius: 8px; margin: 15px 0; border-left: 3px solid #ffc107;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <label style="font-size: 12px; font-weight: bold; color: #333;">
                                üí∞ Markup/Discount (%)
                            </label>
                            <button onclick="estimatorIntegration.applyMarkup()" 
                                    style="padding: 4px 10px; background: #4caf50; color: white; border: none; border-radius: 4px; font-size: 11px; font-weight: 600; cursor: pointer;">
                                Apply
                            </button>
                        </div>
                        <input type="number" step="0.01" value="0" id="markupInput"
                               placeholder="Enter % (positive for markup, negative for discount)"
                               style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
                        <div style="font-size: 10px; color: #666; margin-top: 5px;">
                            Example: 10 = 10% markup | -15 = 15% discount
                        </div>
                    </div>
                    
                    <div class="action-buttons">
                        <button onclick="estimatorIntegration.addCustomItem()" class="btn-secondary">
                            ‚ûï Add Custom Item
                        </button>
                        <button onclick="estimatorIntegration.duplicateEstimate()" class="btn-secondary" 
                                style="background: #9c27b0; border-color: #9c27b0;">
                            üìã Duplicate
                        </button>
                        <button onclick="estimatorIntegration.generateFromSelected()" class="btn-primary">
                            üìä Generate Estimate
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept=".json" style="display:none;">

    <div class="placement-dialog" id="placementDialog">
        <div class="dialog-title" id="dialogTitle">Add Door</div>
        
        <div class="dialog-field">
            <label>Width (inches)</label>
            <input type="number" id="featureWidth" value="36" min="1" max="240" step="1" onchange="updatePositionPreview()">
        </div>

        <div class="dialog-field" id="heightField" style="display: none;">
            <label id="heightFieldLabel">Height from Floor (feet)</label>
            <input type="number" id="featureHeight" value="3.0" min="0" max="12" step="0.1">
            <small id="heightHelpText" style="color: #666; font-size: 11px; display: block; margin-top: 4px;">Enter 0 for floor-level windows</small>
        </div>

        <div class="dialog-field" id="windowHeightField" style="display: none;">
            <label>Window Height (inches)</label>
            <input type="number" id="featureWindowHeight" value="36" min="12" max="120" step="6">
        </div>

        <div style="border-top: 1px solid #ddd; margin: 15px 0; padding-top: 15px;">
            <div style="font-weight: 600; margin-bottom: 10px; color: #555;">üìè Position on Wall</div>
            
            <div class="dialog-field">
                <label>Measure From</label>
                <select id="positionReference" onchange="updatePositionPreview()">
                    <option value="left">Left Corner</option>
                    <option value="right">Right Corner</option>
                </select>
            </div>

            <div class="dialog-field">
                <label>Distance from Corner (feet)</label>
                <input type="number" id="distanceFromCorner" value="0" min="0" step="0.1" onchange="updatePositionPreview()">
                <small id="wallLengthInfo" style="color: #666; font-size: 11px; display: block; margin-top: 4px;">Wall length: 0 ft</small>
            </div>

            <div style="padding: 8px; background: #f0f7ff; border-radius: 6px; font-size: 12px; color: #666; margin-top: 10px;">
                <div id="positionPreview">Position: Left edge at 0 ft</div>
            </div>
        </div>

        <div class="dialog-buttons">
            <button class="dialog-btn dialog-btn-secondary" onclick="cancelPlacement()">Cancel</button>
            <button class="dialog-btn dialog-btn-primary" onclick="confirmPlacement()">Place</button>
        </div>
    </div>

    <script>
        // =================================================================
        // VERSION CHECK - v3.64
        // =================================================================
        console.log('%cüéØ PROPERTY ESTIMATOR v3.64 - LIDAR IMPORT FIXED', 'background: #4caf50; color: white; font-size: 16px; font-weight: bold; padding: 10px;');
        console.log('%c‚úÖ FIXED: Added visible "Process & Create Room" button after file loads', 'color: #4caf50; font-size: 14px; font-weight: bold;');
        console.log('%c‚úÖ FIXED: Better error handling and error display', 'color: #4caf50; font-size: 14px; font-weight: bold;');
        console.log('%c‚úÖ FIXED: Console logging to debug issues (F12 to see)', 'color: #4caf50; font-size: 14px; font-weight: bold;');
        console.log('');
        
        // =================================================================
        // GLOBAL ESTIMATOR TOGGLE - MUST BE FIRST FOR INLINE ONCLICK
        // =================================================================
        window.toggleEstimatorMenu = function() {
            console.log('üñ±Ô∏è Estimator button clicked!');
            const menu = document.getElementById('estimatorMenu');
            if (menu) {
                const wasOpen = menu.classList.contains('open');
                menu.classList.toggle('open');
                console.log('üìä Menu toggled from', wasOpen, 'to', !wasOpen);
            } else {
                console.error('‚ùå Menu element not found!');
                alert('Error: Menu not found. Please refresh the page.');
            }
        };
        
        // =================================================================
        // ZOOM FUNCTIONS - MUST BE GLOBAL FOR INLINE ONCLICK
        // =================================================================
        window.zoomAll = function() {
            console.log('üîçüîçüîç Zoom All BUTTON CLICKED!');
            console.log('State exists:', typeof state !== 'undefined');
            console.log('State.rooms exists:', state && state.rooms);
            
            if (typeof state === 'undefined' || !state.rooms) {
                console.error('‚ùå State not ready');
                alert('Error: State not ready. Please wait for the page to load.');
                return;
            }
            
            console.log('Number of rooms:', state.rooms.length);
            
            // Calculate bounding box of all rooms
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let hasContent = false;
            
            state.rooms.forEach((room, idx) => {
                console.log(`Room ${idx}: ${room.floorPoints ? room.floorPoints.length : 0} points`);
                if (room.floorPoints && room.floorPoints.length > 0) {
                    room.floorPoints.forEach(p => {
                        const offsetX = (room.positionX || 0) * 30;
                        const offsetY = (room.positionZ || 0) * 30;
                        
                        minX = Math.min(minX, p.x + offsetX);
                        maxX = Math.max(maxX, p.x + offsetX);
                        minY = Math.min(minY, p.y + offsetY);
                        maxY = Math.max(maxY, p.y + offsetY);
                        hasContent = true;
                    });
                }
            });
            
            console.log('Has content:', hasContent);
            console.log('Bounds:', { minX, maxX, minY, maxY });
            
            if (!hasContent) {
                showToast('‚ö†Ô∏è No content to zoom to', 2000);
                console.log('‚ùå No content found');
                return;
            }
            
            // Add padding
            const padding = 100;
            minX -= padding;
            maxX += padding;
            minY -= padding;
            maxY += padding;
            
            // Calculate required zoom to fit content
            const canvas = document.getElementById('canvas2D');
            if (!canvas) {
                console.error('‚ùå Canvas not found!');
                alert('Error: Canvas not found');
                return;
            }
            
            const contentWidth = maxX - minX;
            const contentHeight = maxY - minY;
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            console.log('Canvas size:', canvasWidth, 'x', canvasHeight);
            console.log('Content size:', contentWidth, 'x', contentHeight);
            
            const zoomX = canvasWidth / contentWidth;
            const zoomY = canvasHeight / contentHeight;
            state.zoom = Math.min(zoomX, zoomY, 2);
            
            // Center the content
            const contentCenterX = (minX + maxX) / 2;
            const contentCenterY = (minY + maxY) / 2;
            
            state.panX = canvasWidth / 2 - contentCenterX * state.zoom;
            state.panY = canvasHeight / 2 - contentCenterY * state.zoom;
            
            console.log('‚úÖ Zoom set to:', state.zoom);
            console.log('‚úÖ Pan set to:', state.panX, state.panY);
            
            document.getElementById('zoomLevel').textContent = Math.round(state.zoom * 100) + '%';
            
            if (typeof redraw2D === 'function') {
                redraw2D();
            } else {
                console.error('‚ùå redraw2D not found');
            }
            
            showToast('üîç Zoomed to fit all content', 2000);
        };
        
        window.startZoomWindow = function() {
            console.log('‚¨ö Zoom Window clicked!');
            if (typeof state === 'undefined') {
                console.error('State not ready');
                return;
            }
            
            // Clear other modes
            if (typeof clearActiveToolMode !== 'undefined') {
                clearActiveToolMode();
            }
            
            // Activate zoom window mode
            state.zoomWindowMode = true;
            state.zoomWindowStart = null;
            state.zoomWindowEnd = null;
            
            const zoomBtn = document.getElementById('zoomWindowBtn');
            if (zoomBtn) {
                zoomBtn.classList.add('toolbar-btn-active');
            }
            
            const canvas = document.getElementById('canvas2D');
            canvas.style.cursor = 'crosshair';
            
            const banner = document.getElementById('instructionBanner');
            if (banner) {
                banner.textContent = '‚¨ö ZOOM WINDOW - Click and drag to select area';
                banner.style.display = 'block';
                banner.style.background = '#9C27B0';
                banner.style.color = 'white';
            }
            
            showToast('‚¨ö Click and drag to select zoom area', 3000);
        };
        
        window.executeZoomWindow = function(x1, y1, x2, y2) {
            console.log('Executing zoom window:', x1, y1, x2, y2);
            
            // Convert screen coordinates to world coordinates
            const worldX1 = (x1 - state.panX) / state.zoom;
            const worldY1 = (y1 - state.panY) / state.zoom;
            const worldX2 = (x2 - state.panX) / state.zoom;
            const worldY2 = (y2 - state.panY) / state.zoom;
            
            // Calculate bounding box
            const minX = Math.min(worldX1, worldX2);
            const maxX = Math.max(worldX1, worldX2);
            const minY = Math.min(worldY1, worldY2);
            const maxY = Math.max(worldY1, worldY2);
            
            // Add small padding
            const padding = 20;
            const contentWidth = maxX - minX + padding * 2;
            const contentHeight = maxY - minY + padding * 2;
            
            if (contentWidth < 10 || contentHeight < 10) {
                showToast('‚ùå Selection too small - drag larger area', 2000);
                return;
            }
            
            // Calculate zoom to fit selected area
            const canvas = document.getElementById('canvas2D');
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            const zoomX = canvasWidth / contentWidth;
            const zoomY = canvasHeight / contentHeight;
            state.zoom = Math.min(zoomX, zoomY, 5); // Cap at 5x zoom
            
            // Center the selected area
            const contentCenterX = (minX + maxX) / 2;
            const contentCenterY = (minY + maxY) / 2;
            
            state.panX = canvasWidth / 2 - contentCenterX * state.zoom;
            state.panY = canvasHeight / 2 - contentCenterY * state.zoom;
            
            // Clear zoom window mode
            state.zoomWindowMode = false;
            state.zoomWindowStart = null;
            state.zoomWindowEnd = null;
            
            const zoomBtn = document.getElementById('zoomWindowBtn');
            if (zoomBtn) {
                zoomBtn.classList.remove('toolbar-btn-active');
            }
            
            canvas.style.cursor = 'default';
            
            const banner = document.getElementById('instructionBanner');
            if (banner) {
                banner.style.display = 'none';
            }
            
            document.getElementById('zoomLevel').textContent = Math.round(state.zoom * 100) + '%';
            redraw2D();
            showToast(`üîç Zoomed ${state.zoom.toFixed(1)}x to selected area`, 2000);
        };
        
        // Client Info Functions
        window.clientInfoData = null;
        
        window.openClientInfo = function() {
            console.log('üë§ Opening client info modal');
            const modal = document.getElementById('clientInfoModal');
            if (modal) {
                modal.style.display = 'block';
                
                // POPULATE FROM CLAIM DATA IF AVAILABLE
                if (window.claimDataFromManager) {
                    console.log('üìã Populating form with claim data...');
                    
                    const data = window.claimDataFromManager;
                    
                    const clientNameField = document.getElementById('clientName');
                    const clientCompanyField = document.getElementById('clientCompany');
                    const clientEmailField = document.getElementById('clientEmail');
                    const clientPhoneField = document.getElementById('clientPhone');
                    const clientAddressField = document.getElementById('clientAddress');
                    const clientCityField = document.getElementById('clientCity');
                    const clientStateField = document.getElementById('clientState');
                    const clientZipField = document.getElementById('clientZip');
                    const clientNotesField = document.getElementById('clientNotes');
                    
                    if (clientNameField) clientNameField.value = data.clientName || '';
                    if (clientCompanyField) clientCompanyField.value = data.clientCompany || '';
                    if (clientEmailField) clientEmailField.value = data.clientEmail || '';
                    if (clientPhoneField) clientPhoneField.value = data.clientPhone || '';
                    if (clientAddressField) clientAddressField.value = data.clientAddress || '';
                    if (clientCityField) clientCityField.value = data.clientCity || '';
                    if (clientStateField) clientStateField.value = data.clientState || '';
                    if (clientZipField) clientZipField.value = data.clientZip || '';
                    if (clientNotesField) clientNotesField.value = data.clientNotes || '';
                    
                    console.log('‚úÖ Form populated with claim data!');
                    showToast('‚úì Client info loaded from claim');
                } else {
                    // Load saved data if exists
                    loadClientInfoFromStorage();
                }
            }
            // Close estimator menu
            const menu = document.getElementById('estimatorMenu');
            if (menu) menu.classList.remove('open');
        };
        
        window.closeClientInfo = function() {
            const modal = document.getElementById('clientInfoModal');
            if (modal) modal.style.display = 'none';
        };
        
        window.saveClientInfo = function(event) {
            event.preventDefault();
            
            const clientInfo = {
                name: document.getElementById('clientName').value,
                company: document.getElementById('clientCompany').value,
                email: document.getElementById('clientEmail').value,
                phone: document.getElementById('clientPhone').value,
                address: document.getElementById('clientAddress').value,
                city: document.getElementById('clientCity').value,
                state: document.getElementById('clientState').value,
                zip: document.getElementById('clientZip').value,
                notes: document.getElementById('clientNotes').value
            };
            
            window.clientInfoData = clientInfo;
            
            // Save to localStorage
            try {
                localStorage.setItem('clientInfo', JSON.stringify(clientInfo));
            } catch (e) {
                console.warn('Could not save to localStorage:', e);
            }
            
            displaySavedClientInfo(clientInfo);
            console.log('‚úÖ Client info saved:', clientInfo);
            
            alert('‚úì Client information saved!\n\nThis will be included in your estimates.');
        };
        
        window.clearClientInfo = function() {
            if (confirm('Clear saved client information?')) {
                window.clientInfoData = null;
                try {
                    localStorage.removeItem('clientInfo');
                } catch (e) {
                    console.warn('Could not clear localStorage:', e);
                }
                document.getElementById('clientInfoForm').reset();
                document.getElementById('savedClientInfo').style.display = 'none';
                console.log('üóëÔ∏è Client info cleared');
            }
        };
        
        function displaySavedClientInfo(clientInfo) {
            const displayDiv = document.getElementById('clientInfoDisplay');
            const savedDiv = document.getElementById('savedClientInfo');
            
            let html = `<strong>${clientInfo.name}</strong>`;
            if (clientInfo.company) html += `<br>${clientInfo.company}`;
            if (clientInfo.email) html += `<br>üìß ${clientInfo.email}`;
            if (clientInfo.phone) html += `<br>üì± ${clientInfo.phone}`;
            html += `<br>üìç ${clientInfo.address}, ${clientInfo.city}, ${clientInfo.state} ${clientInfo.zip}`;
            if (clientInfo.notes) html += `<br><em>Note: ${clientInfo.notes}</em>`;
            
            displayDiv.innerHTML = html;
            savedDiv.style.display = 'block';
        }
        
        function loadClientInfoFromStorage() {
            try {
                const saved = localStorage.getItem('clientInfo');
                if (saved) {
                    const clientInfo = JSON.parse(saved);
                    window.clientInfoData = clientInfo;
                    
                    // Fill form
                    document.getElementById('clientName').value = clientInfo.name || '';
                    document.getElementById('clientCompany').value = clientInfo.company || '';
                    document.getElementById('clientEmail').value = clientInfo.email || '';
                    document.getElementById('clientPhone').value = clientInfo.phone || '';
                    document.getElementById('clientAddress').value = clientInfo.address || '';
                    document.getElementById('clientCity').value = clientInfo.city || '';
                    document.getElementById('clientState').value = clientInfo.state || '';
                    document.getElementById('clientZip').value = clientInfo.zip || '';
                    document.getElementById('clientNotes').value = clientInfo.notes || '';
                    
                    displaySavedClientInfo(clientInfo);
                }
            } catch (e) {
                console.warn('Could not load from localStorage:', e);
            }
        }
        
        // Load on page load
        setTimeout(() => {
            try {
                const saved = localStorage.getItem('clientInfo');
                if (saved) {
                    window.clientInfoData = JSON.parse(saved);
                    console.log('‚úÖ Client info loaded from storage');
                }
            } catch (e) {
                console.warn('Could not load client info:', e);
            }
        }, 100);
        
        // ===================================================================
        // DATABASE MANAGER FUNCTIONS
        // ===================================================================
        
        window.currentPricePreset = 'default';
        window.customDatabase = null;
        window.pendingImportData = null;
        
        window.openDatabaseManager = function() {
            console.log('üíæ Opening database manager');
            const modal = document.getElementById('databaseManagerModal');
            if (modal) {
                modal.style.display = 'block';
                switchDbTab('presets');
                updatePresetCheckmarks();
            }
            // Close estimator menu
            const menu = document.getElementById('estimatorMenu');
            if (menu) menu.classList.remove('open');
        };
        
        window.closeDatabaseManager = function() {
            const modal = document.getElementById('databaseManagerModal');
            if (modal) modal.style.display = 'none';
        };
        
        window.switchDbTab = function(tab) {
            // Hide all content
            document.querySelectorAll('.db-content').forEach(el => el.style.display = 'none');
            // Remove active from all tabs
            document.querySelectorAll('.db-tab').forEach(el => {
                el.style.borderBottom = '3px solid transparent';
                el.style.color = '#666';
            });
            
            // Show selected content
            const content = document.getElementById('dbContent' + tab.charAt(0).toUpperCase() + tab.slice(1));
            const tabBtn = document.getElementById('dbTab' + tab.charAt(0).toUpperCase() + tab.slice(1));
            if (content) content.style.display = 'block';
            if (tabBtn) {
                tabBtn.style.borderBottom = '3px solid #ff9800';
                tabBtn.style.color = '#333';
            }
            
            // Load content for specific tabs
            if (tab === 'edit') {
                populateDatabaseItemsList();
            } else if (tab === 'presets') {
                updatePresetCheckmarks();
            }
        };
        
        function updatePresetCheckmarks() {
            document.getElementById('presetDefaultCheck').style.display = currentPricePreset === 'default' ? 'block' : 'none';
            document.getElementById('presetDallasCheck').style.display = currentPricePreset === 'dallas' ? 'block' : 'none';
            document.getElementById('presetCustomCheck').style.display = currentPricePreset === 'custom' ? 'block' : 'none';
        }
        
        window.applyPricePreset = function(preset) {
            console.log('üìç Applying price preset:', preset);
            currentPricePreset = preset;
            
            if (preset === 'dallas') {
                // Apply Dallas pricing (15% lower labor costs)
                applyDallasPricing();
            } else if (preset === 'custom') {
                // Load custom database
                try {
                    const saved = localStorage.getItem('customDatabase');
                    if (saved) {
                        customDatabase = JSON.parse(saved);
                        console.log('‚úÖ Custom database loaded');
                    } else {
                        alert('No custom database found. Start by importing or editing items.');
                    }
                } catch (e) {
                    console.error('Error loading custom database:', e);
                }
            }
            
            updatePresetCheckmarks();
            
            try {
                localStorage.setItem('currentPricePreset', preset);
            } catch (e) {
                console.warn('Could not save preset preference:', e);
            }
            
            alert('‚úì Preset applied: ' + preset + '\n\nThis will be used for new estimates.');
        };
        
        function applyDallasPricing() {
            // Dallas pricing adjustments (15% lower labor, similar materials)
            console.log('ü§† Applying Dallas market rates');
            // This will be used when building estimates
        }
        
        window.filterDatabaseItems = function(searchTerm) {
            const items = document.querySelectorAll('.db-item-row');
            searchTerm = searchTerm.toLowerCase();
            
            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(searchTerm) ? 'flex' : 'none';
            });
        };
        
        function populateDatabaseItemsList() {
            const container = document.getElementById('databaseItemsList');
            if (!container) return;
            
            const items = window.estimatorIntegration?.estimator?.itemDatabase || [];
            
            let html = '<div style="padding: 10px; background: #f5f5f5; font-weight: 600; display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 100px; gap: 10px; border-bottom: 2px solid #ddd;">';
            html += '<div>Item Name</div><div>Category</div><div>Unit</div><div>Price</div><div></div>';
            html += '</div>';
            
            items.forEach((item, index) => {
                html += `<div class="db-item-row" style="padding: 10px; display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 100px; gap: 10px; border-bottom: 1px solid #eee; align-items: center;">`;
                html += `<div><input type="text" value="${item.name}" id="dbItem${index}Name" style="width: 100%; padding: 5px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;"></div>`;
                html += `<div style="font-size: 12px; color: #666;">${item.category}</div>`;
                html += `<div style="font-size: 12px; color: #666;">${item.unit}</div>`;
                html += `<div><input type="number" value="${item.unit_price}" id="dbItem${index}Price" step="0.01" min="0" style="width: 100%; padding: 5px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;"></div>`;
                html += `<div><button onclick="deleteDbItem(${index})" style="padding: 5px 10px; background: #ff5722; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Delete</button></div>`;
                html += `</div>`;
            });
            
            container.innerHTML = html;
        }
        
        window.deleteDbItem = function(index) {
            if (confirm('Delete this item?')) {
                const items = window.estimatorIntegration?.estimator?.itemDatabase;
                if (items) {
                    items.splice(index, 1);
                    populateDatabaseItemsList();
                }
            }
        };
        
        window.saveDatabaseChanges = function() {
            const items = window.estimatorIntegration?.estimator?.itemDatabase;
            if (!items) return;
            
            let changes = 0;
            items.forEach((item, index) => {
                const nameInput = document.getElementById(`dbItem${index}Name`);
                const priceInput = document.getElementById(`dbItem${index}Price`);
                
                if (nameInput && nameInput.value !== item.name) {
                    item.name = nameInput.value;
                    changes++;
                }
                if (priceInput && parseFloat(priceInput.value) !== item.unit_price) {
                    item.unit_price = parseFloat(priceInput.value);
                    changes++;
                }
            });
            
            // Save to custom database
            try {
                localStorage.setItem('customDatabase', JSON.stringify(items));
                currentPricePreset = 'custom';
                updatePresetCheckmarks();
                console.log('‚úÖ Database changes saved');
                alert(`‚úì Saved ${changes} changes to custom database`);
            } catch (e) {
                console.error('Error saving database:', e);
                alert('Error saving changes');
            }
        };
        
        window.resetToPreset = function() {
            if (confirm('Reset database to current preset? This will discard unsaved changes.')) {
                populateDatabaseItemsList();
                console.log('üîÑ Database reset to preset');
            }
        };
        
        window.exportDatabase = function() {
            const items = window.estimatorIntegration?.estimator?.itemDatabase;
            if (!items) return;
            
            let csv = 'name,category,unit,unit_price,description\n';
            items.forEach(item => {
                csv += `"${item.name}","${item.category}","${item.unit}",${item.unit_price},"${item.description || ''}"\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'construction_database_' + new Date().toISOString().split('T')[0] + '.csv';
            a.click();
            URL.revokeObjectURL(url);
            
            console.log('üì§ Database exported to CSV');
        };
        
        window.handleCsvImport = function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const csv = e.target.result;
                parseCsvImport(csv);
            };
            reader.readAsText(file);
        };
        
        function parseCsvImport(csv) {
            const lines = csv.split('\n').filter(line => line.trim());
            const headers = lines[0].toLowerCase().split(',').map(h => h.trim().replace(/"/g, ''));
            
            const items = [];
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
                if (values.length < 4) continue;
                
                items.push({
                    name: values[0],
                    category: values[1],
                    unit: values[2],
                    unit_price: parseFloat(values[3]),
                    description: values[4] || ''
                });
            }
            
            window.pendingImportData = items;
            
            const preview = document.getElementById('importPreview');
            const content = document.getElementById('importPreviewContent');
            content.innerHTML = `
                <strong>${items.length} items</strong> ready to import<br>
                Categories: ${[...new Set(items.map(i => i.category))].join(', ')}
            `;
            preview.style.display = 'block';
            
            console.log('üì• CSV parsed:', items.length, 'items');
        }
        
        window.confirmImport = function() {
            if (!window.pendingImportData) return;
            
            if (window.estimatorIntegration?.estimator) {
                window.estimatorIntegration.estimator.itemDatabase = window.pendingImportData;
                
                try {
                    localStorage.setItem('customDatabase', JSON.stringify(window.pendingImportData));
                    currentPricePreset = 'custom';
                    console.log('‚úÖ Database imported and saved');
                    alert(`‚úì Successfully imported ${window.pendingImportData.length} items!`);
                    
                    document.getElementById('importPreview').style.display = 'none';
                    document.getElementById('csvFileInput').value = '';
                    window.pendingImportData = null;
                } catch (e) {
                    console.error('Error saving imported database:', e);
                    alert('Error saving imported data');
                }
            }
        };
        
        window.addNewDatabaseItem = function(event) {
            event.preventDefault();
            
            const newItem = {
                name: document.getElementById('newItemName').value,
                category: document.getElementById('newItemCategory').value,
                unit: document.getElementById('newItemUnit').value,
                unit_price: parseFloat(document.getElementById('newItemPrice').value),
                description: document.getElementById('newItemDescription').value
            };
            
            if (window.estimatorIntegration?.estimator) {
                window.estimatorIntegration.estimator.itemDatabase.push(newItem);
                
                try {
                    localStorage.setItem('customDatabase', JSON.stringify(window.estimatorIntegration.estimator.itemDatabase));
                    currentPricePreset = 'custom';
                    console.log('‚úÖ New item added:', newItem.name);
                    alert(`‚úì Added: ${newItem.name}`);
                    
                    document.getElementById('addItemForm').reset();
                } catch (e) {
                    console.error('Error saving new item:', e);
                    alert('Error saving new item');
                }
            }
        };
        
        // Load saved preset on page load
        setTimeout(() => {
            try {
                const saved = localStorage.getItem('currentPricePreset');
                if (saved) {
                    currentPricePreset = saved;
                    console.log('‚úÖ Price preset loaded:', saved);
                }
            } catch (e) {
                console.warn('Could not load price preset:', e);
            }
        }, 100);
        
        window.openEstimateBuilder = function() {
            console.log('üõ†Ô∏è Build Estimate clicked!');
            console.log('Checking estimatorIntegration:', window.estimatorIntegration);
            
            if (window.estimatorIntegration) {
                try {
                    // Close menu first
                    const menu = document.getElementById('estimatorMenu');
                    if (menu) menu.classList.remove('open');
                    
                    estimatorIntegration.openItemBuilder();
                    console.log('‚úÖ Item Builder opened successfully');
                } catch (error) {
                    console.error('‚ùå Error opening item builder:', error);
                    alert('Error opening Item Builder:\n\n' + error.message + '\n\nCheck console for details (F12)');
                }
            } else {
                console.error('‚ùå estimatorIntegration not ready!');
                console.log('Attempting to initialize now...');
                console.log('typeof EstimatorIntegration:', typeof EstimatorIntegration);
                
                // Try to initialize
                if (typeof EstimatorIntegration !== 'undefined') {
                    try {
                        console.log('üîß Manually creating EstimatorIntegration...');
                        window.estimatorIntegration = new EstimatorIntegration();
                        console.log('‚úÖ Initialized! Trying again...');
                        // Try again
                        setTimeout(function() {
                            window.openEstimateBuilder();
                        }, 100);
                        return;
                    } catch (e) {
                        console.error('‚ùå Failed to initialize:', e);
                        console.error('Error details:', e.message);
                        console.error('Stack:', e.stack);
                        alert('Failed to initialize:\n\n' + e.message + '\n\nCheck console (F12) for details');
                        return;
                    }
                } else {
                    console.error('‚ùå EstimatorIntegration class not found!');
                    console.error('typeof EstimatorIntegration:', typeof EstimatorIntegration);
                    console.error('typeof QuantityEstimator:', typeof QuantityEstimator);
                }
                
                alert('‚ö†Ô∏è Estimator not ready yet!\n\n' +
                      'The estimator is still initializing...\n\n' +
                      'Debug Info:\n' +
                      '‚Ä¢ EstimatorIntegration: ' + (typeof EstimatorIntegration) + '\n' +
                      '‚Ä¢ QuantityEstimator: ' + (typeof QuantityEstimator) + '\n' +
                      '‚Ä¢ Attempts: ' + (window.initAttempts || 0) + '\n\n' +
                      'What to do:\n' +
                      '‚Ä¢ Wait 2-3 seconds and try again\n' +
                      '‚Ä¢ Buttons will be enabled when ready\n' +
                      '‚Ä¢ Press F12 and type: debugEstimator()\n' +
                      '‚Ä¢ Refresh (F5) if this persists');
            }
        };
        
        window.openLoadSavedEstimate = function() {
            console.log('üìÇ Load Estimate clicked!');
            console.log('Checking estimatorIntegration:', window.estimatorIntegration);
            
            if (window.estimatorIntegration) {
                try {
                    // Close menu first
                    const menu = document.getElementById('estimatorMenu');
                    if (menu) menu.classList.remove('open');
                    
                    estimatorIntegration.openLoadEstimateFromMain();
                    console.log('‚úÖ File picker opened successfully');
                } catch (error) {
                    console.error('‚ùå Error loading estimate:', error);
                    alert('Error loading estimate:\n\n' + error.message + '\n\nCheck console for details (F12)');
                }
            } else {
                console.error('‚ùå estimatorIntegration not ready!');
                console.log('Attempting to initialize now...');
                console.log('typeof EstimatorIntegration:', typeof EstimatorIntegration);
                
                // Try to initialize
                if (typeof EstimatorIntegration !== 'undefined') {
                    try {
                        console.log('üîß Manually creating EstimatorIntegration...');
                        window.estimatorIntegration = new EstimatorIntegration();
                        console.log('‚úÖ Initialized! Trying again...');
                        // Try again
                        setTimeout(function() {
                            window.openLoadSavedEstimate();
                        }, 100);
                        return;
                    } catch (e) {
                        console.error('‚ùå Failed to initialize:', e);
                        console.error('Error details:', e.message);
                        console.error('Stack:', e.stack);
                        alert('Failed to initialize:\n\n' + e.message + '\n\nCheck console (F12) for details');
                        return;
                    }
                } else {
                    console.error('‚ùå EstimatorIntegration class not found!');
                }
                
                alert('‚ö†Ô∏è Estimator not ready yet!\n\n' +
                      'The estimator is still initializing...\n\n' +
                      'What to do:\n' +
                      '‚Ä¢ Wait 2-3 seconds and try again\n' +
                      '‚Ä¢ Buttons will be enabled when ready\n' +
                      '‚Ä¢ Refresh (F5) if this persists\n\n' +
                      'The page should be ready in a moment!');
            }
        };
        
        console.log('‚úÖ Global estimator functions loaded');
        
        // =================================================================
        // STATE OBJECT
        // =================================================================
        const state = {
            currentView: '2d',
            rooms: [],
            currentRoomIndex: 0,
            currentFeature: null,
            zoom: 1,
            panX: 0,
            panY: 0,
            wallSelectionMode: false,
            pendingFeature: null,
            selectedWall: null,
            hoveredWall: null,
            clickPoint: null,
            showAllRooms: false,
            draggingRoom: null,
            dragStartX: 0,
            dragStartY: 0,
            dragStartRoomX: 0,
            dragStartRoomZ: 0,
            lastSnapped: false,
            snapType: '',
            draggingFeature: null,
            draggingFeatureType: null,
            draggingFeatureIndex: null,
            draggingFeatureWallIndex: null,
            potentialDragFeature: null,  // For tap vs drag detection
            potentialDragType: null,
            potentialDragIndex: null,
            potentialDragWallIndex: null,
            projectName: 'Untitled Project',
            orthoMode: false,
            wallDrawingCorners: [],
            zoomWindowMode: false,
            zoomWindowStart: null,
            zoomWindowEnd: null,
            roomEditMode: false,  // NEW: Room editing with handles
            draggingHandle: null,  // NEW: Which handle is being dragged
            hoveredHandle: null,   // NEW: Which handle is being hovered
            wallDragPreview: null,  // NEW: Preview of wall position while dragging (Xactimate-style)
            creatingAdjacentRoom: null,  // XACTIMATE: CTRL+Drag to create adjacent room
            adjacentRoomPreview: null,   // XACTIMATE: Preview of adjacent room being created
            currentLevel: 'Main Floor',  // NEW: Current level/floor being edited
            levels: ['Basement', 'Main Floor', '2nd Floor', '3rd Floor', 'Roof']  // NEW: Available levels
        };
        
        // Start with NO rooms - blank canvas
        // Users create rooms using the "New Room" button
        // Then click room name to activate handles
        // Regular drag = Expand room
        // CTRL + drag = Create new room
        
        // Make state accessible globally for integration with Claims Manager
        window.state = state;
        console.log('‚úÖ State initialized - ready to create rooms');
        
        // Undo system
        const undoStack = [];
        const redoStack = [];
        const maxUndoSteps = 50;
        
        function saveStateForUndo() {
            // Deep clone the rooms array
            const snapshot = JSON.parse(JSON.stringify(state.rooms));
            undoStack.push(snapshot);
            
            // Clear redo stack when new action is performed
            redoStack.length = 0;
            
            // Limit undo stack size
            if (undoStack.length > maxUndoSteps) {
                undoStack.shift();
            }
            
            console.log('Saved undo state, stack size:', undoStack.length);
        }
        
        function undo() {
            if (undoStack.length === 0) {
                showToast('‚ö†Ô∏è Nothing to undo');
                return;
            }
            
            // Save current state to redo stack before undoing
            const currentState = JSON.parse(JSON.stringify(state.rooms));
            redoStack.push(currentState);
            
            // Pop the last state
            const previousState = undoStack.pop();
            state.rooms = previousState;
            
            console.log('Undo performed, undo stack:', undoStack.length, 'redo stack:', redoStack.length);
            showToast('‚Ü∂ Undo');
            
            updateRoomList();
            redraw2D();
            if (state.currentView === '3d') {
                render3D();
            }
        }
        
        function undoMultiple(steps) {
            if (undoStack.length === 0) {
                showToast('‚ö†Ô∏è Nothing to undo');
                return;
            }
            
            const actualSteps = Math.min(steps, undoStack.length);
            
            // Go back specified number of steps
            for (let i = 0; i < actualSteps; i++) {
                if (undoStack.length > 0) {
                    const previousState = undoStack.pop();
                    state.rooms = previousState;
                }
            }
            
            console.log(`Undo ${actualSteps} steps performed, stack size:`, undoStack.length);
            showToast(`‚Ü∂ Undo ${actualSteps} step${actualSteps > 1 ? 's' : ''}`);
            
            updateRoomList();
            redraw2D();
            if (state.currentView === '3d') {
                render3D();
            }
        }
        
        function redo() {
            if (redoStack.length === 0) {
                showToast('‚ö†Ô∏è Nothing to redo');
                return;
            }
            
            // Save current state to undo stack before redoing
            const currentState = JSON.parse(JSON.stringify(state.rooms));
            undoStack.push(currentState);
            
            // Pop from redo stack
            const nextState = redoStack.pop();
            state.rooms = nextState;
            
            console.log('Redo performed, undo stack:', undoStack.length, 'redo stack:', redoStack.length);
            showToast('‚Ü∑ Redo');
            
            updateRoomList();
            redraw2D();
            if (state.currentView === '3d') {
                render3D();
            }
        }

        const canvas2D = document.getElementById('canvas2D');
        const ctx = canvas2D.getContext('2d');
        
        // Global click tracker for debugging
        window.addEventListener('click', (e) => {
            if (state.currentView === '3d') {
                console.log('üîç GLOBAL CLICK DETECTED in 3D mode');
                console.log('  Target:', e.target.tagName, e.target.id, e.target.className);
                console.log('  Position:', e.clientX, e.clientY);
                console.log('  Current scene children:', scene ? scene.children.length : 'scene not initialized');
            }
        }, true); // Capture phase to see ALL clicks
        let scene, camera, renderer;

        window.addEventListener('load', () => {
            console.log('Initializing Cochran Claims Tool...');
            
            resizeCanvas();
            init3D();
            
            // Start with blank canvas - no default room
            // Users create rooms using the "‚ûï New Room" button
            
            generateWallInputs();
            updateRoomList();
            updateModeIndicator();
            redraw2D(); // Initialize canvas rendering
            
            console.log('‚úÖ Canvas initialized and ready');
            
            // Add direct event listeners for zoom buttons
            document.getElementById('zoomInBtn').addEventListener('click', function() {
                console.log('Zoom In clicked');
                zoomIn();
            });
            
            document.getElementById('zoomOutBtn').addEventListener('click', function() {
                console.log('Zoom Out clicked');
                zoomOut();
            });
            
            console.log('‚úÖ Zoom buttons initialized');
            console.log('Tool ready!');
            
            // Initialize level selector (with retry to ensure DOM is ready)
            function initLevelButtons() {
                const selector = document.getElementById('levelSelector');
                if (selector) {
                    updateLevelButtons();
                    console.log('‚úÖ Level selector initialized - 5 levels available');
                } else {
                    console.warn('Level selector not found, retrying...');
                    setTimeout(initLevelButtons, 100);
                }
            }
            initLevelButtons();
        });

        window.addEventListener('resize', resizeCanvas);

        // Mouse wheel zoom for 2D canvas
        canvas2D.addEventListener('wheel', (e) => {
            if (state.currentView !== '2d') return; // Only handle in 2D mode
            
            e.preventDefault();
            const rect = canvas2D.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Zoom towards mouse position
            const worldX = (mouseX - state.panX) / state.zoom;
            const worldY = (mouseY - state.panY) / state.zoom;
            
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(5, state.zoom * delta));
            
            // Adjust pan to keep mouse position stable
            state.panX = mouseX - worldX * newZoom;
            state.panY = mouseY - worldY * newZoom;
            state.zoom = newZoom;
            
            document.getElementById('zoomLevel').textContent = Math.round(state.zoom * 100) + '%';
            redraw2D();
        }, { passive: false }); // CRITICAL: Non-passive to allow preventDefault

        // Mouse drag for panning 2D canvas
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let panStartPanX = 0;
        let panStartPanY = 0;
        
        // Hover state for delete mode
        let hoverClickPoint = null;
        let hoverDoorIndex = null;
        let hoverWindowIndex = null;

        canvas2D.addEventListener('mousedown', (e) => {
            if (state.currentView !== '2d') return; // Only handle in 2D mode
            
            const rect = canvas2D.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            const x = (clickX - state.panX) / state.zoom;
            const y = (clickY - state.panY) / state.zoom;
            
            // ===== ROOM EDIT MODE HANDLE DRAG START =====
            if (state.roomEditMode && state.hoveredHandle && e.button === 0) {
                const room = getCurrentRoom();
                if (room && room.floorPoints) {
                    // Save state for undo BEFORE starting to drag
                    saveStateForUndo();
                    
                    // XACTIMATE: CTRL + drag from edge handle = Create adjacent room
                    if (e.ctrlKey && state.hoveredHandle.type === 'edge') {
                        console.log('üéØ XACTIMATE MODE: CTRL+Drag to create adjacent room');
                        state.creatingAdjacentRoom = {
                            sourceRoom: room,
                            sourceRoomIndex: state.currentRoomIndex,
                            edgeIndex: state.hoveredHandle.index,
                            startX: x,
                            startY: y
                        };
                        canvas2D.style.cursor = 'copy';
                        return;
                    }
                    
                    if (state.hoveredHandle.type === 'corner') {
                        state.draggingHandle = {
                            type: 'corner',
                            index: state.hoveredHandle.index
                        };
                    } else if (state.hoveredHandle.type === 'edge') {
                        const edgeIndex = state.hoveredHandle.index;
                        const p1Index = edgeIndex;
                        const p2Index = (edgeIndex + 1) % room.floorPoints.length;
                        
                        state.draggingHandle = {
                            type: 'edge',
                            index: edgeIndex,
                            startX: x,
                            startY: y,
                            p1StartX: room.floorPoints[p1Index].x,
                            p1StartY: room.floorPoints[p1Index].y,
                            p2StartX: room.floorPoints[p2Index].x,
                            p2StartY: room.floorPoints[p2Index].y
                        };
                    }
                    console.log('Started dragging handle (undo saved):', state.draggingHandle);
                    return;
                }
            }
            
            // ===== ROOM NAME CLICK DETECTION - Activate handles like Xactimate =====
            // Allow clicking room names even when already in edit mode (for room switching)
            if (e.button === 0) {
                // Check all rooms to see if we clicked on a room name
                for (let i = 0; i < state.rooms.length; i++) {
                    const room = state.rooms[i];
                    if (room.nameBounds && room.floorPoints && room.floorPoints.length > 0) {
                        const centerX = room.nameBounds.x;
                        const centerY = room.nameBounds.y;
                        const halfWidth = room.nameBounds.width / 2;
                        const halfHeight = room.nameBounds.height / 2;
                        
                        // Check if click is within room name bounds
                        if (x >= centerX - halfWidth && x <= centerX + halfWidth &&
                            y >= centerY - halfHeight && y <= centerY + halfHeight) {
                            
                            // Switch to this room and activate edit mode
                            state.currentRoomIndex = i;
                            state.roomEditMode = true;
                            
                            // ONLY clear feature modes if we're NOT actively placing a feature
                            if (!state.currentFeature) {
                                state.wallSelectionMode = false;
                            }
                            
                            state.draggingHandle = null; // Clear any active handle dragging
                            state.hoveredHandle = null; // Clear handle hover
                            
                            // Clear toolbar buttons
                            document.querySelectorAll('.toolbar-btn').forEach(btn => {
                                btn.classList.remove('toolbar-btn-active');
                            });
                            
                            updateRoomList();
                            canvas2D.style.cursor = 'default';
                            
                            // Show room properties modal
                            showRoomProperties(i);
                            
                            console.log(`‚úÖ Clicked room name: ${room.name} - properties shown, handles activated`);
                            
                            redraw2D();
                            updateStats();
                            return;
                        }
                    }
                }
            }
            
            // ===== ROOM INTERIOR CLICK DETECTION - Click anywhere inside room to select =====
            if (e.button === 0) {
                // Check all rooms on current level to see if we clicked inside one
                const roomsOnLevel = state.rooms.filter(r => r.level === state.currentLevel);
                for (let i = 0; i < roomsOnLevel.length; i++) {
                    const room = roomsOnLevel[i];
                    if (room.floorPoints && room.floorPoints.length >= 3) {
                        // Check if click is inside this room's polygon
                        if (pointInPolygon({x, y}, room.floorPoints)) {
                            const globalIndex = state.rooms.indexOf(room);
                            
                            // Switch to this room and activate edit mode
                            state.currentRoomIndex = globalIndex;
                            state.roomEditMode = true;
                            
                            // ONLY clear feature modes if we're NOT actively placing a feature
                            if (!state.currentFeature) {
                                state.wallSelectionMode = false;
                            }
                            
                            state.draggingHandle = null;
                            state.hoveredHandle = null;
                            
                            // Clear toolbar buttons
                            document.querySelectorAll('.toolbar-btn').forEach(btn => {
                                btn.classList.remove('toolbar-btn-active');
                            });
                            
                            updateRoomList();
                            canvas2D.style.cursor = 'default';
                            
                            showToast(`‚úÖ ${room.name} selected - Drag handles to resize`, 2000);
                            
                            redraw2D();
                            updateStats();
                            return;
                        }
                    }
                }
            }
            
            // ===== ZOOM WINDOW MODE =====
            if (state.zoomWindowMode && e.button === 0) {
                state.zoomWindowStart = { x: clickX, y: clickY };
                state.zoomWindowEnd = { x: clickX, y: clickY };
                console.log('Zoom window start:', clickX, clickY);
                return;
            }
            
            // ===== EDIT MODE HANDLING =====
            if (editMode.active && e.button === 0) {
                const room = getCurrentRoom();
                if (!room) return;
                
                if (editMode.tool === 'select') {
                    // Check if clicking on a wall to edit length
                    for (let i = 0; i < room.walls.length; i++) {
                        const wall = room.walls[i];
                        const start = room.floorPoints[i];
                        const end = room.floorPoints[(i + 1) % room.floorPoints.length];
                        
                        // Calculate distance from click to wall line
                        const dist = pointToLineDistance(x, y, start.x, start.y, end.x, end.y);
                        
                        if (dist < 20) {  // 20 pixel tolerance
                            // Clicked on wall - prompt for new length
                            const currentLength = parseFloat(wall.length);
                            const newLength = prompt(`Edit wall length (feet):`, currentLength.toFixed(2));
                            
                            if (newLength && !isNaN(newLength) && parseFloat(newLength) > 0) {
                                wall.length = parseFloat(newLength).toFixed(2);
                                updateEditStatus(`‚úì Wall length updated to ${newLength}'`);
                                redraw2D();
                                if (state.currentView === '3d') render3D();
                            }
                            return;
                        }
                    }
                } else if (editMode.tool === 'force90') {
                    // Select two adjacent walls to make them 90¬∞
                    for (let i = 0; i < room.walls.length; i++) {
                        const start = room.floorPoints[i];
                        const end = room.floorPoints[(i + 1) % room.floorPoints.length];
                        
                        const dist = pointToLineDistance(x, y, start.x, start.y, end.x, end.y);
                        
                        if (dist < 20) {
                            // Check if walls are adjacent
                            if (editMode.selectedWalls.length === 0) {
                                // First wall selected
                                editMode.selectedWalls.push(i);
                                updateEditStatus(`‚úì Wall ${i + 1} selected. Now click the adjacent wall to make it 90¬∞.`);
                                redraw2D();
                            } else if (editMode.selectedWalls.length === 1) {
                                const firstWall = editMode.selectedWalls[0];
                                
                                // Check if walls are adjacent
                                const isAdjacent = (i === (firstWall + 1) % room.walls.length) || 
                                                  (i === (firstWall - 1 + room.walls.length) % room.walls.length);
                                
                                if (!isAdjacent) {
                                    updateEditStatus(`‚ùå Walls must be adjacent! Selected wall ${firstWall + 1}, clicked wall ${i + 1}.`);
                                    return;
                                }
                                
                                // Show modal to choose direction
                                showForce90Modal(firstWall, i);
                            }
                            return;
                        }
                    }
                } else if (editMode.tool === 'deleteWall') {
                    // Check if clicking on a wall to delete
                    for (let i = 0; i < room.walls.length; i++) {
                        const start = room.floorPoints[i];
                        const end = room.floorPoints[(i + 1) % room.floorPoints.length];
                        
                        const dist = pointToLineDistance(x, y, start.x, start.y, end.x, end.y);
                        
                        if (dist < 20) {
                            if (room.walls.length <= 3) {
                                alert('Cannot delete wall - room must have at least 3 walls');
                                return;
                            }
                            
                            if (confirm(`Delete wall ${i + 1}?`)) {
                                room.walls.splice(i, 1);
                                room.floorPoints.splice(i, 1);
                                updateEditStatus(`‚úì Wall ${i + 1} deleted`);
                                redraw2D();
                                if (state.currentView === '3d') render3D();
                            }
                            return;
                        }
                    }
                } else if (editMode.tool === 'addDoor') {
                    // Find nearest wall and add door
                    let nearestWall = -1;
                    let minDist = Infinity;
                    
                    for (let i = 0; i < room.walls.length; i++) {
                        const start = room.floorPoints[i];
                        const end = room.floorPoints[(i + 1) % room.floorPoints.length];
                        const dist = pointToLineDistance(x, y, start.x, start.y, end.x, end.y);
                        
                        if (dist < minDist) {
                            minDist = dist;
                            nearestWall = i;
                        }
                    }
                    
                    if (nearestWall >= 0 && minDist < 50) {
                        const start = room.floorPoints[nearestWall];
                        const end = room.floorPoints[(nearestWall + 1) % room.floorPoints.length];
                        const dx = end.x - start.x;
                        const dy = end.y - start.y;
                        const wallLength = Math.sqrt(dx * dx + dy * dy);
                        const positionFeet = (wallLength / 30) / 2;  // Middle of wall
                        
                        room.doors.push({
                            wallIndex: nearestWall,
                            width: 3,  // 3 feet default
                            position: positionFeet,
                            type: 'swinging'
                        });
                        
                        updateEditStatus(`‚úì Door added to wall ${nearestWall + 1}`);
                        redraw2D();
                        if (state.currentView === '3d') render3D();
                    }
                    return;
                } else if (editMode.tool === 'addWindow') {
                    // Find nearest wall and add window
                    let nearestWall = -1;
                    let minDist = Infinity;
                    
                    for (let i = 0; i < room.walls.length; i++) {
                        const start = room.floorPoints[i];
                        const end = room.floorPoints[(i + 1) % room.floorPoints.length];
                        const dist = pointToLineDistance(x, y, start.x, start.y, end.x, end.y);
                        
                        if (dist < minDist) {
                            minDist = dist;
                            nearestWall = i;
                        }
                    }
                    
                    if (nearestWall >= 0 && minDist < 50) {
                        const start = room.floorPoints[nearestWall];
                        const end = room.floorPoints[(nearestWall + 1) % room.floorPoints.length];
                        const dx = end.x - start.x;
                        const dy = end.y - start.y;
                        const wallLength = Math.sqrt(dx * dx + dy * dy);
                        const positionFeet = (wallLength / 30) / 2;  // Middle of wall
                        
                        room.windows.push({
                            wallIndex: nearestWall,
                            width: 4,  // 4 feet default
                            height: 4,  // 4 feet default
                            position: positionFeet,
                            sillHeight: 3  // 3 feet default
                        });
                        
                        updateEditStatus(`‚úì Window added to wall ${nearestWall + 1}`);
                        redraw2D();
                        if (state.currentView === '3d') render3D();
                    }
                    return;
                }
            }
            // ===== END EDIT MODE HANDLING =====
            
            // Check for feature dragging (doors, windows, missing walls) - only if not shift or middle button
            if (e.button === 0 && !e.shiftKey && !state.wallSelectionMode && !state.currentFeature) {
                const room = getCurrentRoom();
                if (room) {
                    // Check doors
                    for (let i = room.doors.length - 1; i >= 0; i--) {
                        const door = room.doors[i];
                        const dist = Math.sqrt(Math.pow(x - door.x, 2) + Math.pow(y - door.y, 2));
                        if (dist < 50) {
                            saveStateForUndo();
                            state.draggingFeature = door;
                            state.draggingFeatureType = 'door';
                            state.draggingFeatureIndex = i;
                            canvas2D.style.cursor = 'grabbing';
                            e.preventDefault();
                            return;
                        }
                    }
                    
                    // Check windows
                    for (let i = room.windows.length - 1; i >= 0; i--) {
                        const win = room.windows[i];
                        const dist = Math.sqrt(Math.pow(x - win.x, 2) + Math.pow(y - win.y, 2));
                        if (dist < 50) {
                            saveStateForUndo();
                            state.draggingFeature = win;
                            state.draggingFeatureType = 'window';
                            state.draggingFeatureIndex = i;
                            canvas2D.style.cursor = 'grabbing';
                            e.preventDefault();
                            return;
                        }
                    }
                    
                    // Check wall cuts (openings created with Opening button)
                    const hitCut = findClickedCut(room, x, y);
                    if (hitCut) {
                        const wall = room.walls[hitCut.wallIdx];
                        if (wall && wall.cuts && wall.cuts[hitCut.cutIdx]) {
                            saveStateForUndo();
                            state.draggingFeature = wall.cuts[hitCut.cutIdx];
                            state.draggingFeatureType = 'cut';
                            state.draggingFeatureIndex = hitCut.cutIdx;
                            state.draggingFeatureWallIndex = hitCut.wallIdx;
                            canvas2D.style.cursor = 'grabbing';
                            e.preventDefault();
                            console.log('üîì Started dragging opening/cut');
                            return;
                        }
                    }
                    
                    // Check missing walls
                    const hitMissing = findMissingAtPoint(room, x, y);
                    if (hitMissing) {
                        const wall = room.walls[hitMissing.wallIdx];
                        if (wall && wall.missingWalls && wall.missingWalls[hitMissing.missIdx]) {
                            saveStateForUndo();
                            state.draggingFeature = wall.missingWalls[hitMissing.missIdx];
                            state.draggingFeatureType = 'missing';
                            state.draggingFeatureIndex = hitMissing.missIdx;
                            state.draggingFeatureWallIndex = hitMissing.wallIdx;
                            canvas2D.style.cursor = 'grabbing';
                            e.preventDefault();
                            return;
                        }
                    }
                }
            }
            
            // Room dragging in show all rooms mode
            if (state.showAllRooms && e.button === 0 && !e.shiftKey) {
                // Check if clicking on any room
                for (let i = state.rooms.length - 1; i >= 0; i--) {
                    const room = state.rooms[i];
                    if (room.floorPoints.length < 3) continue;
                    
                    const offsetX = (room.positionX || 0) * 30;
                    const offsetZ = (room.positionZ || 0) * 30;
                    
                    // Check if point is inside room polygon
                    let inside = false;
                    for (let j = 0, k = room.floorPoints.length - 1; j < room.floorPoints.length; k = j++) {
                        const xi = room.floorPoints[j].x + offsetX;
                        const yi = room.floorPoints[j].y + offsetZ;
                        const xk = room.floorPoints[k].x + offsetX;
                        const yk = room.floorPoints[k].y + offsetZ;
                        
                        if ((yi > y) !== (yk > y) && x < (xk - xi) * (y - yi) / (yk - yi) + xi) {
                            inside = !inside;
                        }
                    }
                    
                    if (inside) {
                        state.draggingRoom = i;
                        state.dragStartX = x;
                        state.dragStartY = y;
                        state.dragStartRoomX = room.positionX || 0;
                        state.dragStartRoomZ = room.positionZ || 0;
                        state.currentRoomIndex = i;
                        canvas2D.style.cursor = 'move';
                        updateRoomList();
                        redraw2D();
                        return;
                    }
                }
            }
            
            // Middle mouse button or Shift+Left button = pan
            if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                e.preventDefault();
                isPanning = true;
                panStartX = e.clientX;
                panStartY = e.clientY;
                panStartPanX = state.panX;
                panStartPanY = state.panY;
                canvas2D.style.cursor = 'grabbing';
            }
        });

        canvas2D.addEventListener('mousemove', (e) => {
            if (state.currentView !== '2d') return; // Only handle in 2D mode
            
            const rect = canvas2D.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            const x = (clickX - state.panX) / state.zoom;
            const y = (clickY - state.panY) / state.zoom;
            
            // Store mouse position for wall drawing preview
            state.mouseX = clickX;
            state.mouseY = clickY;
            state.mouseWorldX = x;
            state.mouseWorldY = y;
            
            // ===== CREATING ADJACENT ROOM (XACTIMATE CTRL+DRAG) =====
            if (state.creatingAdjacentRoom) {
                const dx = x - state.creatingAdjacentRoom.startX;
                const dy = y - state.creatingAdjacentRoom.startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Only start creating if dragged at least 30 pixels
                if (distance > 30) {
                    const sourceRoom = state.creatingAdjacentRoom.sourceRoom;
                    const edgeIndex = state.creatingAdjacentRoom.edgeIndex;
                    const p1Index = edgeIndex;
                    const p2Index = (edgeIndex + 1) % sourceRoom.floorPoints.length;
                    
                    // Get the edge being dragged from
                    const edgeP1 = sourceRoom.floorPoints[p1Index];
                    const edgeP2 = sourceRoom.floorPoints[p2Index];
                    
                    // Calculate perpendicular direction
                    const edgeDx = edgeP2.x - edgeP1.x;
                    const edgeDy = edgeP2.y - edgeP1.y;
                    const edgeLength = Math.sqrt(edgeDx * edgeDx + edgeDy * edgeDy);
                    const perpDirX = -edgeDy / edgeLength;
                    const perpDirY = edgeDx / edgeLength;
                    
                    // Project mouse movement onto perpendicular direction
                    const perpDist = dx * perpDirX + dy * perpDirY;
                    
                    // Create preview room rectangle
                    state.adjacentRoomPreview = {
                        p1: {x: edgeP1.x, y: edgeP1.y},
                        p2: {x: edgeP2.x, y: edgeP2.y},
                        p3: {x: edgeP2.x + perpDirX * perpDist, y: edgeP2.y + perpDirY * perpDist},
                        p4: {x: edgeP1.x + perpDirX * perpDist, y: edgeP1.y + perpDirY * perpDist},
                        depth: Math.abs(perpDist) / 30  // in feet
                    };
                }
                
                redraw2D();
                return;
            }
            
            // ===== ROOM EDIT MODE HANDLE DRAGGING =====
            if (state.roomEditMode && state.draggingHandle) {
                const room = getCurrentRoom();
                if (room && room.floorPoints) {
                    if (state.draggingHandle.type === 'corner') {
                        // CORNER HANDLES DISABLED - prevent accidental room distortion
                        // Only edge handles can be dragged
                        return;
                    } else if (state.draggingHandle.type === 'edge') {
                        // XACTIMATE-STYLE: Show preview of new wall position
                        // Original wall stays in place, preview shows where it would go
                        const edgeIndex = state.draggingHandle.index;
                        const p1Index = edgeIndex;
                        const p2Index = (edgeIndex + 1) % room.floorPoints.length;
                        
                        // Calculate offset from drag start
                        let dx = x - state.draggingHandle.startX;
                        let dy = y - state.draggingHandle.startY;
                        
                        // ORTHO MODE: Determine if edge is horizontal or vertical
                        // Then only allow movement perpendicular to the edge
                        const edgeX = state.draggingHandle.p2StartX - state.draggingHandle.p1StartX;
                        const edgeY = state.draggingHandle.p2StartY - state.draggingHandle.p1StartY;
                        const edgeLength = Math.sqrt(edgeX * edgeX + edgeY * edgeY);
                        
                        if (edgeLength > 0) {
                            // Normalized edge direction
                            const edgeDirX = edgeX / edgeLength;
                            const edgeDirY = edgeY / edgeLength;
                            
                            // Perpendicular direction (90 degrees rotated)
                            const perpDirX = -edgeDirY;
                            const perpDirY = edgeDirX;
                            
                            // Project movement onto perpendicular direction only
                            const perpDist = dx * perpDirX + dy * perpDirY;
                            dx = perpDist * perpDirX;
                            dy = perpDist * perpDirY;
                        }
                        
                        // Store PREVIEW position (don't modify original points yet!)
                        state.wallDragPreview = {
                            edgeIndex: edgeIndex,
                            p1: {
                                x: state.draggingHandle.p1StartX + dx,
                                y: state.draggingHandle.p1StartY + dy
                            },
                            p2: {
                                x: state.draggingHandle.p2StartX + dx,
                                y: state.draggingHandle.p2StartY + dy
                            },
                            distance: Math.sqrt(dx * dx + dy * dy) / 30,  // Distance in feet
                            snapped: false,  // Will be set to true if snapped to wall
                            ctrlPressed: e.ctrlKey || e.metaKey  // Track CTRL key for "create new room" mode
                        };
                        
                        // SNAP TO WALL: Check if preview wall is near another room's wall
                        const snapTolerance = 30; // 30 pixels = 1 foot
                        const roomsOnLevel = state.rooms.filter(r => r.level === state.currentLevel);
                        
                        for (const otherRoom of roomsOnLevel) {
                            if (otherRoom === room) continue;
                            if (!otherRoom.floorPoints || otherRoom.floorPoints.length < 3) continue;
                            
                            // Check each edge of other room
                            for (let i = 0; i < otherRoom.floorPoints.length; i++) {
                                const op1 = otherRoom.floorPoints[i];
                                const op2 = otherRoom.floorPoints[(i + 1) % otherRoom.floorPoints.length];
                                
                                // Calculate distance from preview wall endpoints to other wall endpoints
                                const p1ToOp1 = Math.sqrt(Math.pow(state.wallDragPreview.p1.x - op1.x, 2) + 
                                                         Math.pow(state.wallDragPreview.p1.y - op1.y, 2));
                                const p2ToOp2 = Math.sqrt(Math.pow(state.wallDragPreview.p2.x - op2.x, 2) + 
                                                         Math.pow(state.wallDragPreview.p2.y - op2.y, 2));
                                const p1ToOp2 = Math.sqrt(Math.pow(state.wallDragPreview.p1.x - op2.x, 2) + 
                                                         Math.pow(state.wallDragPreview.p1.y - op2.y, 2));
                                const p2ToOp1 = Math.sqrt(Math.pow(state.wallDragPreview.p2.x - op1.x, 2) + 
                                                         Math.pow(state.wallDragPreview.p2.y - op1.y, 2));
                                
                                // Check if preview wall is close to this wall (either direction)
                                if ((p1ToOp1 < snapTolerance && p2ToOp2 < snapTolerance) ||
                                    (p1ToOp2 < snapTolerance && p2ToOp1 < snapTolerance)) {
                                    // SNAP! Align preview wall to match other room's wall exactly
                                    if (p1ToOp1 < p1ToOp2) {
                                        // Forward alignment
                                        state.wallDragPreview.p1.x = op1.x;
                                        state.wallDragPreview.p1.y = op1.y;
                                        state.wallDragPreview.p2.x = op2.x;
                                        state.wallDragPreview.p2.y = op2.y;
                                    } else {
                                        // Reverse alignment
                                        state.wallDragPreview.p1.x = op2.x;
                                        state.wallDragPreview.p1.y = op2.y;
                                        state.wallDragPreview.p2.x = op1.x;
                                        state.wallDragPreview.p2.y = op1.y;
                                    }
                                    state.wallDragPreview.snapped = true;
                                    // Update distance after snap
                                    const newDx = state.wallDragPreview.p1.x - state.draggingHandle.p1StartX;
                                    const newDy = state.wallDragPreview.p1.y - state.draggingHandle.p1StartY;
                                    state.wallDragPreview.distance = Math.sqrt(newDx * newDx + newDy * newDy) / 30;
                                    break;
                                }
                            }
                        }
                        
                        redraw2D();
                        updateStats();
                    }
                }
                return;
            }
            
            // ===== ROOM EDIT MODE HANDLE HOVER DETECTION =====
            if (state.roomEditMode && !state.showAllRooms) {
                const room = getCurrentRoom();
                if (room && room.floorPoints) {
                    const HOVER_SIZE = 15 / state.zoom;
                    let foundHandle = null;
                    
                    // CORNER HANDLES DISABLED - only check edge handles
                    // (Skip corner detection to prevent accidental selection)
                    
                    // Check edge handles
                    for (let i = 0; i < room.floorPoints.length; i++) {
                        const p1 = room.floorPoints[i];
                        const p2 = room.floorPoints[(i + 1) % room.floorPoints.length];
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        const dist = Math.sqrt(Math.pow(x - midX, 2) + Math.pow(y - midY, 2));
                        if (dist < HOVER_SIZE) {
                            foundHandle = { type: 'edge', index: i };
                            break;
                        }
                    }
                    
                    // Update hover state
                    const hoverChanged = JSON.stringify(state.hoveredHandle) !== JSON.stringify(foundHandle);
                    state.hoveredHandle = foundHandle;
                    
                    // Update cursor
                    const canvas = document.getElementById('canvas2D');
                    canvas.style.cursor = foundHandle ? 'move' : 'default';
                    
                    // Redraw if hover changed
                    if (hoverChanged) {
                        redraw2D();
                    }
                }
                return; // Don't process other hover events in edit mode
            }
            
            // ===== ROOM NAME HOVER DETECTION =====
            // Check even in edit mode so other room names show pointer cursor
            if (!state.wallSelectionMode && !state.draggingHandle) {
                let hoveringRoomName = false;
                
                // Check if hovering over any room name
                for (let i = 0; i < state.rooms.length; i++) {
                    const room = state.rooms[i];
                    if (room.nameBounds && room.floorPoints && room.floorPoints.length > 0) {
                        const centerX = room.nameBounds.x;
                        const centerY = room.nameBounds.y;
                        const halfWidth = room.nameBounds.width / 2;
                        const halfHeight = room.nameBounds.height / 2;
                        
                        if (x >= centerX - halfWidth && x <= centerX + halfWidth &&
                            y >= centerY - halfHeight && y <= centerY + halfHeight) {
                            hoveringRoomName = true;
                            break;
                        }
                    }
                }
                
                // Update cursor (but don't override handle hover cursor)
                if (!state.hoveredHandle) {
                    const canvas = document.getElementById('canvas2D');
                    canvas.style.cursor = hoveringRoomName ? 'pointer' : 'default';
                }
            }
            
            // ===== ZOOM WINDOW DRAGGING =====
            if (state.zoomWindowMode && state.zoomWindowStart) {
                state.zoomWindowEnd = { x: clickX, y: clickY };
                redraw2D();
                return;
            }
            
            // If in wall drawing mode with corners placed, redraw to show preview line
            // Throttle to prevent excessive redraws
            if (state.wallSelectionMode && !state.currentFeature && state.wallDrawingCorners && state.wallDrawingCorners.length > 0) {
                if (!state.lastRedrawTime || Date.now() - state.lastRedrawTime > 16) { // ~60fps max
                    state.lastRedrawTime = Date.now();
                    redraw2D();
                }
                return; // Stop processing after redraw
            }
            
            if (isPanning) {
                const dx = e.clientX - panStartX;
                const dy = e.clientY - panStartY;
                state.panX = panStartPanX + dx;
                state.panY = panStartPanY + dy;
                redraw2D();
                return; // Don't do hover detection while panning
            }
            
            // Feature dragging (doors, windows, missing walls)
            if (state.draggingFeature) {
                const room = getCurrentRoom();
                if (!room) return;
                
                if (state.draggingFeatureType === 'door' || state.draggingFeatureType === 'window') {
                    const feature = state.draggingFeatureType === 'door' ? room.doors[state.draggingFeatureIndex] : room.windows[state.draggingFeatureIndex];
                    if (!feature) return;
                    
                    const wall = room.walls[feature.wallIndex];
                    if (!wall) return;
                    
                    // Find closest point on the wall to the mouse
                    const wallDx = wall.end.x - wall.start.x;
                    const wallDy = wall.end.y - wall.start.y;
                    const wallLength = Math.sqrt(wallDx * wallDx + wallDy * wallDy);
                    
                    // Project mouse position onto wall
                    const mouseToWallStartX = x - wall.start.x;
                    const mouseToWallStartY = y - wall.start.y;
                    const projection = (mouseToWallStartX * wallDx + mouseToWallStartY * wallDy) / (wallLength * wallLength);
                    const clampedProjection = Math.max(0, Math.min(1, projection));
                    
                    // Calculate new position on wall
                    feature.x = wall.start.x + clampedProjection * wallDx;
                    feature.y = wall.start.y + clampedProjection * wallDy;
                    
                    // Update distanceFromLeft
                    const wallLengthFt = parseFloat(wall.length);
                    const featureWidthFt = feature.width / 12;
                    const distanceFromStartFt = clampedProjection * wallLengthFt;
                    const edgePosition = distanceFromStartFt - (featureWidthFt / 2);
                    feature.distanceFromLeft = Math.max(0, Math.min(wallLengthFt - featureWidthFt, edgePosition));
                    
                    redraw2D();
                    return;
                    
                } else if (state.draggingFeatureType === 'cut') {
                    // Dragging a wall cut (opening) - MOUSE
                    const wall = room.walls[state.draggingFeatureWallIndex];
                    const cut = wall.cuts[state.draggingFeatureIndex];
                    if (!wall || !cut) return;
                    
                    // Find closest point on the wall to the mouse
                    const wallDx = wall.end.x - wall.start.x;
                    const wallDy = wall.end.y - wall.start.y;
                    const wallLength = Math.sqrt(wallDx * wallDx + wallDy * wallDy);
                    
                    // Project mouse position onto wall
                    const mouseToWallStartX = x - wall.start.x;
                    const mouseToWallStartY = y - wall.start.y;
                    const projection = (mouseToWallStartX * wallDx + mouseToWallStartY * wallDy) / (wallLength * wallLength);
                    const clampedProjection = Math.max(0, Math.min(1, projection));
                    
                    // Calculate segment center position
                    const segmentCenter = clampedProjection * wallLength / 30; // Convert to feet
                    const segmentWidthFt = (cut.endDist - cut.startDist);
                    
                    // Update both start and end to move the whole segment
                    const newStart = Math.max(0, segmentCenter - segmentWidthFt / 2);
                    const newEnd = Math.min(wallLength / 30, segmentCenter + segmentWidthFt / 2);
                    
                    cut.startDist = newStart;
                    cut.endDist = newEnd;
                    
                    redraw2D();
                    return;
                    
                } else if (state.draggingFeatureType === 'missing') {
                    const wall = room.walls[state.draggingFeatureWallIndex];
                    const missing = wall.missingWalls[state.draggingFeatureIndex];
                    if (!wall || !missing) return;
                    
                    // Find closest point on the wall to the mouse
                    const wallDx = wall.end.x - wall.start.x;
                    const wallDy = wall.end.y - wall.start.y;
                    const wallLength = Math.sqrt(wallDx * wallDx + wallDy * wallDy);
                    
                    // Project mouse position onto wall
                    const mouseToWallStartX = x - wall.start.x;
                    const mouseToWallStartY = y - wall.start.y;
                    const projection = (mouseToWallStartX * wallDx + mouseToWallStartY * wallDy) / (wallLength * wallLength);
                    const clampedProjection = Math.max(0, Math.min(1, projection));
                    
                    // Calculate the missing wall segment width
                    const missingWidth = missing.endDist - missing.startDist;
                    const wallLengthFt = parseFloat(wall.length);
                    const centerDistFt = clampedProjection * wallLengthFt;
                    const newStartDist = Math.max(0, centerDistFt - missingWidth / 2);
                    const newEndDist = Math.min(wallLengthFt, newStartDist + missingWidth);
                    
                    missing.startDist = newStartDist;
                    missing.endDist = newEndDist;
                    
                    redraw2D();
                    return;
                }
            }
            
            // Room dragging
            if (state.draggingRoom !== null) {
                const room = state.rooms[state.draggingRoom];
                const dx = (x - state.dragStartX) / 30; // Convert pixels to position units
                const dy = (y - state.dragStartY) / 30;
                
                let newX = state.dragStartRoomX + dx;
                let newZ = state.dragStartRoomZ + dy;
                
                // Calculate room bounds for snapping
                if (room.floorPoints.length >= 3) {
                    let minX = Infinity, maxX = -Infinity;
                    let minZ = Infinity, maxZ = -Infinity;
                    
                    room.floorPoints.forEach(p => {
                        minX = Math.min(minX, p.x / 30);
                        maxX = Math.max(maxX, p.x / 30);
                        minZ = Math.min(minZ, p.y / 30);
                        maxZ = Math.max(maxZ, p.y / 30);
                    });
                    
                    const roomWidth = maxX - minX;
                    const roomDepth = maxZ - minZ;
                    
                    // Calculate this room's corners in world space
                    // Account for the room's origin offset from its bounding box
                    const myCorners = [
                        { x: newX + minX, z: newZ + minZ, name: 'TL' },                                    // Top-left
                        { x: newX + maxX, z: newZ + minZ, name: 'TR' },                                    // Top-right
                        { x: newX + maxX, z: newZ + maxZ, name: 'BR' },                                    // Bottom-right
                        { x: newX + minX, z: newZ + maxZ, name: 'BL' }                                     // Bottom-left
                    ];
                    
                    // Check for snapping to other rooms
                    const snapTolerance = 1.0; // Snap if within 1 foot
                    let snapped = false;
                    let snapType = '';
                    
                    state.rooms.forEach((otherRoom, idx) => {
                        if (idx === state.draggingRoom || otherRoom.floorPoints.length < 3) return;
                        
                        let otherMinX = Infinity, otherMaxX = -Infinity;
                        let otherMinZ = Infinity, otherMaxZ = -Infinity;
                        
                        otherRoom.floorPoints.forEach(p => {
                            otherMinX = Math.min(otherMinX, p.x / 30);
                            otherMaxX = Math.max(otherMaxX, p.x / 30);
                            otherMinZ = Math.min(otherMinZ, p.y / 30);
                            otherMaxZ = Math.max(otherMaxZ, p.y / 30);
                        });
                        
                        const otherX = (otherRoom.positionX || 0);
                        const otherZ = (otherRoom.positionZ || 0);
                        const otherWidth = otherMaxX - otherMinX;
                        const otherDepth = otherMaxZ - otherMinZ;
                        
                        // Other room's corners in world space
                        const otherCorners = [
                            { x: otherX + otherMinX, z: otherZ + otherMinZ, name: 'TL' },
                            { x: otherX + otherMaxX, z: otherZ + otherMinZ, name: 'TR' },
                            { x: otherX + otherMaxX, z: otherZ + otherMaxZ, name: 'BR' },
                            { x: otherX + otherMinX, z: otherZ + otherMaxZ, name: 'BL' }
                        ];
                        
                        // CORNER TO CORNER SNAPPING (highest priority)
                        if (!snapped) {
                            for (let i = 0; i < myCorners.length && !snapped; i++) {
                                for (let j = 0; j < otherCorners.length && !snapped; j++) {
                                    const dist = Math.sqrt(
                                        Math.pow(myCorners[i].x - otherCorners[j].x, 2) + 
                                        Math.pow(myCorners[i].z - otherCorners[j].z, 2)
                                    );
                                    
                                    if (dist < snapTolerance * 1.5) {
                                        // Snap this corner to that corner
                                        const offsetX = otherCorners[j].x - myCorners[i].x;
                                        const offsetZ = otherCorners[j].z - myCorners[i].z;
                                        newX += offsetX;
                                        newZ += offsetZ;
                                        snapped = true;
                                        snapType = '‚ö° CORNER';
                                        
                                        // Update corner positions after snap
                                        myCorners[0] = { x: newX + minX, z: newZ + minZ };
                                        myCorners[1] = { x: newX + maxX, z: newZ + minZ };
                                        myCorners[2] = { x: newX + maxX, z: newZ + maxZ };
                                        myCorners[3] = { x: newX + minX, z: newZ + maxZ };
                                        
                                        break; // Found a snap, stop checking
                                    }
                                }
                            }
                        }
                        
                        // EDGE TO EDGE SNAPPING (if no corner snap)
                        if (!snapped) {
                            // My room's edges
                            const myLeft = newX + minX;
                            const myRight = newX + maxX;
                            const myTop = newZ + minZ;
                            const myBottom = newZ + maxZ;
                            
                            // Other room's edges
                            const otherLeft = otherX + otherMinX;
                            const otherRight = otherX + otherMaxX;
                            const otherTop = otherZ + otherMinZ;
                            const otherBottom = otherZ + otherMaxZ;
                            
                            // Snap right edge to left edge of other room
                            if (Math.abs(myRight - otherLeft) < snapTolerance) {
                                newX = otherLeft - maxX;
                                snapped = true;
                                snapType = '‚ö° EDGE';
                            }
                            // Snap left edge to right edge of other room
                            if (Math.abs(myLeft - otherRight) < snapTolerance) {
                                newX = otherRight - minX;
                                snapped = true;
                                snapType = '‚ö° EDGE';
                            }
                            // Snap bottom edge to top edge of other room
                            if (Math.abs(myBottom - otherTop) < snapTolerance) {
                                newZ = otherTop - maxZ;
                                snapped = true;
                                snapType = '‚ö° EDGE';
                            }
                            // Snap top edge to bottom edge of other room
                            if (Math.abs(myTop - otherBottom) < snapTolerance) {
                                newZ = otherBottom - minZ;
                                snapped = true;
                                snapType = '‚ö° EDGE';
                            }
                        }
                    });
                    
                    state.snapType = snapType;
                    
                    if (snapped) {
                        canvas2D.style.cursor = 'crosshair';
                        state.lastSnapped = true;
                    } else {
                        canvas2D.style.cursor = 'move';
                        state.lastSnapped = false;
                    }
                }
                
                room.positionX = newX;
                room.positionZ = newZ;
                
                // Update position inputs
                document.getElementById('roomPosX').value = Math.round(room.positionX);
                document.getElementById('roomPosZ').value = Math.round(room.positionZ);
                
                redraw2D();
                if (state.currentView === '3d') {
                    render3D();
                }
                return;
            }
            
            // Existing hover detection code continues below...
            const room = getCurrentRoom();
            if (!room) return;
            
            // Always reset hover states first
            const prevHoverDoor = hoverDoorIndex;
            const prevHoverWindow = hoverWindowIndex;
            hoverDoorIndex = null;
            hoverWindowIndex = null;
            hoverClickPoint = null;
            
            // Check if hovering over door or window when not in wall selection mode and no feature selected
            if (!state.wallSelectionMode && !state.currentFeature) {
                // Check doors - always check regardless of other conditions
                for (let i = 0; i < room.doors.length; i++) {
                    const door = room.doors[i];
                    const dist = Math.sqrt(Math.pow(x - door.x, 2) + Math.pow(y - door.y, 2));
                    if (dist < 50) { // Increased to 50 pixels for easier detection
                        hoverDoorIndex = i;
                        canvas2D.style.cursor = 'grab';
                        if (prevHoverDoor !== i) redraw2D();
                        return;
                    }
                }
                
                // Check windows
                for (let i = 0; i < room.windows.length; i++) {
                    const win = room.windows[i];
                    const dist = Math.sqrt(Math.pow(x - win.x, 2) + Math.pow(y - win.y, 2));
                    if (dist < 50) { // Increased to 50 pixels
                        hoverWindowIndex = i;
                        canvas2D.style.cursor = 'grab';
                        if (prevHoverWindow !== i) redraw2D();
                        return;
                    }
                }
                
                // Check wall cuts/openings
                const hitCut = findClickedCut(room, x, y);
                if (hitCut) {
                    canvas2D.style.cursor = 'grab';
                    console.log('üîì Hovering over opening - ready to drag');
                    return;
                }
                
                // Check missing walls
                const hitMissing = findMissingAtPoint(room, x, y);
                if (hitMissing) {
                    canvas2D.style.cursor = 'grab';
                    return;
                }
                
                canvas2D.style.cursor = 'default';
                if (prevHoverDoor !== null || prevHoverWindow !== null) {
                    redraw2D(); // Clear previous hover highlight
                }
                return;
            }
            
            // Wall selection mode - show placement indicator
            if (state.wallSelectionMode) {
                canvas2D.style.cursor = 'default';
                
                // Find closest wall and point on wall
                // CHECK ALL POLYGON EDGES - including those marked as skip (shared walls)
                let hoveredWall = null;
                let minDist = Infinity;
                let closestPoint = null;
                
                const numPoints = room.floorPoints.length;
                for (let i = 0; i < numPoints; i++) {
                    const p1 = room.floorPoints[i];
                    const p2 = room.floorPoints[(i + 1) % numPoints];
                    
                    const dist = distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                    if (dist < 60 && dist < minDist) {  // Increased tolerance for easier hovering
                        minDist = dist;
                        hoveredWall = i; // Use edge index, not wall index
                        
                        // Calculate closest point on wall
                        const A = x - p1.x;
                        const B = y - p1.y;
                        const C = p2.x - p1.x;
                        const D = p2.y - p1.y;
                        
                        const dot = A * C + B * D;
                        const lenSq = C * C + D * D;
                        let param = -1;
                        if (lenSq !== 0) param = dot / lenSq;
                        param = Math.max(0, Math.min(1, param));
                        
                        closestPoint = {
                            x: p1.x + param * C,
                            y: p1.y + param * D
                        };
                    }
                }
                
                // Update cursor
                canvas2D.style.cursor = hoveredWall !== null ? 'pointer' : 'default';
                
                // Store hover point for drawing
                hoverClickPoint = closestPoint;
                
                if (state.hoveredWall !== hoveredWall) {
                    state.hoveredWall = hoveredWall;
                    redraw2D();
                } else if (hoverClickPoint) {
                    redraw2D(); // Redraw to show the point indicator
                }
            }
        });

        function resizeCanvas() {
            const area = document.getElementById('canvasArea');
            canvas2D.width = area.clientWidth;
            canvas2D.height = area.clientHeight;
            if (renderer) {
                renderer.setSize(area.clientWidth, area.clientHeight);
                camera.aspect = area.clientWidth / area.clientHeight;
                camera.updateProjectionMatrix();
            }
            
            // Only redraw the current view
            if (state.currentView === '2d') {
                redraw2D();
            } else if (state.currentView === '3d' && renderer) {
                renderer.render(scene, camera);
            }
        }

        function init3D() {
            console.log('=== Initializing 3D ===');
            const container = document.getElementById('canvas3D');
            const area = document.getElementById('canvasArea');
            
            console.log('Container:', container);
            console.log('Area dimensions:', area.clientWidth, 'x', area.clientHeight);
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Monitor scene modifications
            const originalRemove = scene.remove.bind(scene);
            scene.remove = function(...args) {
                console.log('Scene.remove called, current children:', scene.children.length, 'removing:', args.length);
                const result = originalRemove(...args);
                console.log('After remove, children:', scene.children.length);
                return result;
            };
            
            camera = new THREE.PerspectiveCamera(60, area.clientWidth / area.clientHeight, 0.1, 1000);
            // Pull camera way back and up for full room view
            camera.position.set(25, 25, 35);
            camera.lookAt(0, 3, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(area.clientWidth, area.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);
            
            // Ensure the canvas has proper styling for events
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.width = '100%';
            renderer.domElement.style.height = '100%';
            renderer.domElement.style.pointerEvents = 'auto';
            
            console.log('Renderer created, canvas size:', renderer.domElement.width, 'x', renderer.domElement.height);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Increased brightness
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0); // Increased brightness
            dirLight.position.set(30, 50, 30);
            dirLight.castShadow = true;
            scene.add(dirLight);
            
            // Ground plane removed - no floor in 3D view
            
            console.log('Scene has', scene.children.length, 'initial children');
            
            setupOrbitControls();
            console.log('=== 3D initialization complete ===');
        }

        function setupOrbitControls() {
            const canvas = renderer.domElement;
            
            // ORBIT CAMERA - rotates around a fixed target point
            let targetX = 0;  // Will be set to room center by render3D
            let targetY = 4;  // Middle height of room (4 feet)
            let targetZ = 0;  // Will be set to room center by render3D
            
            let radius = 15;  // Distance from target
            let theta = Math.PI;    // Horizontal angle (radians) - rotated 180¬∞ to unmirror
            let phi = Math.PI / 3; // Vertical angle (60 degrees from vertical)
            
            const rotateSpeed = 0.008;
            const zoomSpeed = 0.3;
            const panSpeed = 0.1;
            
            // Track keys and mouse
            const keys = {};
            let isMouseDown = false;
            let isRightMouseDown = false;
            let lastMouseX = 0;
            let lastMouseY = 0;
            
            // Update camera position based on spherical coordinates
            function updateCameraPosition() {
                // Convert spherical to cartesian coordinates
                camera.position.x = targetX + radius * Math.sin(phi) * Math.sin(theta);
                camera.position.y = targetY + radius * Math.cos(phi);
                camera.position.z = targetZ + radius * Math.sin(phi) * Math.cos(theta);
                
                // Always look at the target
                camera.lookAt(targetX, targetY, targetZ);
            }
            
            // Function to set orbit target (called by render3D)
            window.setOrbitTarget = function(x, y, z) {
                targetX = x;
                targetY = y;
                targetZ = z;
                console.log(`üéØ Orbit target set to: (${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)})`);
                updateCameraPosition();
            };
            
            // Function to update camera distance (called by render3D for auto-zoom)
            window.updateCameraRadius = function(newRadius) {
                radius = Math.max(5, Math.min(50, newRadius)); // Clamp between 5 and 50
                updateCameraPosition();
            };
            
            // Function to reset camera to default viewing angle
            window.resetCameraView = function() {
                theta = Math.PI;    // Face the room straight on
                phi = Math.PI / 3;  // 60 degrees from vertical
                radius = 15;        // Default distance
                console.log(`üîÑ Camera reset: theta=${theta.toFixed(2)}, phi=${phi.toFixed(2)}, radius=${radius}`);
                updateCameraPosition();
                console.log(`üì∑ Camera now at: (${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)})`);
            };
            
            // Keyboard events
            window.addEventListener('keydown', (e) => {
                // Ctrl+Z for undo
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    e.stopPropagation();
                    undo();
                    return;
                }
                
                if (state.currentView === '3d') {
                    keys[e.key.toLowerCase()] = true;
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
            
            window.addEventListener('keyup', (e) => {
                if (state.currentView === '3d') {
                    keys[e.key.toLowerCase()] = false;
                }
            });
            
            // Mouse drag to orbit (left) or pan (right)
            canvas.addEventListener('mousedown', (e) => {
                if (state.currentView === '3d') {
                    if (e.button === 0) { // Left button - orbit
                        isMouseDown = true;
                    } else if (e.button === 2) { // Right button - pan
                        isRightMouseDown = true;
                    }
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (state.currentView === '3d') {
                    if (e.button === 0) {
                        isMouseDown = false;
                    } else if (e.button === 2) {
                        isRightMouseDown = false;
                    }
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (state.currentView === '3d') {
                    isMouseDown = false;
                    isRightMouseDown = false;
                }
            });
            
            canvas.addEventListener('click', (e) => {
                if (state.currentView === '3d') {
                    e.stopPropagation();
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (state.currentView === '3d' && (isMouseDown || isRightMouseDown)) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;
                    
                    if (isRightMouseDown) {
                        // Right-click: Pan the target
                        // Calculate right vector (perpendicular to view direction)
                        const right = new THREE.Vector3();
                        right.set(Math.cos(theta), 0, -Math.sin(theta));
                        
                        const panAmount = 0.05;
                        targetX -= right.x * deltaX * panAmount;
                        targetZ -= right.z * deltaX * panAmount;
                        targetY += deltaY * panAmount;
                        
                        updateCameraPosition();
                    } else if (isMouseDown) {
                        // Left-click: Rotate around target
                        theta -= deltaX * rotateSpeed;
                        phi -= deltaY * rotateSpeed;
                        
                        // Clamp phi to prevent flipping
                        phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
                        
                        updateCameraPosition();
                    }
                    
                    renderer.render(scene, camera);
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    
                    e.stopPropagation();
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            // Mouse wheel to zoom (change radius)
            canvas.addEventListener('wheel', (e) => {
                if (state.currentView === '3d') {
                    e.preventDefault();
                    
                    radius += e.deltaY * zoomSpeed;
                    radius = Math.max(3, Math.min(100, radius)); // Clamp between 3 and 100
                    
                    updateCameraPosition();
                    renderer.render(scene, camera);
                }
            });
            
            // Animation loop for keyboard panning
            function animate() {
                requestAnimationFrame(animate);
                
                if (state.currentView !== '3d') return;
                
                let moved = false;
                
                // WASD/Arrow keys pan the target (what we're looking at)
                if (keys['w'] || keys['arrowup']) {
                    targetZ -= panSpeed;
                    moved = true;
                }
                if (keys['s'] || keys['arrowdown']) {
                    targetZ += panSpeed;
                    moved = true;
                }
                if (keys['a'] || keys['arrowleft']) {
                    targetX -= panSpeed;
                    moved = true;
                }
                if (keys['d'] || keys['arrowright']) {
                    targetX += panSpeed;
                    moved = true;
                }
                if (keys['q']) {
                    targetY += panSpeed;
                    moved = true;
                }
                if (keys['e']) {
                    targetY -= panSpeed;
                    moved = true;
                }
                
                if (moved) {
                    updateCameraPosition();
                    renderer.render(scene, camera);
                }
            }
            animate();
            
            // Touch support
            let touchStart = null;
            let touchStartDistance = null;
            
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                }
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                if (state.currentView === '3d') {
                    e.preventDefault();
                    
                    if (e.touches.length === 1 && touchStart) {
                        const dx = e.touches[0].clientX - touchStart.x;
                        const dy = e.touches[0].clientY - touchStart.y;
                        
                        theta -= dx * rotateSpeed;
                        phi -= dy * rotateSpeed;
                        phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
                        
                        updateCameraPosition();
                        renderer.render(scene, camera);
                        
                        touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    } else if (e.touches.length === 2 && touchStartDistance) {
                        const dx = e.touches[0].clientX - e.touches[1].clientX;
                        const dy = e.touches[0].clientY - e.touches[1].clientY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const delta = touchStartDistance - distance;
                        
                        radius += delta * 0.05;
                        radius = Math.max(3, Math.min(100, radius));
                        
                        updateCameraPosition();
                        renderer.render(scene, camera);
                        
                        touchStartDistance = distance;
                    }
                }
            }, { passive: false });
            
            canvas.addEventListener('touchend', () => {
                touchStart = null;
                touchStartDistance = null;
            }, { passive: false });
            
            window.updateCameraTarget = function() {};
        }


        function addNewRoom(name) {
            // If called without a name (from button click), show modal
            if (!name) {
                showAddRoomModal();
                return;
            }
            
            // AUTO-CREATE 12'x12' ROOM
            const roomSize = 12; // 12 feet
            const pixelSize = roomSize * 30; // Convert to pixels (30px per foot)
            
            // Position new rooms ADJACENT to existing rooms on same level (not 400px apart!)
            const roomsOnCurrentLevel = state.rooms.filter(r => r.level === state.currentLevel);
            let offsetX = 100; // Default starting position
            let offsetY = 100;
            
            if (roomsOnCurrentLevel.length > 0) {
                // Find rightmost room on current level
                let maxRight = 0;
                roomsOnCurrentLevel.forEach(r => {
                    if (r.floorPoints && r.floorPoints.length > 0) {
                        r.floorPoints.forEach(p => {
                            maxRight = Math.max(maxRight, p.x);
                        });
                    }
                });
                // Place new room just to the right of rightmost room (10px gap)
                offsetX = maxRight + 10;
            }
            
            // Create perfect 12x12 square room
            const newRoom = {
                name,
                level: state.currentLevel,  // NEW: Assign to current level
                floorPoints: [
                    { x: offsetX, y: offsetY },                          // Top-left
                    { x: offsetX + pixelSize, y: offsetY },              // Top-right
                    { x: offsetX + pixelSize, y: offsetY + pixelSize },  // Bottom-right
                    { x: offsetX, y: offsetY + pixelSize }               // Bottom-left
                ],
                walls: [],
                ceilingHeight: 8.0,
                wallThickness: 4,
                doors: [],
                windows: [],
                damageMarkers: [],
                openings: [],  // Track wall cuts/openings
                positionX: 0,
                positionZ: 0
            };
            
            // Create walls from floor points
            for (let i = 0; i < newRoom.floorPoints.length; i++) {
                const start = newRoom.floorPoints[i];
                const end = newRoom.floorPoints[(i + 1) % newRoom.floorPoints.length];
                
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const lengthPixels = Math.sqrt(dx * dx + dy * dy);
                const lengthFeet = lengthPixels / 30;
                
                newRoom.walls.push({
                    name: `Wall ${i + 1}`,
                    length: lengthFeet.toFixed(2),
                    start: { x: start.x, y: start.y },
                    end: { x: end.x, y: end.y }
                });
            }
            
            state.rooms.push(newRoom);
            state.currentRoomIndex = state.rooms.length - 1; // Switch to new room
            state.roomEditMode = true; // Enable edit mode so handles are visible
            
            // If this is the first room, reset zoom and pan to ensure it's visible
            if (state.rooms.length === 1) {
                state.zoom = 1;
                state.panX = 0;
                state.panY = 0;
                const zoomDisplay = document.getElementById('zoomLevel');
                if (zoomDisplay) {
                    zoomDisplay.textContent = '100%';
                }
                console.log('‚úÖ First room created - reset zoom and pan to center view');
            }
            
            console.log(`‚úÖ Room "${name}" created at position (${offsetX}, ${offsetY})`);
            console.log(`   Room has ${newRoom.floorPoints.length} points and ${newRoom.walls.length} walls`);
            console.log(`   Total rooms now: ${state.rooms.length}`);
            console.log(`   Room edit mode: ${state.roomEditMode}`);
            
            updateRoomList();
            updateLevelButtons(); // Update level button counts
            redraw2D();
            updateStats();
            
            showToast(`‚úì ${name} created (12' x 12') - Click name to activate handles, CTRL+drag to create new room`, 4000);
        }

        function switchRoom(index) {
            state.currentRoomIndex = index;
            updateRoomList();
            
            // Update position inputs if they exist (they might not be in the UI)
            const room = getCurrentRoom();
            if (room) {
                const roomPosX = document.getElementById('roomPosX');
                const roomPosZ = document.getElementById('roomPosZ');
                if (roomPosX) roomPosX.value = room.positionX || 0;
                if (roomPosZ) roomPosZ.value = room.positionZ || 0;
            }
            
            // ENABLE ROOM EDIT MODE - Show handles for resizing
            state.roomEditMode = true;
            
            // ONLY clear feature modes if we're NOT actively placing a feature
            if (!state.currentFeature) {
                state.wallSelectionMode = false;
            }
            
            // Clear any active toolbar buttons
            document.querySelectorAll('.toolbar-btn').forEach(btn => {
                btn.classList.remove('toolbar-btn-active');
            });
            
            // Update cursor
            const canvas = document.getElementById('canvas2D');
            canvas.style.cursor = 'default';
            
            showToast(`üéØ ${room.name} selected - Drag handle to resize, CTRL+Drag to create new room`, 4000);
            console.log('‚úÖ Room edit mode enabled - handles will appear');
            
            redraw2D();
            updateStats();
        }

        function switchLevel(levelName) {
            console.log(`üîÑ Switching to level: ${levelName}`);
            state.currentLevel = levelName;
            
            // Exit room edit mode when switching levels
            state.roomEditMode = false;
            state.draggingHandle = null;
            state.hoveredHandle = null;
            state.wallDragPreview = null;
            
            // Find first room on this level and switch to it
            const roomsOnLevel = state.rooms.filter(r => r.level === levelName);
            if (roomsOnLevel.length > 0) {
                const firstRoomIndex = state.rooms.indexOf(roomsOnLevel[0]);
                state.currentRoomIndex = firstRoomIndex;
            } else {
                // No rooms on this level yet
                state.currentRoomIndex = -1;
            }
            
            updateLevelButtons();
            updateRoomList();
            redraw2D();
            
            const roomCount = roomsOnLevel.length;
            if (roomCount === 0) {
                showToast(`üìç ${levelName} - Empty (Click "+ Add Room" to start)`, 3000);
            } else {
                showToast(`üìç ${levelName} - ${roomCount} room${roomCount !== 1 ? 's' : ''}`, 2000);
            }
            
            console.log(`‚úÖ Now on ${levelName} - ${roomCount} room(s) visible`);
        }

        function updateLevelButtons() {
            const selector = document.getElementById('levelSelector');
            if (!selector) {
                console.error('‚ùå Level selector not found!');
                return;
            }
            
            console.log(`Populating level dropdown with ${state.levels.length} levels:`, state.levels);
            selector.innerHTML = '';
            
            state.levels.forEach(level => {
                // Count rooms on this level
                const roomsOnLevel = state.rooms.filter(r => r.level === level).length;
                
                const option = document.createElement('option');
                option.value = level;
                option.textContent = `${level} (${roomsOnLevel})`;
                
                if (level === state.currentLevel) {
                    option.selected = true;
                }
                
                selector.appendChild(option);
                console.log(`  ‚úì Added option: ${level} (${roomsOnLevel} rooms)`);
            });
            
            // Update room count display
            const roomsOnCurrentLevel = state.rooms.filter(r => r.level === state.currentLevel).length;
            const countDisplay = document.getElementById('levelRoomCount');
            if (countDisplay) {
                countDisplay.textContent = roomsOnCurrentLevel === 0 ? 'No rooms yet' : 
                                          roomsOnCurrentLevel === 1 ? '1 room' : 
                                          `${roomsOnCurrentLevel} rooms`;
            }
            
            console.log(`‚úÖ Level dropdown updated - ${selector.options.length} options available`);
        }

        function updateRoomPosition() {
            const room = getCurrentRoom();
            if (!room) return;
            
            const roomPosX = document.getElementById('roomPosX');
            const roomPosZ = document.getElementById('roomPosZ');
            
            if (roomPosX && roomPosZ) {
                room.positionX = parseFloat(roomPosX.value) || 0;
                room.positionZ = parseFloat(roomPosZ.value) || 0;
            }
            
            if (state.currentView === '3d') {
                render3D();
            }
            showToast(`üìç Position: (${room.positionX}, ${room.positionZ})`);
        }

        function resetRoomPosition() {
            const room = getCurrentRoom();
            if (!room) return;
            
            room.positionX = state.currentRoomIndex * 30;
            room.positionZ = 0;
            
            const roomPosX = document.getElementById('roomPosX');
            const roomPosZ = document.getElementById('roomPosZ');
            if (roomPosX) roomPosX.value = room.positionX;
            if (roomPosZ) roomPosZ.value = room.positionZ;
            
            if (state.currentView === '3d') {
                render3D();
            }
            showToast('üìç Position reset');
        }

        function deleteRoom(index) {
            if (state.rooms.length === 1) {
                showToast('‚ùå Cannot delete last room');
                return;
            }
            if (confirm(`Delete "${state.rooms[index].name}"?`)) {
                state.rooms.splice(index, 1);
                state.currentRoomIndex = Math.min(state.currentRoomIndex, state.rooms.length - 1);
                updateRoomList();
                redraw2D();
            }
        }

        let editingRoomIndex = null;

        function showEditNameModal(roomIndex) {
            editingRoomIndex = roomIndex;
            const room = state.rooms[roomIndex];
            const modal = document.getElementById('editNameModal');
            const input = document.getElementById('editNameInput');
            
            input.value = room.name;
            modal.style.display = 'flex';
            
            // Focus and select text after modal is visible
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
            
            // Allow Enter key to submit
            input.onkeypress = function(e) {
                if (e.key === 'Enter') {
                    confirmEditName();
                }
            };
        }

        function cancelEditName() {
            document.getElementById('editNameModal').style.display = 'none';
            editingRoomIndex = null;
        }

        function confirmEditName() {
            const newName = document.getElementById('editNameInput').value.trim();
            
            if (newName && editingRoomIndex !== null) {
                const room = state.rooms[editingRoomIndex];
                if (newName !== room.name) {
                    room.name = newName;
                    updateRoomList();
                    redraw2D();
                    showToast(`‚úèÔ∏è Room renamed to "${newName}"`);
                }
            }
            
            document.getElementById('editNameModal').style.display = 'none';
            editingRoomIndex = null;
        }

        function showAddRoomModal() {
            const modal = document.getElementById('addRoomModal');
            const input = document.getElementById('addRoomInput');
            
            input.value = `Room ${state.rooms.length + 1}`;
            modal.style.display = 'flex';
            
            // Focus and select text after modal is visible
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
            
            // Allow Enter key to submit
            input.onkeypress = function(e) {
                if (e.key === 'Enter') {
                    confirmAddRoom();
                }
            };
        }

        function cancelAddRoom() {
            document.getElementById('addRoomModal').style.display = 'none';
        }

        function confirmAddRoom() {
            const name = document.getElementById('addRoomInput').value.trim() || `Room ${state.rooms.length + 1}`;
            
            console.log('===== ADDING NEW ROOM =====');
            console.log('Room name:', name);
            
            // Close modal first
            document.getElementById('addRoomModal').style.display = 'none';
            
            // Call addNewRoom to create a proper 12x12 room with geometry
            addNewRoom(name);
        }

        // ===== ROOM PROPERTIES MODAL FUNCTIONS =====
        
        function showRoomProperties(roomIndex) {
            const room = state.rooms[roomIndex];
            if (!room) return;
            
            // Populate form fields
            document.getElementById('propRoomName').value = room.name || '';
            document.getElementById('propCeilingHeight').value = room.ceilingHeight || 8.0;
            document.getElementById('propWallThickness').value = room.wallThickness || 4;
            document.getElementById('propRoomLevel').value = room.level || 'Main Floor';
            
            // Calculate and display statistics
            let floorArea = 0;
            let perimeter = 0;
            
            if (room.floorPoints && room.floorPoints.length >= 3) {
                // Calculate area using shoelace formula
                let area = 0;
                for (let i = 0; i < room.floorPoints.length; i++) {
                    const j = (i + 1) % room.floorPoints.length;
                    area += room.floorPoints[i].x * room.floorPoints[j].y;
                    area -= room.floorPoints[j].x * room.floorPoints[i].y;
                }
                floorArea = Math.abs(area / 2) / 900; // Convert from pixels¬≤ to feet¬≤ (30px = 1ft)
            }
            
            if (room.walls && room.walls.length > 0) {
                perimeter = room.walls.reduce((sum, wall) => sum + parseFloat(wall.length), 0);
            }
            
            document.getElementById('propFloorArea').textContent = floorArea.toFixed(2);
            document.getElementById('propPerimeter').textContent = perimeter.toFixed(2);
            document.getElementById('propWallCount').textContent = room.walls ? room.walls.length : 0;
            document.getElementById('propDoorCount').textContent = room.doors ? room.doors.length : 0;
            document.getElementById('propWindowCount').textContent = room.windows ? room.windows.length : 0;
            
            // Show modal
            document.getElementById('roomPropertiesModal').style.display = 'flex';
        }
        
        function closeRoomProperties() {
            document.getElementById('roomPropertiesModal').style.display = 'none';
        }
        
        function saveRoomProperties() {
            const room = getCurrentRoom();
            if (!room) return;
            
            // Save changes
            const newName = document.getElementById('propRoomName').value.trim();
            if (newName) room.name = newName;
            
            room.ceilingHeight = parseFloat(document.getElementById('propCeilingHeight').value) || 8.0;
            room.wallThickness = parseFloat(document.getElementById('propWallThickness').value) || 4;
            
            const newLevel = document.getElementById('propRoomLevel').value;
            if (newLevel !== room.level) {
                room.level = newLevel;
                // Update level if changed
                state.currentLevel = newLevel;
                updateLevelButtons();
            }
            
            // Update UI
            updateRoomList();
            redraw2D();
            updateStats();
            
            closeRoomProperties();
            showToast(`‚úÖ ${room.name} properties saved`, 2000);
        }

        // ===== LiDAR IMPORT FUNCTIONS =====
        
        let lidarFileData = null;
        
        function showLidarImport() {
            document.getElementById('lidarImportModal').style.display = 'flex';
            document.getElementById('lidarRoomName').value = `Room ${state.rooms.length + 1}`;
            document.getElementById('lidarFileInfo').style.display = 'none';
            document.getElementById('lidarProgress').style.display = 'none';
            document.getElementById('lidarError').style.display = 'none';
            if (document.getElementById('lidarProcessBtn')) {
                document.getElementById('lidarProcessBtn').style.display = 'none';
            }
            lidarFileData = null;
        }
        
        function cancelLidarImport() {
            document.getElementById('lidarImportModal').style.display = 'none';
            document.getElementById('lidarFileInput').value = '';
            lidarFileData = null;
        }
        
        function handleLidarFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            console.log('üì° LiDAR file selected:', file.name, file.size, 'bytes');
            
            // Hide error if showing
            document.getElementById('lidarError').style.display = 'none';
            
            // Show file info
            document.getElementById('lidarFileName').textContent = file.name;
            document.getElementById('lidarFileSize').textContent = `${(file.size / 1024).toFixed(1)} KB`;
            document.getElementById('lidarFileInfo').style.display = 'block';
            
            // Show progress
            document.getElementById('lidarProgress').style.display = 'block';
            updateLidarProgress(10, 'Reading file...');
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    const fileExt = file.name.toLowerCase().split('.').pop();
                    
                    console.log('üìÑ File loaded, size:', content.length, 'chars');
                    updateLidarProgress(50, 'Parsing file format...');
                    
                    if (fileExt === 'obj') {
                        lidarFileData = parseOBJFile(content);
                        updateLidarProgress(100, `‚úÖ Ready: ${lidarFileData.vertices.length} vertices found`);
                        console.log('‚úÖ OBJ parsed:', lidarFileData.vertices.length, 'vertices');
                    } else if (fileExt === 'csv') {
                        lidarFileData = parseCSVPointCloud(content);
                        updateLidarProgress(100, `‚úÖ Ready: ${lidarFileData.points.length} points found`);
                        console.log('‚úÖ CSV parsed:', lidarFileData.points.length, 'points');
                    } else {
                        showLidarError('Unsupported file format. Please use .obj or .csv files.');
                        updateLidarProgress(0, '');
                        return;
                    }
                    
                    // Show process button
                    document.getElementById('lidarProcessBtn').style.display = 'block';
                    
                } catch (error) {
                    console.error('‚ùå Error parsing LiDAR file:', error);
                    console.error('Stack:', error.stack);
                    showLidarError(`Parse error: ${error.message}. Check console (F12) for details.`);
                    updateLidarProgress(0, '');
                }
            };
            
            reader.onerror = function(error) {
                console.error('‚ùå Error reading file:', error);
                showLidarError('Error reading file. Please try again.');
                updateLidarProgress(0, '');
            };
            
            reader.readAsText(file);
        }
        
        function showLidarError(message) {
            document.getElementById('lidarErrorText').textContent = message;
            document.getElementById('lidarError').style.display = 'block';
            showToast('‚ùå ' + message);
        }
        
        function updateLidarProgress(percent, message) {
            document.getElementById('lidarProgressBar').style.width = percent + '%';
            document.getElementById('lidarProgressText').textContent = message;
        }
        
        function parseOBJFile(content) {
            console.log('üìä Parsing OBJ file...');
            const lines = content.split('\n');
            
            // Check format type
            const isCornerTrace = lines.some(line => 
                line.includes('# Cochran Claims Wall Trace') || 
                line.includes('# Corners:')
            );
            
            const isWallBased = lines.some(line =>
                line.includes('# Format: Wall-Based') ||
                line.includes('# Cochran Claims Wall Capture')
            );
            
            console.log(`üìê Format detected: ${isWallBased ? 'Wall-Based' : isCornerTrace ? 'Corner-Trace' : 'Unknown'}`);
            
            const vertices = [];
            const faces = [];
            const features = {
                doors: [],
                windows: [],
                openings: []
            };
            
            for (let line of lines) {
                line = line.trim();
                
                // Parse feature annotations from comments
                if (line.startsWith('#')) {
                    const featureMatch = line.match(/# (DOOR|WINDOW|OPENING) \d+: pos\(([^)]+)\) size\(([^)]+)\) normal\(([^)]+)\)/);
                    if (featureMatch) {
                        const type = featureMatch[1].toLowerCase();
                        const posStr = featureMatch[2].split(',');
                        const sizeStr = featureMatch[3].split('x');
                        const normalStr = featureMatch[4].split(',');
                        
                        const feature = {
                            type: type,
                            position: {
                                x: parseFloat(posStr[0]),
                                y: parseFloat(posStr[1]),
                                z: parseFloat(posStr[2])
                            },
                            size: {
                                width: parseFloat(sizeStr[0]),
                                height: parseFloat(sizeStr[1])
                            },
                            normal: {
                                x: parseFloat(normalStr[0]),
                                y: parseFloat(normalStr[1]),
                                z: parseFloat(normalStr[2])
                            }
                        };
                        
                        if (type === 'door') features.doors.push(feature);
                        else if (type === 'window') features.windows.push(feature);
                        else if (type === 'opening') features.openings.push(feature);
                    }
                    continue;
                }
                
                if (!line) continue;
                
                const parts = line.split(/\s+/);
                
                if (parts[0] === 'v') {
                    // Vertex: v x y z
                    vertices.push({
                        x: parseFloat(parts[1]),
                        y: parseFloat(parts[2]),
                        z: parseFloat(parts[3])
                    });
                } else if (parts[0] === 'f') {
                    // Face: f v1 v2 v3 (vertex indices)
                    const face = [];
                    for (let i = 1; i < parts.length; i++) {
                        const vertexIndex = parseInt(parts[i].split('/')[0]) - 1;
                        face.push(vertexIndex);
                    }
                    faces.push(face);
                }
            }
            
            console.log(`‚úÖ Parsed OBJ: ${vertices.length} vertices, ${faces.length} faces`);
            console.log(`üìê Features: ${features.doors.length} doors, ${features.windows.length} windows, ${features.openings.length} openings`);
            
            if (isCornerTrace) {
                console.log('üìê Detected corner-traced room from iPad');
            } else if (isWallBased) {
                console.log('üìê Detected wall-based room from iPad');
            }
            
            return { vertices, faces, features, type: 'obj', isCornerTrace, isWallBased };
        }
        
        function parseCSVPointCloud(content) {
            console.log('üìä Parsing CSV point cloud...');
            const lines = content.split('\n');
            const points = [];
            
            let hasHeader = false;
            let xCol = 0, yCol = 1, zCol = 2;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const parts = line.split(/[,\t]/);
                
                // Detect header
                if (i === 0 && (isNaN(parseFloat(parts[0])) || line.toLowerCase().includes('x'))) {
                    hasHeader = true;
                    // Try to find column indices
                    for (let j = 0; j < parts.length; j++) {
                        const col = parts[j].toLowerCase().trim();
                        if (col === 'x') xCol = j;
                        if (col === 'y') yCol = j;
                        if (col === 'z') zCol = j;
                    }
                    continue;
                }
                
                if (parts.length >= 3) {
                    const x = parseFloat(parts[xCol]);
                    const y = parseFloat(parts[yCol]);
                    const z = parseFloat(parts[zCol]);
                    
                    if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                        points.push({ x, y, z });
                    }
                }
            }
            
            console.log(`‚úÖ Parsed CSV: ${points.length} points`);
            return { points, type: 'csv' };
        }
        
        function processLidarData() {
            try {
                if (!lidarFileData) {
                    showLidarError('No LiDAR data loaded');
                    return;
                }
                
                console.log('üîÑ Processing LiDAR data...');
                updateLidarProgress(30, 'Analyzing point cloud...');
                
                // Check if this is a wall-based room
                if (lidarFileData.isWallBased) {
                    console.log('üìê Processing wall-based room from iPad');
                    processWallBasedRoom();
                    return;
                }
                
                // Check if this is a corner-traced room
                if (lidarFileData.isCornerTrace) {
                    console.log('üìê Processing corner-traced room from iPad');
                    processCornerTracedRoom();
                    return;
                }
                
                // Convert to point cloud
                let pointCloud = [];
                if (lidarFileData.type === 'obj') {
                    pointCloud = lidarFileData.vertices;
                } else {
                    pointCloud = lidarFileData.points;
                }
                
                console.log(`üìä Point cloud has ${pointCloud.length} points`);
                
                if (pointCloud.length === 0) {
                    showLidarError('No points found in file');
                    updateLidarProgress(0, '');
                    return;
                }
                
                if (pointCloud.length < 50) {
                    showLidarError(`Not enough points (${pointCloud.length}). Need at least 50 points for wall detection, OR use corner-tracing mode on iPad.`);
                    updateLidarProgress(0, '');
                    return;
                }
                
                updateLidarProgress(50, 'Detecting walls...');
                
                // Extract wall segments from point cloud
                const wallSegments = extractWallsFromPointCloud(pointCloud);
                
                console.log(`üî≤ Detected ${wallSegments.length} wall segments`);
                
                if (wallSegments.length < 3) {
                    showLidarError(`Could not detect enough walls (found ${wallSegments.length}, need at least 3). Try scanning with more wall coverage.`);
                    updateLidarProgress(0, '');
                    return;
                }
                
                updateLidarProgress(75, `Found ${wallSegments.length} walls, creating room...`);
                
                // Get wall settings from UI
                const wallThickness = parseInt(document.getElementById('lidarWallThickness').value);
                const measurementMode = document.getElementById('lidarMeasurementMode').value;
                
                console.log(`‚öôÔ∏è Wall settings: ${wallThickness}" thickness, ${measurementMode} mode`);
                
                // Create room from walls
                const roomName = document.getElementById('lidarRoomName').value.trim() || `Room ${state.rooms.length + 1}`;
                createRoomFromWalls(roomName, wallSegments, wallThickness, measurementMode);
                
                // Auto-place features if they exist
                const features = lidarFileData.features;
                if (features && (features.doors.length > 0 || features.windows.length > 0 || features.openings.length > 0)) {
                    console.log('üéØ Auto-placing features from scan...');
                    updateLidarProgress(85, 'Placing doors and windows...');
                    autoPlaceFeatures(features, pointCloud);
                }
                
                updateLidarProgress(100, '‚úÖ Room created successfully!');
                
                const featureCount = features ? (features.doors.length + features.windows.length + features.openings.length) : 0;
                const message = featureCount > 0 
                    ? `‚úÖ Room "${roomName}" created with ${wallSegments.length} walls and ${featureCount} features!`
                    : `‚úÖ Room "${roomName}" created from LiDAR scan with ${wallSegments.length} walls`;
                
                setTimeout(() => {
                    cancelLidarImport();
                    showToast(message);
                }, 1000);
                
            } catch (error) {
                console.error('‚ùå Error in processLidarData:', error);
                console.error('Stack:', error.stack);
                showLidarError(`Processing error: ${error.message}. Check console (F12) for details.`);
                updateLidarProgress(0, '');
            }
        }
        
        function orthogonalizeCorners(rawCorners) {
            console.log('üìê Starting orthogonalization...');
            console.log(`   Input: ${rawCorners.length} corners`);
            
            // Step 1: Find dominant wall direction (longest wall)
            let longestWallIndex = 0;
            let maxLength = 0;
            
            for (let i = 0; i < rawCorners.length; i++) {
                const start = rawCorners[i];
                const end = rawCorners[(i + 1) % rawCorners.length];
                const dx = end.x - start.x;
                const dz = end.z - start.z;
                const length = Math.sqrt(dx * dx + dz * dz);
                
                if (length > maxLength) {
                    maxLength = length;
                    longestWallIndex = i;
                }
            }
            
            // Step 2: Calculate angle of longest wall
            const start = rawCorners[longestWallIndex];
            const end = rawCorners[(longestWallIndex + 1) % rawCorners.length];
            const dx = end.x - start.x;
            const dz = end.z - start.z;
            let angle = Math.atan2(dz, dx);
            
            // Step 3: Round to nearest 90 degrees (0¬∞, 90¬∞, 180¬∞, 270¬∞)
            const angleInDegrees = angle * 180 / Math.PI;
            const roundedDegrees = Math.round(angleInDegrees / 90) * 90;
            const rotationAngle = (roundedDegrees - angleInDegrees) * Math.PI / 180;
            
            console.log(`   Longest wall: ${longestWallIndex} (${(maxLength * 3.28084).toFixed(2)} ft)`);
            console.log(`   Original angle: ${angleInDegrees.toFixed(2)}¬∞`);
            console.log(`   Rotating by: ${(rotationAngle * 180 / Math.PI).toFixed(2)}¬∞ to align to grid`);
            
            // Step 4: Find center point for rotation
            let centerX = 0, centerZ = 0;
            for (const corner of rawCorners) {
                centerX += corner.x;
                centerZ += corner.z;
            }
            centerX /= rawCorners.length;
            centerZ /= rawCorners.length;
            
            // Step 5: Rotate all corners around center
            const rotatedCorners = rawCorners.map(corner => {
                // Translate to origin
                const x = corner.x - centerX;
                const z = corner.z - centerZ;
                
                // Rotate
                const cos = Math.cos(rotationAngle);
                const sin = Math.sin(rotationAngle);
                const rotatedX = x * cos - z * sin;
                const rotatedZ = x * sin + z * cos;
                
                // Translate back
                return {
                    x: rotatedX + centerX,
                    y: corner.y,  // Keep floor height
                    z: rotatedZ + centerZ
                };
            });
            
            // Step 6: Snap to grid (0.05m = ~2 inches for tighter precision)
            const gridSize = 0.05;  // Tighter grid = cleaner floor plans
            const snappedCorners = rotatedCorners.map(corner => ({
                x: Math.round(corner.x / gridSize) * gridSize,
                y: corner.y,
                z: Math.round(corner.z / gridSize) * gridSize
            }));
            
            // Step 7: Use snapped corners directly - no H/V forcing!
            // Grid snapping + rotation is enough to make clean walls
            // Forcing H/V was causing corners to merge
            const orthogonalCorners = snappedCorners;
            
            // Step 8: Loop should already be closed due to grid snapping
            // Skip H/V forcing to preserve corner count
            
            console.log('‚úÖ Orthogonalization complete!');
            console.log(`   ${orthogonalCorners.length} corners preserved`);
            console.log(`   Walls straightened via grid alignment`);
            console.log(`   All corners snapped to ${(gridSize * 3.28084 * 12).toFixed(1)}" grid (2-inch precision)`);
            
            return orthogonalCorners;
        }
        
        function processCornerTracedRoom() {
            try {
                updateLidarProgress(40, 'Processing corner-traced room...');
                
                const corners = lidarFileData.vertices;
                
                console.log(`üìê Processing ${corners.length} corners`);
                
                if (corners.length < 3) {
                    showLidarError(`Need at least 3 corners (found ${corners.length}). Please trace more corners on iPad.`);
                    updateLidarProgress(0, '');
                    return;
                }
                
                updateLidarProgress(60, 'Converting corners to walls...');
                
                // SMART ORTHOGONALIZATION - Straighten walls but keep ALL corners
                console.log('üìê Orthogonalizing corners (preserving all corners)...');
                const orthogonalCorners = orthogonalizeCorners(corners);
                console.log('‚úÖ Corners orthogonalized - all corners preserved!');
                
                // Create walls in the format createRoomFromWalls expects
                // Corners are already in meters from iPad
                const walls = [];
                
                for (let i = 0; i < orthogonalCorners.length; i++) {
                    const start = orthogonalCorners[i];
                    const end = orthogonalCorners[(i + 1) % orthogonalCorners.length];
                    
                    // Calculate length in meters
                    const dx = end.x - start.x;
                    const dz = end.z - start.z;
                    const lengthMeters = Math.sqrt(dx * dx + dz * dz);
                    
                    walls.push({
                        start: { x: start.x, y: start.z },  // Use z as y (floor plane)
                        end: { x: end.x, y: end.z },
                        length: lengthMeters
                    });
                    
                    const lengthFeet = lengthMeters * 3.28084;
                    console.log(`  Wall ${i + 1}: ${lengthFeet.toFixed(2)} feet`);
                }
                
                updateLidarProgress(80, 'Creating room...');
                
                // Get room name
                const roomName = document.getElementById('lidarRoomName').value.trim() || 'Room ' + (rooms.length + 1);
                
                // Get wall settings
                const wallThickness = parseInt(document.getElementById('lidarWallThickness').value);
                const measurementMode = document.getElementById('lidarMeasurementMode').value;
                
                // Create the room using the correct function
                createRoomFromWalls(roomName, walls, wallThickness, measurementMode);
                
                // Auto-place features if any
                if (lidarFileData.features && 
                    (lidarFileData.features.doors.length > 0 || 
                     lidarFileData.features.windows.length > 0 || 
                     lidarFileData.features.openings.length > 0)) {
                    console.log('üéØ Auto-placing features from iPad scan...');
                    autoPlaceFeatures(lidarFileData.features, corners);
                }
                
                updateLidarProgress(100, '‚úÖ Corner-traced room created!');
                
                const featureCount = lidarFileData.features ? 
                    (lidarFileData.features.doors.length + lidarFileData.features.windows.length + lidarFileData.features.openings.length) : 0;
                
                const message = featureCount > 0 
                    ? `‚úÖ Room "${roomName}" created from iPad trace with ${walls.length} walls and ${featureCount} features!`
                    : `‚úÖ Room "${roomName}" created from iPad trace with ${walls.length} walls`;
                
                setTimeout(() => {
                    cancelLidarImport();
                    showToast(message);
                    // Enter edit mode after import
                    enterEditMode();
                }, 1000);
                
            } catch (error) {
                console.error('‚ùå Error in processCornerTracedRoom:', error);
                console.error('Stack:', error.stack);
                showLidarError(`Processing error: ${error.message}. Check console (F12) for details.`);
                updateLidarProgress(0, '');
            }
        }
        
        function processWallBasedRoom() {
            try {
                updateLidarProgress(40, 'Processing wall-based room...');
                
                const vertices = lidarFileData.vertices;
                
                // Vertices come in pairs: v1,v2 = wall 1, v3,v4 = wall 2, etc.
                if (vertices.length < 6 || vertices.length % 2 !== 0) {
                    showLidarError(`Invalid wall data: ${vertices.length} vertices. Expected pairs of vertices for walls.`);
                    updateLidarProgress(0, '');
                    return;
                }
                
                const wallCount = vertices.length / 2;
                console.log(`üìê Processing ${wallCount} walls from vertex pairs`);
                
                // Extract corners from wall endpoints
                const corners = [];
                for (let i = 0; i < vertices.length; i += 2) {
                    corners.push(vertices[i]);
                }
                
                updateLidarProgress(60, 'Converting walls to room...');
                
                // CRITICAL: Orthogonalize corners to fix crooked walls
                console.log('üìê Orthogonalizing corners...');
                const orthogonalCorners = orthogonalizeCorners(corners);
                console.log('‚úÖ Corners orthogonalized!');
                
                // Create walls in the format createRoomFromWalls expects
                const walls = [];
                
                for (let i = 0; i < orthogonalCorners.length; i++) {
                    const start = orthogonalCorners[i];
                    const end = orthogonalCorners[(i + 1) % orthogonalCorners.length];
                    
                    // Calculate length in meters
                    const dx = end.x - start.x;
                    const dz = end.z - start.z;
                    const lengthMeters = Math.sqrt(dx * dx + dz * dz);
                    
                    walls.push({
                        start: { x: start.x, y: start.z },  // Use z as y (floor plane)
                        end: { x: end.x, y: end.z },
                        length: lengthMeters
                    });
                    
                    const lengthFeet = lengthMeters * 3.28084;
                    console.log(`  Wall ${i + 1}: ${lengthFeet.toFixed(2)} feet`);
                }
                
                updateLidarProgress(80, 'Creating room...');
                
                // Get room name
                const roomName = document.getElementById('lidarRoomName').value.trim() || 'Room ' + (state.rooms.length + 1);
                
                // Get wall settings
                const wallThickness = parseInt(document.getElementById('lidarWallThickness').value);
                const measurementMode = document.getElementById('lidarMeasurementMode').value;
                
                // Create the room
                createRoomFromWalls(roomName, walls, wallThickness, measurementMode);
                
                // Auto-place features if any
                if (lidarFileData.features && 
                    (lidarFileData.features.doors.length > 0 || 
                     lidarFileData.features.windows.length > 0 || 
                     lidarFileData.features.openings.length > 0)) {
                    console.log('üéØ Auto-placing features from iPad scan...');
                    autoPlaceFeatures(lidarFileData.features, vertices);
                }
                
                updateLidarProgress(100, '‚úÖ Wall-based room created!');
                
                const featureCount = lidarFileData.features ? 
                    (lidarFileData.features.doors.length + lidarFileData.features.windows.length + lidarFileData.features.openings.length) : 0;
                
                const message = featureCount > 0 
                    ? `‚úÖ Room "${roomName}" created from iPad with ${wallCount} walls and ${featureCount} features!`
                    : `‚úÖ Room "${roomName}" created from iPad with ${wallCount} walls`;
                
                setTimeout(() => {
                    cancelLidarImport();
                    showToast(message);
                }, 1000);
                
            } catch (error) {
                console.error('‚ùå Error in processWallBasedRoom:', error);
                console.error('Stack:', error.stack);
                showLidarError(`Processing error: ${error.message}. Check console (F12) for details.`);
                updateLidarProgress(0, '');
            }
        }
        
        // =============================================
        // WALL EDITING MODE (Like Xactimate)
        // =============================================
        
        let editMode = {
            active: false,
            tool: 'select',  // select, force90, addWall, deleteWall, moveCorner, addDoor, addWindow, addOpening
            selectedWall: null,
            selectedWalls: [],  // For force90 tool - select 2 adjacent walls
            selectedCorner: null,
            dragStart: null,
            showAngles: false
        };
        
        function enterEditMode() {
            const room = getCurrentRoom();
            if (!room) {
                alert('Please select a room first');
                return;
            }
            
            console.log('üìê Entering edit mode');
            editMode.active = true;
            editMode.tool = 'select';
            editMode.selectedWalls = [];
            
            // Show toolbar
            document.getElementById('wallEditingToolbar').style.display = 'block';
            
            // Add edit mode class to canvas
            const canvas = document.getElementById('canvas2D');
            canvas.classList.add('edit-mode');
            
            // Update status
            updateEditStatus('Click a wall to edit its length, or select a tool above.');
            
            // Redraw with edit mode visuals
            redraw2D();
        }
        
        function exitEditMode() {
            console.log('üìê Exiting edit mode');
            editMode.active = false;
            editMode.tool = 'select';
            editMode.selectedWall = null;
            editMode.selectedWalls = [];
            editMode.selectedCorner = null;
            editMode.showAngles = false;
            
            // Hide toolbar
            document.getElementById('wallEditingToolbar').style.display = 'none';
            
            // Remove edit mode class
            const canvas = document.getElementById('canvas2D');
            canvas.classList.remove('edit-mode');
            
            // Redraw without edit mode visuals
            redraw2D();
        }
        
        function setEditTool(tool) {
            console.log('üîß Switching to tool:', tool);
            editMode.tool = tool;
            editMode.selectedWall = null;
            editMode.selectedWalls = [];  // Reset wall selections
            editMode.selectedCorner = null;
            
            // Update button states
            document.querySelectorAll('.edit-tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const toolBtn = document.getElementById('editTool' + tool.charAt(0).toUpperCase() + tool.slice(1));
            if (toolBtn) {
                toolBtn.classList.add('active');
            }
            
            // Update cursor
            const canvas = document.getElementById('canvas2D');
            canvas.classList.remove('move-cursor', 'delete-cursor');
            
            if (tool === 'moveCorner') {
                canvas.classList.add('move-cursor');
            } else if (tool === 'deleteWall') {
                canvas.classList.add('delete-cursor');
            }
            
            // Update status message
            const messages = {
                select: 'Click a wall to edit its length.',
                force90: 'Click two adjacent walls to make them 90¬∞ to each other.',
                addWall: 'Click two points to draw a new wall.',
                deleteWall: 'Click a wall to delete it.',
                moveCorner: 'Click and drag a corner to move it.',
                addDoor: 'Click on a wall to add a door.',
                addWindow: 'Click on a wall to add a window.',
                addOpening: 'Click on a wall to add an opening.'
            };
            
            updateEditStatus(messages[tool] || 'Select a tool.');
            
            redraw2D();
        }
        
        function toggleShowAngles() {
            editMode.showAngles = !editMode.showAngles;
            
            const btn = document.getElementById('editToolShowAngles');
            if (editMode.showAngles) {
                btn.classList.add('active');
                updateEditStatus('‚úì Wall angles displayed');
            } else {
                btn.classList.remove('active');
                updateEditStatus('Wall angles hidden');
            }
            
            redraw2D();
        }
        
        function updateEditStatus(message) {
            document.getElementById('editStatusBar').textContent = message;
        }
        
        function editCeilingHeight() {
            const room = getCurrentRoom();
            if (!room) {
                alert('Please select a room first');
                return;
            }
            
            const currentHeight = room.ceilingHeight || 8;
            const newHeight = prompt(`Enter ceiling height (feet):`, currentHeight);
            
            if (newHeight && !isNaN(newHeight) && parseFloat(newHeight) > 0) {
                room.ceilingHeight = parseFloat(newHeight);
                updateEditStatus(`‚úì Ceiling height set to ${newHeight}'`);
                redraw2D();
                if (state.currentView === '3d') render3D();
                showToast(`Ceiling height updated to ${newHeight}'`);
            }
        }
        
        function orthogonalizeCurrentRoom() {
            const room = getCurrentRoom();
            if (!room || !room.floorPoints || room.floorPoints.length < 3) {
                alert('Please select a room first');
                return;
            }
            
            if (!confirm('Straighten all walls to 90¬∞ angles? This will adjust corner positions.')) {
                return;
            }
            
            console.log('üìê Orthogonalizing current room...');
            
            // Convert floor points to the format orthogonalizeCorners expects
            const metersToPixels = 30 / 0.3048;
            const corners = room.floorPoints.map(p => ({
                x: p.x / metersToPixels,
                y: 0,
                z: p.y / metersToPixels
            }));
            
            // Orthogonalize
            const orthoCorners = orthogonalizeCorners(corners);
            
            // Convert back to pixels
            room.floorPoints = orthoCorners.map(c => ({
                x: c.x * metersToPixels,
                y: c.z * metersToPixels
            }));
            
            // Recalculate walls
            room.walls = [];
            for (let i = 0; i < room.floorPoints.length; i++) {
                const start = room.floorPoints[i];
                const end = room.floorPoints[(i + 1) % room.floorPoints.length];
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const lengthPixels = Math.sqrt(dx * dx + dy * dy);
                const lengthFeet = lengthPixels / 30;
                
                room.walls.push({
                    length: lengthFeet.toFixed(2)
                });
            }
            
            console.log('‚úÖ Room orthogonalized!');
            updateEditStatus('‚úì Walls straightened to 90¬∞ angles');
            redraw2D();
            if (state.currentView === '3d') render3D();
            showToast('Walls straightened successfully!');
        }
        
        // Force 90¬∞ Modal Functions
        let force90WallIndices = { wall1: null, wall2: null };
        
        function showForce90Modal(wall1Index, wall2Index) {
            force90WallIndices.wall1 = wall1Index;
            force90WallIndices.wall2 = wall2Index;
            
            // Update modal text
            document.getElementById('force90Wall1').textContent = wall1Index + 1;
            document.getElementById('force90Wall2').textContent = wall2Index + 1;
            document.getElementById('force90Wall2b').textContent = wall2Index + 1;
            
            // Show modal
            document.getElementById('force90Modal').style.display = 'flex';
        }
        
        function confirmForce90(direction) {
            const wall1 = force90WallIndices.wall1;
            const wall2 = force90WallIndices.wall2;
            
            if (wall1 === null || wall2 === null) return;
            
            // Hide modal
            document.getElementById('force90Modal').style.display = 'none';
            
            // Make walls 90¬∞ to each other in chosen direction
            makeWallsPerpendicular(wall1, wall2, direction);
            
            // Reset selection
            editMode.selectedWalls = [];
            updateEditStatus(`‚úì Walls ${wall1 + 1} and ${wall2 + 1} are now 90¬∞ (${direction === 'L' ? 'LEFT' : 'RIGHT'})!`);
            redraw2D();
            if (state.currentView === '3d') render3D();
            
            // Clear stored indices
            force90WallIndices = { wall1: null, wall2: null };
        }
        
        function cancelForce90() {
            document.getElementById('force90Modal').style.display = 'none';
            editMode.selectedWalls = [];
            force90WallIndices = { wall1: null, wall2: null };
            updateEditStatus('Force 90¬∞ cancelled. Click two adjacent walls to try again.');
            redraw2D();
        }
        
        function makeWallsPerpendicular(wall1Index, wall2Index, direction) {
            const room = getCurrentRoom();
            if (!room) return;
            
            console.log(`üìê Making walls ${wall1Index + 1} and ${wall2Index + 1} perpendicular (${direction === 'L' ? 'LEFT' : 'RIGHT'})...`);
            
            // Get the shared corner between the two walls
            let sharedCornerIndex;
            if (wall2Index === (wall1Index + 1) % room.floorPoints.length) {
                // wall2 comes after wall1
                sharedCornerIndex = (wall1Index + 1) % room.floorPoints.length;
            } else {
                // wall2 comes before wall1
                sharedCornerIndex = wall1Index;
            }
            
            const sharedCorner = room.floorPoints[sharedCornerIndex];
            
            // Get wall1 direction vector
            const wall1Start = room.floorPoints[wall1Index];
            const wall1End = room.floorPoints[(wall1Index + 1) % room.floorPoints.length];
            
            let wall1DirX = wall1End.x - wall1Start.x;
            let wall1DirY = wall1End.y - wall1Start.y;
            const wall1Length = Math.sqrt(wall1DirX * wall1DirX + wall1DirY * wall1DirY);
            wall1DirX /= wall1Length;
            wall1DirY /= wall1Length;
            
            // Get wall2 info
            const wall2Start = room.floorPoints[wall2Index];
            const wall2End = room.floorPoints[(wall2Index + 1) % room.floorPoints.length];
            
            // Calculate current wall2 length
            const wall2DirX = wall2End.x - wall2Start.x;
            const wall2DirY = wall2End.y - wall2Start.y;
            const wall2Length = Math.sqrt(wall2DirX * wall2DirX + wall2DirY * wall2DirY);
            
            // Create perpendicular direction to wall1
            // LEFT perpendicular: rotate wall1 direction 90¬∞ counter-clockwise = (-dy, dx)
            // RIGHT perpendicular: rotate wall1 direction 90¬∞ clockwise = (dy, -dx)
            
            let perpendicularX, perpendicularY;
            
            if (direction === 'L') {
                // 90¬∞ LEFT (counter-clockwise)
                perpendicularX = -wall1DirY;
                perpendicularY = wall1DirX;
            } else {
                // 90¬∞ RIGHT (clockwise)
                perpendicularX = wall1DirY;
                perpendicularY = -wall1DirX;
            }
            
            // Determine which end of wall2 to move
            if (wall2Index === (wall1Index + 1) % room.floorPoints.length) {
                // wall2 starts at shared corner
                // New end point for wall2
                const newEndX = sharedCorner.x + perpendicularX * wall2Length;
                const newEndY = sharedCorner.y + perpendicularY * wall2Length;
                
                // Update wall2's end point
                room.floorPoints[(wall2Index + 1) % room.floorPoints.length].x = newEndX;
                room.floorPoints[(wall2Index + 1) % room.floorPoints.length].y = newEndY;
                
            } else {
                // wall2 ends at shared corner
                // New start point for wall2 (use opposite direction)
                const newStartX = sharedCorner.x - perpendicularX * wall2Length;
                const newStartY = sharedCorner.y - perpendicularY * wall2Length;
                
                // Update wall2's start point
                room.floorPoints[wall2Index].x = newStartX;
                room.floorPoints[wall2Index].y = newStartY;
            }
            
            // Recalculate wall lengths
            for (let i = 0; i < room.walls.length; i++) {
                const start = room.floorPoints[i];
                const end = room.floorPoints[(i + 1) % room.floorPoints.length];
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                room.walls[i].length = (length / 30).toFixed(2);  // Convert pixels to feet
            }
            
            console.log(`‚úÖ Walls are now perpendicular (${direction === 'L' ? 'LEFT' : 'RIGHT'})!`);
        }
        
        function checkRoomQuality() {
            const room = getCurrentRoom();
            if (!room || !room.floorPoints || room.floorPoints.length < 3) {
                alert('Please select a room first');
                return;
            }
            
            console.log('üîç Checking room quality...');
            
            let report = `ROOM QUALITY REPORT: "${room.name}"\n`;
            report += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
            report += `Total Corners: ${room.floorPoints.length}\n`;
            report += `Total Walls: ${room.walls.length}\n\n`;
            
            // Check each corner angle
            let perfectCorners = 0;
            let nearPerfectCorners = 0;
            let problematicCorners = 0;
            
            report += `CORNER ANGLES:\n`;
            report += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
            
            for (let i = 0; i < room.floorPoints.length; i++) {
                const prev = room.floorPoints[(i - 1 + room.floorPoints.length) % room.floorPoints.length];
                const curr = room.floorPoints[i];
                const next = room.floorPoints[(i + 1) % room.floorPoints.length];
                
                // Calculate angle at this corner
                const dx1 = curr.x - prev.x;
                const dy1 = curr.y - prev.y;
                const dx2 = next.x - curr.x;
                const dy2 = next.y - curr.y;
                
                const angle1 = Math.atan2(dy1, dx1);
                const angle2 = Math.atan2(dy2, dx2);
                
                let angleDiff = (angle2 - angle1) * 180 / Math.PI;
                
                // Normalize to 0-360
                while (angleDiff < 0) angleDiff += 360;
                while (angleDiff > 360) angleDiff -= 360;
                
                // Interior angle
                const interiorAngle = 360 - angleDiff;
                const displayAngle = Math.round(interiorAngle);
                
                const deviation = Math.abs(displayAngle - 90);
                
                let status;
                if (deviation === 0) {
                    status = '‚úì PERFECT';
                    perfectCorners++;
                } else if (deviation <= 2) {
                    status = '‚úì GOOD';
                    nearPerfectCorners++;
                } else {
                    status = '‚úó NEEDS FIX';
                    problematicCorners++;
                }
                
                report += `Corner ${i + 1}: ${displayAngle}¬∞ (off by ${deviation}¬∞) ${status}\n`;
            }
            
            report += `\n`;
            report += `WALL LENGTHS:\n`;
            report += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
            
            room.walls.forEach((wall, i) => {
                const lengthFeet = parseFloat(wall.length);
                const feet = Math.floor(lengthFeet);
                const inches = Math.round((lengthFeet - feet) * 12);
                let dimensionText;
                if (inches === 0) {
                    dimensionText = `${feet}'`;
                } else if (inches === 12) {
                    dimensionText = `${feet + 1}'`;
                } else {
                    dimensionText = `${feet}' ${inches}"`;
                }
                report += `Wall ${i + 1}: ${dimensionText} (${lengthFeet.toFixed(2)} ft)\n`;
            });
            
            report += `\n`;
            report += `SUMMARY:\n`;
            report += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
            report += `Perfect (90¬∞): ${perfectCorners} corners\n`;
            report += `Good (88-92¬∞): ${nearPerfectCorners} corners\n`;
            report += `Needs Fix: ${problematicCorners} corners\n\n`;
            
            if (problematicCorners === 0) {
                report += `‚úì EXCELLENT! All corners are 90¬∞ or very close.\n`;
                report += `This room is ready for professional estimates!`;
            } else {
                report += `‚ö† ${problematicCorners} corners need correction.\n`;
                report += `Use [üìê Edit Room] ‚Üí [‚äæ Force 90¬∞] to fix them.`;
            }
            
            alert(report);
            console.log(report);
        }
        
        function squareUpCorners() {
            const room = getCurrentRoom();
            if (!room || !room.floorPoints || room.floorPoints.length < 3) {
                alert('Please select a room first');
                return;
            }
            
            const confirmed = confirm(
                `Square up all corners in "${room.name}"?\n\n` +
                `This will adjust corners to perfect 90¬∞ angles.\n` +
                `Use this to fix rooms with angled or misaligned corners.`
            );
            
            if (!confirmed) return;
            
            // Save state for undo before making changes
            saveStateForUndo();
            
            console.log('üîß Squaring up corners for:', room.name);
            
            // For a simple rectangular room, we can fix it by:
            // 1. Finding the dominant direction (horizontal/vertical)
            // 2. Snapping points to grid aligned with those directions
            
            // Calculate average positions for each axis
            const numPoints = room.floorPoints.length;
            
            // Group points by approximate X and Y positions
            const xGroups = {};
            const yGroups = {};
            const tolerance = 30; // pixels
            
            room.floorPoints.forEach((p, i) => {
                // Find or create X group
                let foundX = false;
                for (const xKey in xGroups) {
                    if (Math.abs(parseFloat(xKey) - p.x) < tolerance) {
                        xGroups[xKey].push(i);
                        foundX = true;
                        break;
                    }
                }
                if (!foundX) xGroups[p.x] = [i];
                
                // Find or create Y group
                let foundY = false;
                for (const yKey in yGroups) {
                    if (Math.abs(parseFloat(yKey) - p.y) < tolerance) {
                        yGroups[yKey].push(i);
                        foundY = true;
                        break;
                    }
                }
                if (!foundY) yGroups[p.y] = [i];
            });
            
            // Snap points to average positions
            for (const xKey in xGroups) {
                const indices = xGroups[xKey];
                const avgX = indices.reduce((sum, i) => sum + room.floorPoints[i].x, 0) / indices.length;
                indices.forEach(i => room.floorPoints[i].x = Math.round(avgX));
            }
            
            for (const yKey in yGroups) {
                const indices = yGroups[yKey];
                const avgY = indices.reduce((sum, i) => sum + room.floorPoints[i].y, 0) / indices.length;
                indices.forEach(i => room.floorPoints[i].y = Math.round(avgY));
            }
            
            // Update walls
            updateRoomWallsFromPoints(room);
            redraw2D();
            updateStats();
            
            showToast(`‚úÖ Corners squared up for ${room.name}`, 3000);
            console.log('‚úÖ Corners squared up successfully');
        }
        
        function autoPlaceFeatures(features, pointCloud) {
            const room = getCurrentRoom();
            if (!room || !room.walls || room.walls.length === 0) {
                console.warn('‚ö†Ô∏è Cannot auto-place features: room not found');
                return;
            }
            
            console.log(`üéØ Auto-placing features: ${features.doors.length} doors, ${features.windows.length} windows, ${features.openings.length} openings`);
            
            // Convert meters to pixels (30 pixels = 1 foot)
            const metersToPixels = 30 / 0.3048;
            const metersToFeet = 3.28084;
            
            // Process each feature type
            let added = { doors: 0, windows: 0, openings: 0 };
            
            // Add doors
            for (const door of features.doors) {
                const result = placeFeatureOnWall(door, room, metersToFeet);
                if (result) {
                    room.doors.push({
                        wallIndex: result.wallIndex,
                        width: result.width,
                        position: result.position,
                        type: 'swinging'
                    });
                    added.doors++;
                    console.log(`  üö™ Placed door on wall ${result.wallIndex + 1} at ${result.position.toFixed(1)} ft`);
                }
            }
            
            // Add windows
            for (const window of features.windows) {
                const result = placeFeatureOnWall(window, room, metersToFeet);
                if (result) {
                    room.windows.push({
                        wallIndex: result.wallIndex,
                        width: result.width,
                        height: result.height,
                        position: result.position,
                        sillHeight: 3.0  // Default 3 feet
                    });
                    added.windows++;
                    console.log(`  ü™ü Placed window on wall ${result.wallIndex + 1} at ${result.position.toFixed(1)} ft`);
                }
            }
            
            // Add openings (as door openings with no door)
            for (const opening of features.openings) {
                const result = placeFeatureOnWall(opening, room, metersToFeet);
                if (result) {
                    room.openings = room.openings || [];
                    room.openings.push({
                        wallIndex: result.wallIndex,
                        width: result.width,
                        position: result.position,
                        type: 'archway'
                    });
                    added.openings++;
                    console.log(`  ‚¨úÔ∏è Placed opening on wall ${result.wallIndex + 1} at ${result.position.toFixed(1)} ft`);
                }
            }
            
            console.log(`‚úÖ Auto-placed: ${added.doors} doors, ${added.windows} windows, ${added.openings} openings`);
            
            // Redraw to show features
            redraw2D();
            if (state.currentView === '3d') render3D();
        }
        
        function placeFeatureOnWall(feature, room, metersToFeet) {
            // Find which wall this feature belongs to by comparing position and normal
            const featurePos = feature.position;
            const normal = feature.normal;
            
            let bestWallIndex = -1;
            let minDistance = Infinity;
            
            // Check each wall
            for (let i = 0; i < room.walls.length; i++) {
                const wall = room.walls[i];
                
                // Calculate wall direction and normal in 2D
                const wallStart = room.floorPoints[i];
                const wallEndIdx = (i + 1) % room.floorPoints.length;
                const wallEnd = room.floorPoints[wallEndIdx];
                
                const wallDx = wallEnd.x - wallStart.x;
                const wallDy = wallEnd.y - wallStart.y;
                const wallLength = Math.sqrt(wallDx * wallDx + wallDy * wallDy);
                
                // Wall normal (perpendicular to wall direction)
                const wallNormalX = -wallDy / wallLength;
                const wallNormalY = wallDx / wallLength;
                
                // Check if feature normal aligns with wall normal (dot product > 0.7)
                const normalAlignment = Math.abs(normal.x * wallNormalX + normal.z * wallNormalY);
                
                if (normalAlignment > 0.5) {
                    // Calculate distance from feature to wall line
                    // Project feature onto wall to find position along wall
                    const toFeatureX = (featurePos.x * metersToFeet * 30 / 0.3048) - wallStart.x;
                    const toFeatureY = (featurePos.z * metersToFeet * 30 / 0.3048) - wallStart.y;
                    
                    const projectionOnWall = (toFeatureX * wallDx + toFeatureY * wallDy) / (wallLength * wallLength);
                    
                    // Check if projection is within wall bounds
                    if (projectionOnWall >= 0 && projectionOnWall <= 1) {
                        // Calculate perpendicular distance to wall
                        const projX = wallStart.x + projectionOnWall * wallDx;
                        const projY = wallStart.y + projectionOnWall * wallDy;
                        const featureX = featurePos.x * metersToFeet * 30 / 0.3048;
                        const featureY = featurePos.z * metersToFeet * 30 / 0.3048;
                        const distance = Math.sqrt((featureX - projX) ** 2 + (featureY - projY) ** 2);
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            bestWallIndex = i;
                        }
                    }
                }
            }
            
            if (bestWallIndex === -1) {
                console.warn(`  ‚ö†Ô∏è Could not find wall for feature at (${featurePos.x.toFixed(2)}, ${featurePos.z.toFixed(2)})`);
                return null;
            }
            
            // Calculate position along wall (from left corner)
            const wall = room.walls[bestWallIndex];
            const wallStart = room.floorPoints[bestWallIndex];
            const wallEndIdx = (bestWallIndex + 1) % room.floorPoints.length;
            const wallEnd = room.floorPoints[wallEndIdx];
            
            const wallDx = wallEnd.x - wallStart.x;
            const wallDy = wallEnd.y - wallStart.y;
            const wallLength = Math.sqrt(wallDx * wallDx + wallDy * wallDy);
            
            const toFeatureX = (featurePos.x * metersToFeet * 30 / 0.3048) - wallStart.x;
            const toFeatureY = (featurePos.z * metersToFeet * 30 / 0.3048) - wallStart.y;
            
            const projectionOnWall = (toFeatureX * wallDx + toFeatureY * wallDy) / (wallLength * wallLength);
            const positionPixels = projectionOnWall * wallLength;
            const positionFeet = positionPixels / 30;  // Convert pixels to feet
            
            return {
                wallIndex: bestWallIndex,
                position: Math.max(0, Math.min(parseFloat(wall.length), positionFeet)),  // Clamp to wall length
                width: feature.size.width * metersToFeet,
                height: feature.size.height * metersToFeet
            };
        }
        
        function extractWallsFromPointCloud(points) {
            console.log(`üîç Extracting walls from ${points.length} points...`);
            
            // Find floor level (lowest Y or Z depending on orientation)
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            for (let p of points) {
                if (p.y < minY) minY = p.y;
                if (p.y > maxY) maxY = p.y;
                if (p.z < minZ) minZ = p.z;
                if (p.z > maxZ) maxZ = p.z;
            }
            
            // Determine which axis is vertical (has larger range)
            const yRange = maxY - minY;
            const zRange = maxZ - minZ;
            const isYUp = yRange > zRange;
            
            console.log(`Vertical axis: ${isYUp ? 'Y' : 'Z'}, range: ${isYUp ? yRange.toFixed(2) : zRange.toFixed(2)}m`);
            
            // Filter points near floor level (bottom 30% of vertical range)
            const floorThreshold = isYUp ? minY + yRange * 0.3 : minZ + zRange * 0.3;
            const floorPoints = points.filter(p => {
                const verticalPos = isYUp ? p.y : p.z;
                return verticalPos <= floorThreshold;
            });
            
            console.log(`üìê Floor points: ${floorPoints.length} of ${points.length}`);
            
            if (floorPoints.length < 10) {
                throw new Error('Not enough floor points to detect walls');
            }
            
            // Project to 2D (X, Z or X, Y plane)
            const points2D = floorPoints.map(p => ({
                x: p.x,
                y: isYUp ? p.z : p.y
            }));
            
            // ==================================================================
            // ROBUST ALGORITHM: Detect major wall planes and square corners
            // ==================================================================
            
            console.log('üß† Detecting major wall planes...');
            
            // Step 1: Find bounding box
            let minX = Infinity, maxX = -Infinity;
            let minYp = Infinity, maxYp = -Infinity;
            
            for (let p of points2D) {
                if (p.x < minX) minX = p.x;
                if (p.x > maxX) maxX = p.x;
                if (p.y < minYp) minYp = p.y;
                if (p.y > maxYp) maxYp = p.y;
            }
            
            const widthX = maxX - minX;
            const widthY = maxYp - minYp;
            
            console.log(`üìè Bounding box: ${widthX.toFixed(2)}m √ó ${widthY.toFixed(2)}m`);
            
            // Step 2: Detect wall regions using histogram approach
            // Divide room into 20 bins for each axis
            const binsX = 20;
            const binsY = 20;
            const histX = new Array(binsX).fill(0);
            const histY = new Array(binsY).fill(0);
            
            for (let p of points2D) {
                const binX = Math.floor(((p.x - minX) / widthX) * (binsX - 1));
                const binY = Math.floor(((p.y - minYp) / widthY) * (binsY - 1));
                if (binX >= 0 && binX < binsX) histX[binX]++;
                if (binY >= 0 && binY < binsY) histY[binY]++;
            }
            
            // Step 3: Find edges (where point density drops off)
            // Look at first and last 30% of bins
            const edgeThreshold = 0.3;
            
            function findEdgeBins(histogram) {
                const edges = [];
                const avgDensity = histogram.reduce((a, b) => a + b) / histogram.length;
                const threshold = avgDensity * 0.2; // 20% of average
                
                // Find first bin with significant points
                for (let i = 0; i < histogram.length; i++) {
                    if (histogram[i] > threshold) {
                        edges.push(i);
                        break;
                    }
                }
                
                // Find last bin with significant points
                for (let i = histogram.length - 1; i >= 0; i--) {
                    if (histogram[i] > threshold) {
                        edges.push(i);
                        break;
                    }
                }
                
                return edges;
            }
            
            const edgesX = findEdgeBins(histX);
            const edgesY = findEdgeBins(histY);
            
            console.log(`üìä Edge bins - X: ${edgesX}, Y: ${edgesY}`);
            
            // Convert bin indices to world coordinates
            const leftX = edgesX[0] !== undefined ? minX + (edgesX[0] / (binsX - 1)) * widthX : minX;
            const rightX = edgesX[1] !== undefined ? minX + (edgesX[1] / (binsX - 1)) * widthX : maxX;
            const bottomY = edgesY[0] !== undefined ? minYp + (edgesY[0] / (binsY - 1)) * widthY : minYp;
            const topY = edgesY[1] !== undefined ? minYp + (edgesY[1] / (binsY - 1)) * widthY : maxYp;
            
            console.log(`üìê Wall positions:`);
            console.log(`   Left X: ${leftX.toFixed(3)}m, Right X: ${rightX.toFixed(3)}m`);
            console.log(`   Bottom Y: ${bottomY.toFixed(3)}m, Top Y: ${topY.toFixed(3)}m`);
            
            // Step 4: Check for pop-outs and recesses by looking at point distribution
            // Divide each wall region into segments and check for indentations
            const wallSegments = detectWallFeatures(points2D, leftX, rightX, bottomY, topY);
            
            console.log(`üî≤ Detected ${wallSegments.length} wall segments`);
            
            // Calculate room dimensions
            const roomWidth = rightX - leftX;
            const roomLength = topY - bottomY;
            const roomWidthFeet = roomWidth * 3.28084;
            const roomLengthFeet = roomLength * 3.28084;
            const roomArea = roomWidthFeet * roomLengthFeet;
            
            console.log(`‚úÖ Room detected:`);
            console.log(`   Base dimensions: ${roomWidthFeet.toFixed(1)} ft √ó ${roomLengthFeet.toFixed(1)} ft`);
            console.log(`   Area: ~${roomArea.toFixed(0)} sq ft`);
            console.log(`   Walls: ${wallSegments.length}`);
            
            return wallSegments;
        }
        
        function detectWallFeatures(points, leftX, rightX, bottomY, topY) {
            const walls = [];
            const widthX = rightX - leftX;
            const widthY = topY - bottomY;
            
            // Define wall regions (outer 20% on each side)
            const margin = 0.20;
            const xMargin = widthX * margin;
            const yMargin = widthY * margin;
            
            // Classify points by wall region
            const leftWall = points.filter(p => p.x < leftX + xMargin);
            const rightWall = points.filter(p => p.x > rightX - xMargin);
            const bottomWall = points.filter(p => p.y < bottomY + yMargin);
            const topWall = points.filter(p => p.y > topY - yMargin);
            
            console.log(`üîç Wall point counts: L=${leftWall.length}, R=${rightWall.length}, B=${bottomWall.length}, T=${topWall.length}`);
            
            // Analyze each wall for segments, gaps (doors), and pop-outs
            const leftSegments = analyzeWallForIndentations(leftWall, 'vertical', leftX, bottomY, topY, points);
            const rightSegments = analyzeWallForIndentations(rightWall, 'vertical', rightX, bottomY, topY, points);
            const bottomSegments = analyzeWallForIndentations(bottomWall, 'horizontal', bottomY, leftX, rightX, points);
            const topSegments = analyzeWallForIndentations(topWall, 'horizontal', topY, leftX, rightX, points);
            
            // Build wall list from segments
            // Bottom wall (left to right)
            for (let seg of bottomSegments) {
                walls.push({
                    start: { x: seg.start, y: seg.position },
                    end: { x: seg.end, y: seg.position },
                    length: seg.end - seg.start
                });
            }
            
            // Right wall (bottom to top)
            for (let seg of rightSegments) {
                walls.push({
                    start: { x: seg.position, y: seg.start },
                    end: { x: seg.position, y: seg.end },
                    length: seg.end - seg.start
                });
            }
            
            // Top wall (right to left)
            for (let seg of topSegments) {
                walls.push({
                    start: { x: seg.end, y: seg.position },
                    end: { x: seg.start, y: seg.position },
                    length: seg.end - seg.start
                });
            }
            
            // Left wall (top to bottom)
            for (let seg of leftSegments) {
                walls.push({
                    start: { x: seg.position, y: seg.end },
                    end: { x: seg.position, y: seg.start },
                    length: seg.end - seg.start
                });
            }
            
            return walls;
        }
        
        function analyzeWallForIndentations(wallPoints, orientation, wallPosition, rangeStart, rangeEnd) {
            if (wallPoints.length < 3) {
                // Not enough points, return full wall segment
                return [{ start: rangeStart, end: rangeEnd, position: wallPosition }];
            }
            
            // Step 1: Divide wall into bins along its length
            const numBins = 40; // Divide wall into 40 segments
            const rangeLength = rangeEnd - rangeStart;
            const binSize = rangeLength / numBins;
            const bins = new Array(numBins).fill(0);
            const binPositions = new Array(numBins).fill(null).map(() => []);
            
            // Step 2: Count points in each bin and track perpendicular positions
            for (let p of wallPoints) {
                const alongWall = orientation === 'vertical' ? p.y : p.x;
                const perpWall = orientation === 'vertical' ? p.x : p.y;
                
                if (alongWall >= rangeStart && alongWall <= rangeEnd) {
                    const binIndex = Math.floor((alongWall - rangeStart) / binSize);
                    if (binIndex >= 0 && binIndex < numBins) {
                        bins[binIndex]++;
                        binPositions[binIndex].push(perpWall);
                    }
                }
            }
            
            console.log(`   ${orientation} wall analysis: ${bins.reduce((a,b) => a+b, 0)} points in ${numBins} bins`);
            
            // Step 3: Detect gaps (doors/openings) and pop-outs
            const avgDensity = bins.reduce((a, b) => a + b, 0) / numBins;
            const gapThreshold = avgDensity * 0.3; // Less than 30% of average = gap
            
            console.log(`   Average density: ${avgDensity.toFixed(1)} points/bin, Gap threshold: ${gapThreshold.toFixed(1)}`);
            
            const segments = [];
            let segmentStart = null;
            let segmentPositions = [];
            
            for (let i = 0; i < numBins; i++) {
                const binCenter = rangeStart + (i + 0.5) * binSize;
                const hasPoints = bins[i] >= gapThreshold;
                
                if (hasPoints) {
                    if (segmentStart === null) {
                        segmentStart = rangeStart + i * binSize;
                    }
                    // Collect perpendicular positions for pop-out detection
                    segmentPositions.push(...binPositions[i]);
                } else {
                    // Gap detected - end current segment
                    if (segmentStart !== null) {
                        const segmentEnd = rangeStart + i * binSize;
                        
                        // Calculate average perpendicular position (for pop-out detection)
                        let avgPosition = wallPosition;
                        if (segmentPositions.length > 0) {
                            avgPosition = segmentPositions.reduce((a, b) => a + b, 0) / segmentPositions.length;
                        }
                        
                        // Check if this is a pop-out (points significantly away from wall)
                        const offset = Math.abs(avgPosition - wallPosition);
                        if (offset > 0.3) { // 30cm+ offset = pop-out
                            console.log(`   üî≤ Pop-out detected at ${segmentStart.toFixed(2)}-${segmentEnd.toFixed(2)}, offset: ${offset.toFixed(2)}m`);
                        }
                        
                        segments.push({
                            start: segmentStart,
                            end: segmentEnd,
                            position: avgPosition
                        });
                        
                        segmentStart = null;
                        segmentPositions = [];
                    }
                }
            }
            
            // Close final segment
            if (segmentStart !== null) {
                let avgPosition = wallPosition;
                if (segmentPositions.length > 0) {
                    avgPosition = segmentPositions.reduce((a, b) => a + b, 0) / segmentPositions.length;
                }
                
                const offset = Math.abs(avgPosition - wallPosition);
                if (offset > 0.3) {
                    console.log(`   üî≤ Pop-out detected at ${segmentStart.toFixed(2)}-${rangeEnd.toFixed(2)}, offset: ${offset.toFixed(2)}m`);
                }
                
                segments.push({
                    start: segmentStart,
                    end: rangeEnd,
                    position: avgPosition
                });
            }
            
            console.log(`   ‚úÖ Found ${segments.length} segment(s) on this wall`);
            
            // If no segments found, return full wall
            if (segments.length === 0) {
                return [{ start: rangeStart, end: rangeEnd, position: wallPosition }];
            }
            
            return segments;
        }
        
        function traceBoundary(boundaryCells, gridSize) {
            if (boundaryCells.length === 0) return [];
            
            // Start with leftmost-bottom point
            let current = boundaryCells[0];
            for (let cell of boundaryCells) {
                if (cell.x < current.x || (cell.x === current.x && cell.y < current.y)) {
                    current = cell;
                }
            }
            
            const visited = new Set();
            const ordered = [current];
            visited.add(`${current.gx},${current.gy}`);
            
            // Trace boundary by finding nearest unvisited neighbor
            while (ordered.length < boundaryCells.length) {
                let nearest = null;
                let minDist = Infinity;
                
                for (let cell of boundaryCells) {
                    const key = `${cell.gx},${cell.gy}`;
                    if (visited.has(key)) continue;
                    
                    const dx = cell.x - current.x;
                    const dy = cell.y - current.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Only consider cells within 3 grid cells
                    if (dist < gridSize * 3 && dist < minDist) {
                        minDist = dist;
                        nearest = cell;
                    }
                }
                
                if (!nearest) break; // No more connected cells
                
                current = nearest;
                ordered.push(current);
                visited.add(`${current.gx},${current.gy}`);
            }
            
            return ordered;
        }
        
        function simplifyBoundary(points, tolerance) {
            if (points.length < 3) return points;
            
            // Douglas-Peucker simplification
            function simplifySegment(start, end, points, tolerance) {
                if (end - start <= 1) return [];
                
                let maxDist = 0;
                let maxIndex = -1;
                
                const p1 = points[start];
                const p2 = points[end];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const lenSq = dx * dx + dy * dy;
                
                for (let i = start + 1; i < end; i++) {
                    const p = points[i];
                    
                    // Calculate perpendicular distance from point to line segment
                    let dist;
                    if (lenSq === 0) {
                        dist = Math.sqrt((p.x - p1.x) ** 2 + (p.y - p1.y) ** 2);
                    } else {
                        const t = Math.max(0, Math.min(1, ((p.x - p1.x) * dx + (p.y - p1.y) * dy) / lenSq));
                        const projX = p1.x + t * dx;
                        const projY = p1.y + t * dy;
                        dist = Math.sqrt((p.x - projX) ** 2 + (p.y - projY) ** 2);
                    }
                    
                    if (dist > maxDist) {
                        maxDist = dist;
                        maxIndex = i;
                    }
                }
                
                if (maxDist > tolerance) {
                    const left = simplifySegment(start, maxIndex, points, tolerance);
                    const right = simplifySegment(maxIndex, end, points, tolerance);
                    return [...left, points[maxIndex], ...right];
                } else {
                    return [];
                }
            }
            
            const simplified = [points[0]];
            const middle = simplifySegment(0, points.length - 1, points, tolerance);
            simplified.push(...middle);
            simplified.push(points[points.length - 1]);
            
            return simplified;
        }
        
        function calculatePolygonArea(points) {
            if (points.length < 3) return 0;
            
            let area = 0;
            for (let i = 0; i < points.length; i++) {
                const j = (i + 1) % points.length;
                area += points[i].x * points[j].y;
                area -= points[j].x * points[i].y;
            }
            return Math.abs(area) / 2;
        }
        
        function findConvexHull(points) {
            // Graham scan algorithm for convex hull
            if (points.length < 3) return points;
            
            // Find the bottom-most point (or left-most if tied)
            let start = points[0];
            for (let p of points) {
                if (p.y < start.y || (p.y === start.y && p.x < start.x)) {
                    start = p;
                }
            }
            
            // Sort points by polar angle with respect to start point
            const sorted = points.filter(p => p !== start).sort((a, b) => {
                const angleA = Math.atan2(a.y - start.y, a.x - start.x);
                const angleB = Math.atan2(b.y - start.y, b.x - start.x);
                return angleA - angleB;
            });
            
            // Graham scan
            const hull = [start, sorted[0]];
            
            for (let i = 1; i < sorted.length; i++) {
                let top = hull[hull.length - 1];
                let nextTop = hull[hull.length - 2];
                
                // Remove points that create right turn
                while (hull.length >= 2 && ccw(nextTop, top, sorted[i]) <= 0) {
                    hull.pop();
                    if (hull.length >= 2) {
                        top = hull[hull.length - 1];
                        nextTop = hull[hull.length - 2];
                    }
                }
                
                hull.push(sorted[i]);
            }
            
            // Simplify hull - merge nearly collinear points
            const simplified = [hull[0]];
            for (let i = 1; i < hull.length - 1; i++) {
                const prev = simplified[simplified.length - 1];
                const curr = hull[i];
                const next = hull[i + 1];
                
                // Check if current point is nearly collinear with prev and next
                const crossProduct = Math.abs(ccw(prev, curr, next));
                if (crossProduct > 0.01) { // Keep point if not collinear
                    simplified.push(curr);
                }
            }
            simplified.push(hull[hull.length - 1]);
            
            return simplified;
        }
        
        function ccw(a, b, c) {
            // Counter-clockwise test
            return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        }
        
        function createRoomFromWalls(roomName, wallSegments, wallThickness = 4, measurementMode = 'interior') {
            console.log(`üèóÔ∏è Creating room "${roomName}" from ${wallSegments.length} walls...`);
            console.log(`   Wall thickness: ${wallThickness}", Mode: ${measurementMode}`);
            
            // Apply wall offset if exterior mode
            let adjustedSegments = wallSegments;
            if (measurementMode === 'exterior') {
                const offsetMeters = (wallThickness / 12) * 0.3048 / 2; // Half thickness in meters
                console.log(`   Applying ${(offsetMeters * 39.3701).toFixed(2)}" outward offset to walls`);
                adjustedSegments = offsetWallsOutward(wallSegments, offsetMeters);
            }
            
            // Find center and scale factor
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            for (let wall of adjustedSegments) {
                minX = Math.min(minX, wall.start.x, wall.end.x);
                maxX = Math.max(maxX, wall.start.x, wall.end.x);
                minY = Math.min(minY, wall.start.y, wall.end.y);
                maxY = Math.max(maxY, wall.start.y, wall.end.y);
            }
            
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const scaleX = maxX - minX;
            const scaleY = maxY - minY;
            
            // Convert meters to pixels (30 pixels = 1 foot, ~0.3048 meters)
            const metersToPixels = 30 / 0.3048;
            
            // Create floor points
            const floorPoints = adjustedSegments.map(wall => ({
                x: (wall.start.x - centerX) * metersToPixels,
                y: (wall.start.y - centerY) * metersToPixels
            }));
            
            // Create walls with lengths in feet
            const walls = adjustedSegments.map((seg, i) => {
                const lengthMeters = seg.length;
                const lengthFeet = lengthMeters / 0.3048;
                
                const nextIdx = (i + 1) % adjustedSegments.length;
                const start = floorPoints[i];
                const end = floorPoints[nextIdx];
                
                return {
                    name: `Wall ${i + 1}`,
                    length: lengthFeet.toFixed(1),
                    start: start,
                    end: end
                };
            });
            
            // Create room
            state.rooms.push({
                name: roomName,
                floorPoints: floorPoints,
                walls: walls,
                ceilingHeight: 8.0,
                wallThickness: wallThickness,
                doors: [],
                windows: [],
                damageMarkers: [],
                openings: [],
                positionX: state.rooms.length * 30,
                positionZ: 0
            });
            
            state.currentRoomIndex = state.rooms.length - 1;
            updateRoomList();
            redraw2D();
            if (state.currentView === '3d') render3D();
            
            console.log(`‚úÖ Room created successfully!`);
        }
        
        function offsetWallsOutward(wallSegments, offsetDistance) {
            // Calculate center point to determine outward direction
            let centerX = 0, centerY = 0;
            for (let wall of wallSegments) {
                centerX += wall.start.x + wall.end.x;
                centerY += wall.start.y + wall.end.y;
            }
            centerX /= (wallSegments.length * 2);
            centerY /= (wallSegments.length * 2);
            
            // Offset each wall segment outward
            const offsetSegments = wallSegments.map(wall => {
                // Calculate wall direction vector
                const dx = wall.end.x - wall.start.x;
                const dy = wall.end.y - wall.start.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                // Calculate perpendicular (normal) vector
                const normalX = -dy / length;
                const normalY = dx / length;
                
                // Determine which direction is outward (away from center)
                const midX = (wall.start.x + wall.end.x) / 2;
                const midY = (wall.start.y + wall.end.y) / 2;
                const toCenterX = centerX - midX;
                const toCenterY = centerY - midY;
                
                // Dot product determines if normal points outward or inward
                const dotProduct = normalX * toCenterX + normalY * toCenterY;
                const direction = dotProduct < 0 ? 1 : -1; // Flip if pointing inward
                
                // Apply offset
                const offsetX = normalX * direction * offsetDistance;
                const offsetY = normalY * direction * offsetDistance;
                
                return {
                    start: {
                        x: wall.start.x + offsetX,
                        y: wall.start.y + offsetY
                    },
                    end: {
                        x: wall.end.x + offsetX,
                        y: wall.end.y + offsetY
                    },
                    length: length // Keep original length
                };
            });
            
            return offsetSegments;
        }

        // Position Modal Functions
        let positionFeatureType = null;
        let positionFeatureIndex = null;
        let positionWallIndex = null;
        let cutWallRoomIndex = null;
        let editingCut = null;
function showPositionModal(featureType, featureIndex) {
            const room = getCurrentRoom();
            if (!room) return;
            
            const feature = featureType === 'door' ? room.doors[featureIndex] : room.windows[featureIndex];
            if (!feature) return;
            
            positionFeatureType = featureType;
            positionFeatureIndex = featureIndex;
            positionWallIndex = feature.wallIndex;
            
            const wall = room.walls[feature.wallIndex];
            const wallLength = parseFloat(wall.length);
            const featureWidthFt = feature.width / 12; // Convert inches to feet
            
            // Update modal content
            const icon = featureType === 'door' ? 'üö™' : 'ü™ü';
            const typeName = featureType === 'door' ? 'Door' : 'Window';
            
            document.getElementById('positionModalTitle').textContent = `üìè Edit ${typeName}`;
            document.getElementById('positionCurrentWall').textContent = wall.name;
            document.getElementById('positionWallLength').textContent = `${wallLength.toFixed(1)} ft`;
            document.getElementById('positionFeatureWidth').textContent = `${featureWidthFt.toFixed(2)} ft`;
            document.getElementById('positionCurrentPos').textContent = `${feature.distanceFromLeft.toFixed(2)} ft`;
            
            // Position input
            const posInput = document.getElementById('positionInput');
            const referenceCorner = feature.referenceCorner || 'left'; // Default to left if not set
            document.getElementById('positionReferenceCorner').value = referenceCorner;
            
            // Set distance based on reference corner
            if (referenceCorner === 'right') {
                const distanceFromRight = wallLength - feature.distanceFromLeft - featureWidthFt;
                posInput.value = distanceFromRight.toFixed(2);
                document.getElementById('positionDistanceLabel').textContent = 'Distance to Left Edge from Right (feet):';
            } else {
                posInput.value = feature.distanceFromLeft.toFixed(2);
                document.getElementById('positionDistanceLabel').textContent = 'Distance to Left Edge from Left (feet):';
            }
            posInput.max = wallLength - featureWidthFt;
            
            // Width input
            const widthInput = document.getElementById('positionWidthInput');
            widthInput.value = feature.width;
            
            // Height fields
            const heightFields = document.getElementById('positionHeightFields');
            if (featureType === 'window') {
                heightFields.style.display = 'block';
                const heightInput = document.getElementById('positionHeightInput');
                const floorHeightInput = document.getElementById('positionFloorHeightInput');
                heightInput.value = feature.height || 36; // Default 36" (3.0 feet) if not set
                floorHeightInput.value = (feature.heightFromFloor !== undefined && feature.heightFromFloor !== null) ? feature.heightFromFloor : 3.0; // Default 3.0 ft, allow 0
                document.querySelector('#positionHeightFields label[for="positionHeightInput"]').textContent = 'Window Height (inches)';
                document.getElementById('positionFloorHeightFields').style.display = 'block';
                
                // Show window type selector
                document.getElementById('positionWindowTypeFields').style.display = 'block';
                const windowTypeSelect = document.getElementById('windowTypeSelect');
                windowTypeSelect.value = feature.windowType || 'double-hung';
                
                // Hide door swing fields
                document.getElementById('positionDoorSwingFields').style.display = 'none';
                
            } else if (featureType === 'door') {
                heightFields.style.display = 'block';
                const heightInput = document.getElementById('positionHeightInput');
                heightInput.value = feature.height || 80; // Default 80" (6'8") if not set
                document.querySelector('#positionHeightFields label[for="positionHeightInput"]').textContent = 'Door Height (inches)';
                document.getElementById('positionFloorHeightFields').style.display = 'none';
                
                // Show door swing selector and door type
                const swingFields = document.getElementById('positionDoorSwingFields');
                swingFields.style.display = 'block';
                
                // Set door type selector
                const doorTypeSelect = document.getElementById('doorTypeSelect');
                doorTypeSelect.value = feature.doorType || 'single';
                
                // Get current settings
                const currentHinge = feature.hinge || 'right';
                const currentSwingDir = feature.swingDirection || 'in';
                
                // Hide window type selector
                document.getElementById('positionWindowTypeFields').style.display = 'none';
                
                // Get all buttons
                const hingeLeftBtn = document.getElementById('hingeLeftBtn');
                const hingeRightBtn = document.getElementById('hingeRightBtn');
                const swingInBtn = document.getElementById('swingInBtn');
                const swingOutBtn = document.getElementById('swingOutBtn');
                
                // Highlight hinge side
                if (currentHinge === 'left') {
                    hingeLeftBtn.style.background = '#4CAF50';
                    hingeLeftBtn.style.color = 'white';
                    hingeLeftBtn.style.borderColor = '#4CAF50';
                    hingeRightBtn.style.background = 'white';
                    hingeRightBtn.style.color = '#333';
                    hingeRightBtn.style.borderColor = '#ddd';
                } else {
                    hingeRightBtn.style.background = '#4CAF50';
                    hingeRightBtn.style.color = 'white';
                    hingeRightBtn.style.borderColor = '#4CAF50';
                    hingeLeftBtn.style.background = 'white';
                    hingeLeftBtn.style.color = '#333';
                    hingeLeftBtn.style.borderColor = '#ddd';
                }
                
                // Highlight swing direction
                if (currentSwingDir === 'in') {
                    swingInBtn.style.background = '#4CAF50';
                    swingInBtn.style.color = 'white';
                    swingInBtn.style.borderColor = '#4CAF50';
                    swingOutBtn.style.background = 'white';
                    swingOutBtn.style.color = '#333';
                    swingOutBtn.style.borderColor = '#ddd';
                } else {
                    swingOutBtn.style.background = '#4CAF50';
                    swingOutBtn.style.color = 'white';
                    swingOutBtn.style.borderColor = '#4CAF50';
                    swingInBtn.style.background = 'white';
                    swingInBtn.style.color = '#333';
                    swingInBtn.style.borderColor = '#ddd';
                }
            } else {
                heightFields.style.display = 'none';
            }
            
            const modal = document.getElementById('positionModal');
            modal.style.display = 'flex';
            
            // Focus and select input
            setTimeout(() => {
                posInput.focus();
                posInput.select();
            }, 100);
        }
        
        // Temporary storage for door swing changes
        let tempDoorSwing = null;
        
        function setDoorHinge(side) {
            // Update button styles
            const hingeLeftBtn = document.getElementById('hingeLeftBtn');
            const hingeRightBtn = document.getElementById('hingeRightBtn');
            
            if (side === 'left') {
                hingeLeftBtn.style.background = '#4CAF50';
                hingeLeftBtn.style.color = 'white';
                hingeLeftBtn.style.borderColor = '#4CAF50';
                hingeRightBtn.style.background = 'white';
                hingeRightBtn.style.color = '#333';
                hingeRightBtn.style.borderColor = '#ddd';
            } else {
                hingeRightBtn.style.background = '#4CAF50';
                hingeRightBtn.style.color = 'white';
                hingeRightBtn.style.borderColor = '#4CAF50';
                hingeLeftBtn.style.background = 'white';
                hingeLeftBtn.style.color = '#333';
                hingeLeftBtn.style.borderColor = '#ddd';
            }
            
            // Update the door immediately
            const room = getCurrentRoom();
            if (room && positionFeatureType === 'door' && positionFeatureIndex !== null) {
                const door = room.doors[positionFeatureIndex];
                if (door) {
                    door.hinge = side;
                    redraw2D();
                    if (state.currentView === '3d') {
                        render3D();
                    }
                }
            }
        }
        
        function setDoorSwingDirection(direction) {
            // Update button styles
            const swingInBtn = document.getElementById('swingInBtn');
            const swingOutBtn = document.getElementById('swingOutBtn');
            
            if (direction === 'in') {
                swingInBtn.style.background = '#4CAF50';
                swingInBtn.style.color = 'white';
                swingInBtn.style.borderColor = '#4CAF50';
                swingOutBtn.style.background = 'white';
                swingOutBtn.style.color = '#333';
                swingOutBtn.style.borderColor = '#ddd';
            } else {
                swingOutBtn.style.background = '#4CAF50';
                swingOutBtn.style.color = 'white';
                swingOutBtn.style.borderColor = '#4CAF50';
                swingInBtn.style.background = 'white';
                swingInBtn.style.color = '#333';
                swingInBtn.style.borderColor = '#ddd';
            }
            
            // Update the door immediately
            const room = getCurrentRoom();
            if (room && positionFeatureType === 'door' && positionFeatureIndex !== null) {
                const door = room.doors[positionFeatureIndex];
                if (door) {
                    door.swingDirection = direction;
                    redraw2D();
                    if (state.currentView === '3d') {
                        render3D();
                    }
                }
            }
        }
        
        function confirmPosition() {
            const room = getCurrentRoom();
            if (!room || positionFeatureType === null || positionFeatureIndex === null) return;
            
            const inputDistance = parseFloat(document.getElementById('positionInput').value);
            const referenceCorner = document.getElementById('positionReferenceCorner').value;
            const newWidth = parseFloat(document.getElementById('positionWidthInput').value);
            const wall = room.walls[positionWallIndex];
            const wallLength = parseFloat(wall.length);
            
            // Validate width
            if (isNaN(newWidth) || newWidth < 12 || newWidth > 120) {
                showToast(`‚ùå Width must be between 12 and 120 inches`);
                return;
            }
            
            // Get the feature
            const feature = positionFeatureType === 'door' ? room.doors[positionFeatureIndex] : room.windows[positionFeatureIndex];
            const newWidthFt = newWidth / 12; // Convert inches to feet
            
            // Convert to distance from left if measuring from right
            let edgePosition;
            if (referenceCorner === 'right') {
                edgePosition = wallLength - inputDistance - newWidthFt;
            } else {
                edgePosition = inputDistance;
            }
            
            // Validate that the entire feature fits on the wall
            if (isNaN(edgePosition) || edgePosition < 0 || (edgePosition + newWidthFt) > wallLength) {
                showToast(`‚ùå Position must allow feature to fit (0 to ${(wallLength - newWidthFt).toFixed(1)} ft)`);
                return;
            }
            
            // Update width and reference corner
            feature.width = newWidth;
            feature.referenceCorner = referenceCorner;
            
            // For doors, update height, swing, and door type
            if (positionFeatureType === 'door') {
                const newHeight = parseFloat(document.getElementById('positionHeightInput').value);
                
                if (!isNaN(newHeight) && newHeight >= 12 && newHeight <= 120) {
                    feature.height = newHeight;
                }
                
                // Save door type
                const doorTypeSelect = document.getElementById('doorTypeSelect');
                if (doorTypeSelect) {
                    feature.doorType = doorTypeSelect.value || 'single';
                }
                
                // Save swing direction from tempDoorSwing (set by setDoorSwing function)
                if (tempDoorSwing) {
                    feature.swing = tempDoorSwing;
                } else if (!feature.swing) {
                    feature.swing = 'right'; // Default if not set
                }
                
                // Reset temp swing
                tempDoorSwing = null;
            }
            
            // For windows, update height, floor height, and window type
            if (positionFeatureType === 'window') {
                const newHeight = parseFloat(document.getElementById('positionHeightInput').value);
                const newFloorHeight = parseFloat(document.getElementById('positionFloorHeightInput').value);
                
                if (!isNaN(newHeight) && newHeight >= 12 && newHeight <= 120) {
                    feature.height = newHeight;
                }
                if (!isNaN(newFloorHeight) && newFloorHeight >= 0 && newFloorHeight <= 10) {
                    feature.heightFromFloor = newFloorHeight;
                }
                
                // Save window type
                const windowTypeSelect = document.getElementById('windowTypeSelect');
                if (windowTypeSelect) {
                    feature.windowType = windowTypeSelect.value || 'double-hung';
                }
            }
            
            // Store distance to LEFT EDGE (what user entered)
            feature.distanceFromLeft = edgePosition;
            
            // Calculate CENTER position for rendering (edge + half width)
            const centerPosition = edgePosition + (newWidthFt / 2);
            
            // Recalculate x, y position on wall using CENTER
            const param = centerPosition / wallLength;
            
                // Draw missing wall overlays (dashed red + end ticks) and hide wall line in missing span
                if (wall.missingWalls && wall.missingWalls.length) {
                    const dx0 = wall.end.x - wall.start.x;
                    const dy0 = wall.end.y - wall.start.y;
                    const wLenPx = Math.sqrt(dx0*dx0 + dy0*dy0);
                    if (wLenPx > 0.001) {
                        const ux0 = dx0 / wLenPx;
                        const uy0 = dy0 / wLenPx;
                        const nx0 = -uy0;
                        const ny0 = ux0;
                        const scale0 = 30; // px per ft
                        const tick = 10 / state.zoom;
                        
                        wall.missingWalls.forEach((mw) => {
                            const sPx = mw.startDist * scale0;
                            const ePx = mw.endDist * scale0;

                            // erase underlying wall (creates visible gap even if cut drawing didn't cover)
                            ctx.save();
                            ctx.strokeStyle = '#f5f5f5'; // background
                            ctx.lineWidth = (6 / state.zoom);
                            ctx.beginPath();
                            ctx.moveTo(wall.start.x + ux0*sPx, wall.start.y + uy0*sPx);
                            ctx.lineTo(wall.start.x + ux0*ePx, wall.start.y + uy0*ePx);
                            ctx.stroke();
                            ctx.restore();

                            // dashed marker
                            ctx.save();
                            ctx.setLineDash([8 / state.zoom, 6 / state.zoom]);
                            ctx.strokeStyle = '#c0392b';
                            ctx.lineWidth = (3 / state.zoom);
                            ctx.beginPath();
                            ctx.moveTo(wall.start.x + ux0*sPx, wall.start.y + uy0*sPx);
                            ctx.lineTo(wall.start.x + ux0*ePx, wall.start.y + uy0*ePx);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            // end ticks
                            ctx.beginPath();
                            const sx = wall.start.x + ux0*sPx, sy = wall.start.y + uy0*sPx;
                            const ex = wall.start.x + ux0*ePx, ey = wall.start.y + uy0*ePx;
                            ctx.moveTo(sx - nx0*tick, sy - ny0*tick);
                            ctx.lineTo(sx + nx0*tick, sy + ny0*tick);
                            ctx.moveTo(ex - nx0*tick, ey - ny0*tick);
                            ctx.lineTo(ex + nx0*tick, ey + ny0*tick);
                            ctx.stroke();
                            ctx.restore();
                        });
                    }
                }

                const dx = wall.end.x - wall.start.x;

            const dy = wall.end.y - wall.start.y;
            
            feature.x = wall.start.x + param * dx;
            feature.y = wall.start.y + param * dy;
            
            // Calculate rotation angle to match wall angle
            const angle = Math.atan2(dy, dx);
            feature.rotation = angle * 180 / Math.PI;
            
            const icon = positionFeatureType === 'door' ? 'üö™' : 'ü™ü';
            showToast(`${icon} Updated - ${newWidth}" wide at ${edgePosition.toFixed(2)} ft from left`);
            
            document.getElementById('positionModal').style.display = 'none';
            positionFeatureType = null;
            positionFeatureIndex = null;
            positionWallIndex = null;
            
            redraw2D();
            if (state.currentView === '3d') {
                render3D();
            }
            updateStats();
        }
        
        function cancelPosition() {
            document.getElementById('positionModal').style.display = 'none';
            positionFeatureType = null;
            positionFeatureIndex = null;
            positionWallIndex = null;
        }
        
        function deleteCurrentFeature() {
            const room = getCurrentRoom();
            if (!room || positionFeatureType === null || positionFeatureIndex === null) return;
            
            const icon = positionFeatureType === 'door' ? 'üö™' : 'ü™ü';
            const typeName = positionFeatureType === 'door' ? 'Door' : 'Window';
            
            // Delete the feature
            if (positionFeatureType === 'door') {
                room.doors.splice(positionFeatureIndex, 1);
            } else {
                room.windows.splice(positionFeatureIndex, 1);
            }
            
            showToast(`${icon} ${typeName} deleted`);
            
            // Close modal and reset
            document.getElementById('positionModal').style.display = 'none';
            positionFeatureType = null;
            positionFeatureIndex = null;
            positionWallIndex = null;
            
            redraw2D();
            if (state.currentView === '3d') {
                render3D();
            }
            updateStats();
        }
        
        // Handle Enter key in position modal
        document.addEventListener('DOMContentLoaded', function() {
            const positionInput = document.getElementById('positionInput');
            if (positionInput) {
                positionInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        confirmPosition();
                    } else if (e.key === 'Escape') {
                        cancelPosition();
                    }
                });
            }
            
            // Handle reference corner change for position modal
            const positionReferenceCorner = document.getElementById('positionReferenceCorner');
            if (positionReferenceCorner) {
                positionReferenceCorner.addEventListener('change', function(e) {
                    const label = document.getElementById('positionDistanceLabel');
                    if (e.target.value === 'right') {
                        label.textContent = 'Distance to Left Edge from Right (feet):';
                    } else {
                        label.textContent = 'Distance to Left Edge from Left (feet):';
                    }
                });
            }
            
            // Handle reference corner change for missing wall modal
            const missingWallReference = document.getElementById('missingWallReference');
            if (missingWallReference) {
                missingWallReference.addEventListener('change', function(e) {
                    const startLabel = document.getElementById('missingWallStartLabel');
                    const endLabel = document.getElementById('missingWallEndLabel');
                    if (e.target.value === 'right') {
                        startLabel.textContent = 'Start (ft from right corner)';
                        endLabel.textContent = 'End (ft from right corner)';
                    } else {
                        startLabel.textContent = 'Start (ft from left corner)';
                        endLabel.textContent = 'End (ft from left corner)';
                    }
                });
            }
            
            // Handle Enter key in filename modal
            const filenameInput = document.getElementById('filenameInput');
            if (filenameInput) {
                filenameInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        confirmFilename();
                    } else if (e.key === 'Escape') {
                        cancelFilename();
                    }
                });
            }
            
            // Apply Measurements button - iOS-compatible
            const applyMeasurementsBtn = document.getElementById('applyMeasurementsBtn');
            if (applyMeasurementsBtn) {
                applyMeasurementsBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    applyQuickEntry();
                });
                console.log('‚úÖ Apply Measurements button listener attached');
            }
            
            // Opening button - iOS-compatible
            const openingBtn = document.getElementById('openingBtn');
            if (openingBtn) {
                openingBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('üîì Opening button clicked via listener');
                    selectFeature('opening', e);
                });
                console.log('‚úÖ Opening button listener attached');
            }
            
            // Door button - iOS-compatible (backup for onclick)
            const doorBtn = document.getElementById('doorBtn');
            if (doorBtn) {
                doorBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('üö™ Door button clicked via listener');
                    selectFeature('door', e);
                });
                console.log('‚úÖ Door button listener attached');
            }
            
            // Window button - iOS-compatible (backup for onclick)
            const windowBtn = document.getElementById('windowBtn');
            if (windowBtn) {
                windowBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('ü™ü Window button clicked via listener');
                    selectFeature('window', e);
                });
                console.log('‚úÖ Window button listener attached');
            }
            
            // TESTING: Using inline onclick for now
            /*
            // Feature buttons - iOS PWA needs BOTH touch AND click events
            function setupFeatureButton(buttonId, featureType, label) {
                const btn = document.getElementById(buttonId);
                if (!btn) {
                    console.error(`‚ùå Button not found: ${buttonId}`);
                    alert(`ERROR: ${buttonId} not found!`);
                    return;
                }
                
                const handler = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // SUPER VISIBLE DEBUG - Flash the background
                    document.body.style.backgroundColor = '#00FF00';
                    setTimeout(() => { document.body.style.backgroundColor = ''; }, 200);
                    
                    console.log(`üëÜ ${label} button activated`);
                    alert(`${label} button tapped!`);
                    
                    selectFeature(featureType, e);
                };
                
                // Add BOTH event types for iOS PWA
                btn.addEventListener('touchstart', handler, { passive: false });
                btn.addEventListener('click', handler);
                
                console.log(`‚úÖ ${label} button listeners attached`);
                alert(`‚úÖ ${label} button ready`);
            }
            
            // Setup all feature buttons
            setTimeout(function() {
                setupFeatureButton('doorBtn', 'door', 'Door');
                setupFeatureButton('windowBtn', 'window', 'Window');
                setupFeatureButton('openingBtn', 'missing-wall', 'Opening');
                setupFeatureButton('waterBtn', 'water-damage', 'Water');
                setupFeatureButton('fireBtn', 'fire-damage', 'Fire');
            }, 1000); // Wait 1 second to make sure DOM is ready
            */
        });

        function updateRoomList() {
            const list = document.getElementById('roomList');
            
            if (!list) {
                console.error('ERROR: Room list element not found!');
                return;
            }
            
            list.innerHTML = '';
            
            if (state.rooms.length === 0) return;
            
            // Filter to show only rooms on current level
            const roomsOnCurrentLevel = state.rooms.filter(r => r.level === state.currentLevel);
            
            if (roomsOnCurrentLevel.length === 0) {
                list.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">No rooms on this level yet.<br><br>Click "+ Add Room" to create one.</div>';
                return;
            }
            
            roomsOnCurrentLevel.forEach((room) => {
                const i = state.rooms.indexOf(room);  // Get index in full rooms array
                
                const div = document.createElement('div');
                div.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    padding: 10px 15px;
                    background: ${i === state.currentRoomIndex ? '#4CAF50' : 'white'};
                    color: ${i === state.currentRoomIndex ? 'white' : '#333'};
                    border: 2px solid ${i === state.currentRoomIndex ? '#4CAF50' : '#999'};
                    border-radius: 4px 4px 0 0;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: ${i === state.currentRoomIndex ? '700' : '500'};
                    white-space: nowrap;
                    min-width: 120px;
                `;
                
                // Create room name - clicking it activates edit mode
                const nameSpan = document.createElement('span');
                nameSpan.textContent = room.name;
                nameSpan.style.cssText = 'flex: 1;';
                
                // Create delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '√ó';
                deleteBtn.style.cssText = 'padding: 2px 6px; font-size: 16px; background: rgba(244,67,54,0.2); color: #f44336; border: none; border-radius: 3px; cursor: pointer; font-weight: bold;';
                deleteBtn.title = 'Delete room';
                deleteBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    deleteRoom(i);
                });
                
                div.appendChild(nameSpan);
                div.appendChild(deleteBtn);
                
                // Click on the tab to switch rooms AND activate edit mode
                div.addEventListener('click', function() {
                    console.log('Switching to room', i, 'and activating edit mode');
                    switchRoom(i);
                    // Activate edit mode so handles show
                    if (!state.roomEditMode) {
                        enterEditMode();
                    }
                });
                
                list.appendChild(div);
            });
        }

        function editRoomName(index) {
            // This function now calls the modal version
            showEditNameModal(index);
        }
        
        function cutWallPortion(index) {
            const room = state.rooms[index];
            
            // Switch to this room
            state.currentRoomIndex = index;
            updateRoomList();
            
            // Store room index for modal
            cutWallRoomIndex = index;
            editingCut = null;
            document.getElementById('cutWallModalTitle').textContent = '‚úÇÔ∏è Cut Portion of Wall';
            document.getElementById('cutWallDeleteBtn').style.display = 'none';
            document.getElementById('cutWallConfirmBtn').textContent = '‚úÇÔ∏è Cut Wall';
// Update modal with room name
            document.getElementById('cutWallRoomName').textContent = room.name;
            
            // Populate wall dropdown
            const select = document.getElementById('cutWallSelect');
            select.innerHTML = '<option value="">Choose a wall...</option>';
            room.walls.forEach((wall, idx) => {
                const option = document.createElement('option');
                option.value = idx;
                option.textContent = `${wall.name} (${wall.length} ft)`;
                select.appendChild(option);
            });
            
            // Show modal
            const modal = document.getElementById('cutWallModal');
            modal.style.display = 'block';
            
            // Focus select
            setTimeout(() => {
                select.focus();
            }, 100);
        }

        // Find if a click is on a wall cut (gap) in the current room.
        function findClickedCut(room, x, y) {
            if (!room || !room.walls) return null;
            const SCALE = 30; // px per ft
            for (let wallIdx = 0; wallIdx < room.walls.length; wallIdx++) {
                const wall = room.walls[wallIdx];
                if (!wall.cuts || wall.cuts.length === 0) continue;

                // Near the wall line? - INCREASED from 22 to 50 pixels for easier clicking
                const dist = distanceToLineSegment(x, y, wall.start.x, wall.start.y, wall.end.x, wall.end.y);
                if (dist > 50) continue; // must click close to wall

                // Project click onto wall to get distance from start (feet)
                const A = x - wall.start.x;
                const B = y - wall.start.y;
                const C = wall.end.x - wall.start.x;
                const D = wall.end.y - wall.start.y;
                const lenSq = C * C + D * D;
                if (lenSq === 0) continue;

                let param = (A * C + B * D) / lenSq;
                param = Math.max(0, Math.min(1, param));
                const projX = wall.start.x + param * C;
                const projY = wall.start.y + param * D;

                const distFromStartPx = Math.sqrt((projX - wall.start.x) ** 2 + (projY - wall.start.y) ** 2);
                const distFromStartFt = distFromStartPx / SCALE;

                for (let cutIdx = 0; cutIdx < wall.cuts.length; cutIdx++) {
                    const cut = wall.cuts[cutIdx];
                    // INCREASED tolerance from 0.05 to 0.5 feet for easier clicking
                    if (distFromStartFt >= cut.startDist - 0.5 && distFromStartFt <= cut.endDist + 0.5) {
                        console.log(`üéØ Found opening at wall ${wallIdx}, cut ${cutIdx}, distance: ${distFromStartFt.toFixed(2)} ft`);
                        return { wallIdx, cutIdx };
                    }
                }
            }
            return null;
        }

        function showCutWallEditModal(roomIndex, wallIdx, cutIdx) {
            const room = state.rooms[roomIndex];
            if (!room) return;
            const wall = room.walls[wallIdx];
            if (!wall || !wall.cuts || !wall.cuts[cutIdx]) return;

            // Switch to this room (keep behavior consistent with cutting)
            state.currentRoomIndex = roomIndex;
            updateRoomList();

            cutWallRoomIndex = roomIndex;
            editingCut = { roomIndex, wallIdx, cutIdx };

            document.getElementById('cutWallModalTitle').textContent = '‚úÇÔ∏è Edit Wall Cut';
            document.getElementById('cutWallRoomName').textContent = room.name;

            // Populate walls
            const select = document.getElementById('cutWallSelect');
            select.innerHTML = '<option value="">Choose a wall...</option>';
            room.walls.forEach((w, idx) => {
                const option = document.createElement('option');
                option.value = idx;
                option.textContent = `${w.name} (${w.length} ft)`;
                select.appendChild(option);
            });
            select.value = String(wallIdx);

            // Prefill distances
            const cut = wall.cuts[cutIdx];
            document.getElementById('cutWallStart').value = cut.startDist;
            document.getElementById('cutWallEnd').value = cut.endDist;

            // Show modal + buttons
            document.getElementById('cutWallDeleteBtn').style.display = 'inline-block';
            document.getElementById('cutWallConfirmBtn').textContent = '‚úÖ Update Cut';

            const modal = document.getElementById('cutWallModal');
            modal.style.display = 'block';

            setTimeout(() => document.getElementById('cutWallStart').focus(), 50);
        }

        function deleteCurrentCutWall() {
            if (!editingCut) return;
            const { roomIndex, wallIdx, cutIdx } = editingCut;
            const room = state.rooms[roomIndex];
            if (!room) return;
            const wall = room.walls[wallIdx];
            if (!wall || !wall.cuts || !wall.cuts[cutIdx]) return;

            saveStateForUndo();
            wall.cuts.splice(cutIdx, 1);
            if (wall.cuts.length === 0) delete wall.cuts;

            document.getElementById('cutWallModal').style.display = 'none';
            editingCut = null;
            cutWallRoomIndex = null;

            redraw2D();
            if (state.currentView === '3d') render3D();
            updateStats();
            showToast('üóëÔ∏è Cut removed');
        }

        
        
        // =========================
        // Missing Wall (Xactimate-style) - add/edit/delete
        // =========================
        let editingMissing = null;
        let missingWallRoomIndex = null;

        function getWallOpenings(wall) {
            const openings = [];
            if (wall.cuts && wall.cuts.length) {
                wall.cuts.forEach((c, idx) => openings.push({ 
                    type: 'cut', 
                    idx, 
                    startDist: Number(c.startDist), 
                    endDist: Number(c.endDist),
                    height: Number(c.height) || 3,
                    floorDistance: Number(c.floorDistance) || 0
                }));
            }
            if (wall.missingWalls && wall.missingWalls.length) {
                wall.missingWalls.forEach((mw, idx) => openings.push({ 
                    type: 'missing', 
                    idx, 
                    startDist: Number(mw.startDist), 
                    endDist: Number(mw.endDist),
                    height: Number(mw.height) || 3,
                    floorDistance: Number(mw.floorDistance) || 0
                }));
            }
            return openings.filter(o => isFinite(o.startDist) && isFinite(o.endDist) && o.endDist > o.startDist).sort((a,b)=>a.startDist-b.startDist);
        }

        function showMissingWallModal() {
            const room = getCurrentRoom();
            if (!room || !room.walls || room.walls.length === 0) { showToast('‚ùå Create floor plan first'); return; }

            missingWallRoomIndex = state.currentRoomIndex;
            editingMissing = null;

            document.getElementById('missingWallModalTitle').textContent = 'üß± Add Missing Wall';
            document.getElementById('missingWallRoomName').textContent = room.name;

            const select = document.getElementById('missingWallSelect');
            select.innerHTML = '';
            room.walls.forEach((w, idx) => {
                const opt = document.createElement('option');
                opt.value = String(idx);
                opt.textContent = `${w.name} (${w.length} ft)`;
                select.appendChild(opt);
            });

            // Preselect hovered/selected wall if available
            if (state.selectedWall !== null && state.selectedWall !== undefined) select.value = String(state.selectedWall);

            document.getElementById('missingWallStart').value = 0;
            document.getElementById('missingWallEnd').value = 1;
            document.getElementById('missingWallHeight').value = 3;
            document.getElementById('missingWallFloorDist').value = 0;
            document.getElementById('missingWallReference').value = 'left';
            document.getElementById('missingWallStartLabel').textContent = 'Start (ft from left corner)';
            document.getElementById('missingWallEndLabel').textContent = 'End (ft from left corner)';

            document.getElementById('missingWallDeleteBtn').style.display = 'none';
            document.getElementById('missingWallConfirmBtn').textContent = '‚úÖ Save';

            document.getElementById('missingWallModal').style.display = 'flex';
            setTimeout(() => document.getElementById('missingWallStart').focus(), 50);
        }

        function showMissingWallEditModal(roomIndex, wallIdx, missIdx) {
            const room = state.rooms[roomIndex];
            if (!room) return;
            const wall = room.walls[wallIdx];
            if (!wall || !wall.missingWalls || !wall.missingWalls[missIdx]) return;

            state.currentRoomIndex = roomIndex;
            updateRoomList();

            missingWallRoomIndex = roomIndex;
            editingMissing = { roomIndex, wallIdx, missIdx };

            document.getElementById('missingWallModalTitle').textContent = 'üß± Edit Missing Wall';
            document.getElementById('missingWallRoomName').textContent = room.name;

            const select = document.getElementById('missingWallSelect');
            select.innerHTML = '';
            room.walls.forEach((w, idx) => {
                const opt = document.createElement('option');
                opt.value = String(idx);
                opt.textContent = `${w.name} (${w.length} ft)`;
                select.appendChild(opt);
            });
            select.value = String(wallIdx);

            const mw = wall.missingWalls[missIdx];
            const referenceCorner = mw.referenceCorner || 'left';
            const wallLength = parseFloat(wall.length);
            
            document.getElementById('missingWallReference').value = referenceCorner;
            
            if (referenceCorner === 'right') {
                // Convert from left-based storage to right-based display
                const startFromRight = wallLength - mw.endDist;
                const endFromRight = wallLength - mw.startDist;
                document.getElementById('missingWallStart').value = startFromRight;
                document.getElementById('missingWallEnd').value = endFromRight;
                document.getElementById('missingWallStartLabel').textContent = 'Start (ft from right corner)';
                document.getElementById('missingWallEndLabel').textContent = 'End (ft from right corner)';
            } else {
                document.getElementById('missingWallStart').value = mw.startDist;
                document.getElementById('missingWallEnd').value = mw.endDist;
                document.getElementById('missingWallStartLabel').textContent = 'Start (ft from left corner)';
                document.getElementById('missingWallEndLabel').textContent = 'End (ft from left corner)';
            }
            
            document.getElementById('missingWallHeight').value = mw.height || 3;
            document.getElementById('missingWallFloorDist').value = mw.floorDistance || 0;

            document.getElementById('missingWallDeleteBtn').style.display = 'inline-block';
            document.getElementById('missingWallConfirmBtn').textContent = '‚úÖ Update';

            document.getElementById('missingWallModal').style.display = 'flex';
            setTimeout(() => document.getElementById('missingWallStart').focus(), 50);
        }

        function cancelMissingWall() {
            document.getElementById('missingWallModal').style.display = 'none';
            editingMissing = null;
            missingWallRoomIndex = null;
        }

        function deleteCurrentMissingWall() {
            if (!editingMissing) return;
            const { roomIndex, wallIdx, missIdx } = editingMissing;
            const room = state.rooms[roomIndex];
            if (!room) return;
            const wall = room.walls[wallIdx];
            if (!wall || !wall.missingWalls || !wall.missingWalls[missIdx]) return;

            saveStateForUndo();
            wall.missingWalls.splice(missIdx, 1);
            if (wall.missingWalls.length === 0) delete wall.missingWalls;

            cancelMissingWall();
            redraw2D();
            if (state.currentView === '3d') render3D();
            updateStats();
            showToast('üóëÔ∏è Missing wall removed');
        }

        function confirmMissingWall() {
            if (missingWallRoomIndex === null) { showToast('‚ùå No room selected'); return; }
            const room = state.rooms[missingWallRoomIndex];
            if (!room) return;

            const wallIdx = parseInt(document.getElementById('missingWallSelect').value, 10);
            const inputStart = parseFloat(document.getElementById('missingWallStart').value);
            const inputEnd = parseFloat(document.getElementById('missingWallEnd').value);
            const referenceCorner = document.getElementById('missingWallReference').value;
            const height = parseFloat(document.getElementById('missingWallHeight').value);
            const floorDistance = parseFloat(document.getElementById('missingWallFloorDist').value);

            if (!isFinite(wallIdx) || wallIdx < 0 || wallIdx >= room.walls.length) { showToast('‚ùå Select a wall'); return; }
            if (!isFinite(inputStart) || !isFinite(inputEnd) || inputStart < 0 || inputEnd <= inputStart) { showToast('‚ùå Invalid dimensions'); return; }
            if (!isFinite(height) || height <= 0) { showToast('‚ùå Invalid height'); return; }
            if (!isFinite(floorDistance) || floorDistance < 0) { showToast('‚ùå Invalid floor distance'); return; }

            const wall = room.walls[wallIdx];
            const wallLen = parseFloat(wall.length);
            
            // Convert to left-based storage if measuring from right
            let startDist, endDist;
            if (referenceCorner === 'right') {
                startDist = wallLen - inputEnd;
                endDist = wallLen - inputStart;
            } else {
                startDist = inputStart;
                endDist = inputEnd;
            }
            
            if (endDist > wallLen + 1e-6) { showToast(`‚ùå End exceeds wall length (${wallLen} ft)`); return; }

            saveStateForUndo();

            if (editingMissing && editingMissing.roomIndex === missingWallRoomIndex) {
                const { wallIdx: oldWallIdx, missIdx } = editingMissing;
                const oldWall = room.walls[oldWallIdx];
                const item = oldWall.missingWalls[missIdx];
                if (oldWallIdx !== wallIdx) {
                    oldWall.missingWalls.splice(missIdx, 1);
                    if (oldWall.missingWalls.length === 0) delete oldWall.missingWalls;
                    if (!wall.missingWalls) wall.missingWalls = [];
                    wall.missingWalls.push({ startDist, endDist, height, floorDistance, referenceCorner, name: item.name || `Missing ${Date.now()}` });
                } else {
                    item.startDist = startDist;
                    item.endDist = endDist;
                    item.height = height;
                    item.floorDistance = floorDistance;
                    item.referenceCorner = referenceCorner;
                }
            } else {
                if (!wall.missingWalls) wall.missingWalls = [];
                wall.missingWalls.push({ startDist, endDist, height, floorDistance, referenceCorner, name: `Missing ${wall.missingWalls.length + 1}` });
            }

            cancelMissingWall();
            redraw2D();
            if (state.currentView === '3d') render3D();
            updateStats();
            showToast('üß± Missing wall saved');
        }

        function findMissingAtPoint(room, x, y) {
            if (!room || !room.walls) return null;
            const SCALE = 30; // px per ft
            for (let wallIdx = 0; wallIdx < room.walls.length; wallIdx++) {
                const wall = room.walls[wallIdx];
                if (!wall.missingWalls || wall.missingWalls.length === 0) continue;

                const dist = distanceToLineSegment(x, y, wall.start.x, wall.start.y, wall.end.x, wall.end.y);
                if (dist > 22) continue;

                const A = x - wall.start.x;
                const B = y - wall.start.y;
                const C = wall.end.x - wall.start.x;
                const D = wall.end.y - wall.start.y;
                const lenSq = C*C + D*D;
                if (lenSq === 0) continue;
                let param = (A*C + B*D) / lenSq;
                param = Math.max(0, Math.min(1, param));
                const projX = wall.start.x + param * C;
                const projY = wall.start.y + param * D;
                const distFromStartPx = Math.sqrt((projX - wall.start.x)**2 + (projY - wall.start.y)**2);
                const distFromStartFt = distFromStartPx / SCALE;

                for (let missIdx=0; missIdx<wall.missingWalls.length; missIdx++) {
                    const mw = wall.missingWalls[missIdx];
                    if (distFromStartFt >= mw.startDist - 0.05 && distFromStartFt <= mw.endDist + 0.05) {
                        return { wallIdx, missIdx };
                    }
                }
            }
            return null;
        }

function confirmCutWall() {
            console.log('=== confirmCutWall called ===');
            console.log('cutWallRoomIndex:', cutWallRoomIndex);
            
            if (cutWallRoomIndex === null) {
                console.log('ERROR: cutWallRoomIndex is null');
                return;
            }
            
            const room = state.rooms[cutWallRoomIndex];
            console.log('Room:', room.name);
            
            const wallIdx = parseInt(document.getElementById('cutWallSelect').value);
            const startDist = parseFloat(document.getElementById('cutWallStart').value);
            const endDist = parseFloat(document.getElementById('cutWallEnd').value);
            
            console.log('Wall Index:', wallIdx);
            console.log('Start Distance:', startDist);
            console.log('End Distance:', endDist);
            
            if (isNaN(wallIdx) || wallIdx < 0 || wallIdx >= room.walls.length) {
                console.log('ERROR: Invalid wall index');
                showToast('‚ùå Please select a wall');
                return;
            }
            
            if (isNaN(startDist) || isNaN(endDist) || startDist < 0 || endDist <= startDist) {
                console.log('ERROR: Invalid dimensions');
                showToast('‚ùå Invalid dimensions (End must be greater than Start)');
                return;
            }
            
            const wall = room.walls[wallIdx];
            const wallLength = parseFloat(wall.length);
            
            console.log('Wall:', wall.name, 'Length:', wallLength);
            
            if (endDist > wallLength) {
                console.log('ERROR: End distance exceeds wall length');
                showToast(`‚ùå End distance exceeds wall length (${wallLength} ft)`);
                return;
            }
            
            const cutLength = endDist - startDist;
            console.log('Cut Length:', cutLength);
            
            // Save state for undo
            saveStateForUndo();
            
            // Create or update cut
            if (editingCut && editingCut.roomIndex === cutWallRoomIndex) {
                // Updating an existing cut
                const { wallIdx: oldWallIdx, cutIdx } = editingCut;
                const oldWall = room.walls[oldWallIdx];
                if (oldWall && oldWall.cuts && oldWall.cuts[cutIdx]) {
                    // If user changed wall selection, move cut to new wall
                    if (oldWallIdx !== wallIdx) {
                        // Remove from old
                        const moved = oldWall.cuts.splice(cutIdx, 1)[0];
                        if (oldWall.cuts.length === 0) delete oldWall.cuts;

                        // Add to new
                        if (!wall.cuts) wall.cuts = [];
                        moved.startDist = startDist;
                        moved.endDist = endDist;
                        wall.cuts.push(moved);
                    } else {
                        // Update in place
                        oldWall.cuts[cutIdx].startDist = startDist;
                        oldWall.cuts[cutIdx].endDist = endDist;
                    }
                }
            } else {
                // Adding a new cut
                if (!wall.cuts) wall.cuts = [];
                wall.cuts.push({
                    startDist: startDist,
                    endDist: endDist,
                    name: `Cut ${wall.cuts.length + 1}`
                });
            }

            
            console.log('Added cut to wall:', wall.cuts);
            
            showToast(`‚úÇÔ∏è Cut ${cutLength.toFixed(1)} ft from ${wall.name} (${startDist.toFixed(1)}-${endDist.toFixed(1)} ft)`);
            
            // Close modal
            document.getElementById('cutWallModal').style.display = 'none';
            cutWallRoomIndex = null;
            editingCut = null;
            document.getElementById('cutWallDeleteBtn').style.display = 'none';
            document.getElementById('cutWallConfirmBtn').textContent = '‚úÇÔ∏è Cut Wall';
            document.getElementById('cutWallModalTitle').textContent = '‚úÇÔ∏è Cut Portion of Wall';
            
            console.log('Redrawing...');
            redraw2D();
            if (state.currentView === '3d') {
                render3D();
            }
            updateStats();
            console.log('=== confirmCutWall complete ===');
        }
        
        function cancelCutWall() {
            document.getElementById('cutWallModal').style.display = 'none';
            cutWallRoomIndex = null;
            editingCut = null;
            document.getElementById('cutWallDeleteBtn').style.display = 'none';
            document.getElementById('cutWallConfirmBtn').textContent = '‚úÇÔ∏è Cut Wall';
            document.getElementById('cutWallModalTitle').textContent = '‚úÇÔ∏è Cut Portion of Wall';
        }
        
        function recalculateFloorPlan(room) {
            // Recalculate floor points based on walls
            const points = [];
            let x = 0;
            let y = 0;
            let angle = 0;
            
            room.walls.forEach((wall, idx) => {
                const len = parseFloat(wall.length) * 30; // Convert to pixels
                
                // Set wall start and end points
                wall.start = {x, y};
                
                // Calculate end point
                const endX = x + len * Math.cos(angle);
                const endY = y + len * Math.sin(angle);
                wall.end = {x: endX, y: endY};
                
                // Add point
                points.push({x, y});
                
                // Move to next position
                x = endX;
                y = endY;
                
                // Turn 90 degrees for next wall (interior angle)
                angle += Math.PI / 2;
            });
            
            room.floorPoints = points;
        }

        function editRoomMeasurements(index) {
            const room = state.rooms[index];
            const wasCurrentRoom = index === state.currentRoomIndex;
            
            // Switch to this room
            state.currentRoomIndex = index;
            updateRoomList();
            
            // Pre-populate the Quick Entry fields with current measurements
            if (room.walls.length > 0) {
                // Set wall count
                const wallCount = room.walls.length;
                document.getElementById('wallCount').value = wallCount;
                
                // Generate input fields
                generateWallInputs();
                
                // Wait a moment for fields to be created, then populate them
                setTimeout(() => {
                    room.walls.forEach((wall, i) => {
                        const input = document.getElementById(`wall${i+1}Length`);
                        if (input) {
                            input.value = wall.length;
                        }
                    });
                }, 50);
                
                // Populate ceiling height
                if (room.ceilingHeight) {
                    document.getElementById('ceilingHeight').value = room.ceilingHeight;
                }
                
                // Populate wall thickness
                if (room.wallThickness) {
                    document.getElementById('wallThickness').value = room.wallThickness;
                }
                
                showToast('üìè Adjust measurements and click "Apply Measurements"');
            } else {
                showToast('üìè Enter measurements in Quick Entry panel and click "Apply Measurements"');
            }
            
            // Room stays visible - no clearing!
            redraw2D();
        }

        // Calculate perpendicular distance from point to line segment
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) {
                param = dot / lenSq;
            }
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getCurrentRoom() {
            return state.rooms[state.currentRoomIndex] || null;
        }
        
        function updateRoomWallsFromPoints(room) {
            // CRITICAL: Save old walls BEFORE wiping the array
            const oldWalls = room.walls || [];
            
            // Recalculate walls from current floor points
            room.walls = [];
            
            for (let i = 0; i < room.floorPoints.length; i++) {
                const start = room.floorPoints[i];
                const end = room.floorPoints[(i + 1) % room.floorPoints.length];
                
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const lengthPixels = Math.sqrt(dx * dx + dy * dy);
                const lengthFeet = lengthPixels / 30;
                
                // Preserve cuts and missing walls from old wall at this index
                const preservedCuts = oldWalls[i]?.cuts || [];
                const preservedMissingWalls = oldWalls[i]?.missingWalls || [];
                
                room.walls.push({
                    name: `Wall ${i + 1}`,
                    length: lengthFeet.toFixed(2),
                    start: { x: start.x, y: start.y },
                    end: { x: end.x, y: end.y },
                    cuts: preservedCuts,
                    missingWalls: preservedMissingWalls
                });
            }
        }

        function createRoomInGap(originalRoom, dragHandle, preview) {
            // Create a new room filling the gap between original wall and preview wall
            const edgeIndex = preview.edgeIndex;
            const p1Index = edgeIndex;
            const p2Index = (edgeIndex + 1) % originalRoom.floorPoints.length;
            
            // CRITICAL: Create NEW point objects with SAME coordinates
            // This gives perfect alignment but allows independent movement
            const sharedP1 = { 
                x: originalRoom.floorPoints[p1Index].x, 
                y: originalRoom.floorPoints[p1Index].y 
            };
            const sharedP2 = { 
                x: originalRoom.floorPoints[p2Index].x, 
                y: originalRoom.floorPoints[p2Index].y 
            };
            
            // Get preview wall points (these are the far wall of new room)
            const newP1 = { x: preview.p1.x, y: preview.p1.y };
            const newP2 = { x: preview.p2.x, y: preview.p2.y };
            
            // Create new room with 4 corners
            // IMPORTANT: Each room has its own point objects (independent)
            const newRoom = {
                name: `Room ${state.rooms.length + 1}`,
                level: originalRoom.level || state.currentLevel,
                floorPoints: [
                    sharedP1,       // New object with same coordinates
                    sharedP2,       // New object with same coordinates
                    newP2,          // New point (far wall)
                    newP1           // New point (far wall)
                ],
                walls: [],
                ceilingHeight: originalRoom.ceilingHeight || 8.0,
                wallThickness: originalRoom.wallThickness || 4,
                doors: [],
                windows: [],
                damageMarkers: [],
                openings: [],
                positionX: 0,
                positionZ: 0
            };
            
            // Generate walls for both rooms
            updateRoomWallsFromPoints(newRoom);
            updateRoomWallsFromPoints(originalRoom);
            
            // Add new room to state
            state.rooms.push(newRoom);
            
            // Switch to original room (keep editing it)
            state.currentRoomIndex = state.rooms.indexOf(originalRoom);
            updateRoomList();
            updateLevelButtons();
            
            showToast(`‚úÖ New room created! ${preview.distance.toFixed(1)}' deep`, 3000);
        }

        // Convert decimal feet to feet-inches format (e.g., 9.92 -> "9' 11\"")
        function toFeetInches(decimalFeet) {
            const feet = Math.floor(decimalFeet);
            const inches = Math.round((decimalFeet - feet) * 12);
            
            if (inches === 0) {
                return `${feet}'`;
            } else if (inches === 12) {
                return `${feet + 1}'`;
            } else {
                return `${feet}' ${inches}"`;
            }
        }

        function switch2D() {
            state.currentView = '2d';
            document.getElementById('canvasArea').classList.remove('view-3d');
            document.querySelectorAll('.view-btn')[0].classList.add('active');
            document.querySelectorAll('.view-btn')[1].classList.remove('active');
            
            // Hide Reset Camera button in 2D view
            const resetBtn = document.getElementById('resetCameraBtn');
            if (resetBtn) resetBtn.style.display = 'none';
        }

        function switch3D() {
            console.log('=== Switching to 3D view ===');
            console.log('Current rooms:', state.rooms.length);
            
            state.currentView = '3d';
            document.getElementById('canvasArea').classList.add('view-3d');
            document.querySelectorAll('.view-btn')[0].classList.remove('active');
            document.querySelectorAll('.view-btn')[1].classList.add('active');
            
            // Show Reset Camera button in 3D view
            const resetBtn = document.getElementById('resetCameraBtn');
            if (resetBtn) resetBtn.style.display = 'inline-block';
            
            // CALCULATE CENTER IMMEDIATELY before rendering
            const totalRooms = state.rooms.filter(r => r.floorPoints && r.floorPoints.length >= 3).length;
            
            if (totalRooms === 1) {
                const room = state.rooms.find(r => r.floorPoints && r.floorPoints.length >= 3);
                if (room) {
                    const idx = state.rooms.indexOf(room);
                    const roomSpacing = 30;
                    
                    // Use EXACT same offset logic as rendering
                    const offsetX = (room.positionX !== undefined && room.positionX !== null) ? room.positionX : (idx * roomSpacing);
                    const offsetZ = (room.positionZ !== undefined && room.positionZ !== null) ? room.positionZ : 0;
                    
                    // Calculate room center
                    const centerXpx = room.floorPoints.reduce((sum, p) => sum + p.x, 0) / room.floorPoints.length;
                    const centerZpx = room.floorPoints.reduce((sum, p) => sum + p.y, 0) / room.floorPoints.length;
                    
                    const centerX = -(centerXpx / 30 + offsetX);
                    const centerZ = -(centerZpx / 30 + offsetZ);
                    const centerY = room.ceilingHeight * 0.3048 / 2;
                    
                    console.log('üéØ PRE-RENDER CENTER (1 room):', centerX.toFixed(1), centerY.toFixed(1), centerZ.toFixed(1));
                    
                    // SET TARGET IMMEDIATELY
                    if (window.setOrbitTarget) {
                        window.setOrbitTarget(centerX, centerY, centerZ);
                    }
                    
                    // RESET CAMERA ANGLES IMMEDIATELY
                    if (window.resetCameraView) {
                        window.resetCameraView();
                    }
                }
            } else if (totalRooms > 1) {
                // Calculate ACTUAL bounding box of all rooms
                let minX = Infinity, maxX = -Infinity;
                let minZ = Infinity, maxZ = -Infinity;
                let totalHeight = 0;
                
                state.rooms.forEach((room, idx) => {
                    if (room.floorPoints.length < 3) return;
                    
                    const roomSpacing = 30;
                    const offsetX = (room.positionX !== undefined && room.positionX !== null) ? room.positionX : (idx * roomSpacing);
                    const offsetZ = (room.positionZ !== undefined && room.positionZ !== null) ? room.positionZ : 0;
                    
                    room.floorPoints.forEach(p => {
                        const x = -(p.x / 30 + offsetX);
                        const z = -(p.y / 30 + offsetZ);
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minZ = Math.min(minZ, z);
                        maxZ = Math.max(maxZ, z);
                    });
                    
                    totalHeight += room.ceilingHeight;
                });
                
                const centerX = (minX + maxX) / 2;
                const centerZ = (minZ + maxZ) / 2;
                const avgHeight = totalHeight / totalRooms;
                const centerY = avgHeight * 0.3048 / 2;
                
                console.log('üéØ PRE-RENDER CENTER (multi-room):');
                console.log('  Bounds: X[', minX.toFixed(1), 'to', maxX.toFixed(1), '], Z[', minZ.toFixed(1), 'to', maxZ.toFixed(1), ']');
                console.log('  Center:', centerX.toFixed(1), centerY.toFixed(1), centerZ.toFixed(1));
                
                if (window.setOrbitTarget) {
                    window.setOrbitTarget(centerX, centerY, centerZ);
                }
                if (window.resetCameraView) {
                    window.resetCameraView();
                }
            }
            
            console.log('Calling render3D()...');
            render3D();
            console.log('=== 3D view switch complete ===');
        }
        
        function resetCamera() {
            if (state.currentView !== '3d') {
                showToast('‚ö†Ô∏è Switch to 3D view first');
                return;
            }
            
            // Reset camera by recalculating orbit target
            const totalRooms = state.rooms.filter(r => r.floorPoints && r.floorPoints.length >= 3).length;
            const roomSpacing = 30;
            
            if (totalRooms > 1) {
                const totalWidth = (totalRooms - 1) * roomSpacing;
                const centerX = totalWidth / 2;
                if (window.setOrbitTarget) {
                    window.setOrbitTarget(centerX, 4, 0);
                }
            } else if (totalRooms === 1) {
                const room = state.rooms.find(r => r.floorPoints && r.floorPoints.length >= 3);
                if (room) {
                    const centerX = -(room.floorPoints.reduce((sum, p) => sum + p.x, 0) / room.floorPoints.length / 30);
                    const centerZ = -room.floorPoints.reduce((sum, p) => sum + p.y, 0) / room.floorPoints.length / 30;
                    const centerY = room.ceilingHeight * 0.3048 / 2;
                    
                    if (window.setOrbitTarget) {
                        window.setOrbitTarget(centerX, centerY, centerZ);
                    }
                }
            }
            
            // Re-render
            renderer.render(scene, camera);
            showToast('üîÑ Camera reset to default view');
        }
        
        function toggleLeftPanel() {
            const panel = document.getElementById('leftPanel');
            const btn = panel.querySelector('.panel-collapse-btn');
            
            if (panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
                btn.textContent = '‚óÄ';
                btn.title = 'Collapse panel';
            } else {
                panel.classList.add('collapsed');
                btn.textContent = '‚ñ∂';
                btn.title = 'Expand panel';
            }
        }

        function printDrawing() {
            // Save current view mode
            const wasIn3D = state.currentView === '3d';
            
            // Switch to 2D for printing
            if (wasIn3D) {
                switch2D();
            }
            
            // Give the canvas a moment to render
            setTimeout(() => {
                // Trigger browser print dialog
                window.print();
                
                // Restore view after print dialog closes
                setTimeout(() => {
                    if (wasIn3D) {
                        switch3D();
                    }
                }, 100);
            }, 100);
            
            showToast('üñ®Ô∏è Opening print dialog...');
        }

        function generateWallInputs() {
            const count = parseInt(document.getElementById('wallCount').value);
            const container = document.getElementById('wallInputs');
            container.innerHTML = '';
            
            // Clear previous direction selections
            window.wallDirections = {};
            
            for (let i = 1; i <= count; i++) {
                const div = document.createElement('div');
                div.className = 'wall-entry';
                div.style.marginBottom = '15px';
                
                // Wall length input
                let html = `
                    <label style="display: block; margin-bottom: 5px; font-weight: 600;">Wall ${i} (ft)</label>
                    <input type="number" id="wall${i}Length" placeholder="0.0" step="0.1" 
                           oninput="livePreview()"
                           style="width: 100%; padding: 8px; margin-bottom: 8px; font-size: 14px; border: 2px solid #ddd; border-radius: 4px;">
                `;
                
                // Add direction controls for each wall
                html += `
                    <div style="margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 8px; border: 2px solid #999;">
                        <label style="display: block; font-size: 12px; font-weight: 700; color: #333; margin-bottom: 8px; text-align: center;">
                            üìç WALL ${i} DIRECTION
                        </label>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 6px;">
                            <button type="button" class="dir-btn" id="wall${i}DirUp" 
                                    onclick="selectDirection(${i}, 'up')"
                                    style="padding: 8px; font-size: 12px; font-weight: 700; border: 2px solid #ddd; border-radius: 6px; background: white; cursor: pointer;">
                                ‚¨ÜÔ∏è UP
                            </button>
                            <button type="button" class="dir-btn" id="wall${i}DirDown" 
                                    onclick="selectDirection(${i}, 'down')"
                                    style="padding: 8px; font-size: 12px; font-weight: 700; border: 2px solid #ddd; border-radius: 6px; background: white; cursor: pointer;">
                                ‚¨áÔ∏è DOWN
                            </button>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                            <button type="button" class="dir-btn" id="wall${i}DirLeft" 
                                    onclick="selectDirection(${i}, 'left')"
                                    style="padding: 8px; font-size: 12px; font-weight: 700; border: 2px solid #ddd; border-radius: 6px; background: white; cursor: pointer;">
                                ‚¨ÖÔ∏è LEFT
                            </button>
                            <button type="button" class="dir-btn" id="wall${i}DirRight" 
                                    onclick="selectDirection(${i}, 'right')"
                                    style="padding: 8px; font-size: 12px; font-weight: 700; border: 2px solid ${i === 1 ? '#4CAF50' : '#ddd'}; border-radius: 6px; background: ${i === 1 ? '#4CAF50' : 'white'}; color: ${i === 1 ? 'white' : '#333'}; cursor: pointer; ${i === 1 ? 'box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);' : ''}">
                                ‚û°Ô∏è RIGHT
                            </button>
                        </div>
                        <div id="wall${i}DirStatus" style="text-align: center; margin-top: 8px; padding: 6px; font-size: 11px; font-weight: 700; border-radius: 4px; background: ${i === 1 ? '#4CAF50' : '#999'}; color: white;">
                            ${i === 1 ? '‚û°Ô∏è Goes RIGHT (default)' : '‚ö™ Auto (follows previous)'}
                        </div>
                    </div>
                `;
                
                div.innerHTML = html;
                container.appendChild(div);
            }
        }
        
        function selectDirection(wallNum, direction) {
            console.log(`selectDirection called: wall ${wallNum}, direction ${direction}`);
            
            const upBtn = document.getElementById(`wall${wallNum}DirUp`);
            const downBtn = document.getElementById(`wall${wallNum}DirDown`);
            const leftBtn = document.getElementById(`wall${wallNum}DirLeft`);
            const rightBtn = document.getElementById(`wall${wallNum}DirRight`);
            const statusDiv = document.getElementById(`wall${wallNum}DirStatus`);
            
            // Reset all buttons
            [upBtn, downBtn, leftBtn, rightBtn].forEach(btn => {
                if (btn) {
                    btn.style.background = 'white';
                    btn.style.color = '#333';
                    btn.style.borderColor = '#ddd';
                    btn.style.boxShadow = 'none';
                }
            });
            
            // Highlight selected button
            let selectedBtn, emoji, color;
            switch(direction) {
                case 'up':
                    selectedBtn = upBtn;
                    emoji = '‚¨ÜÔ∏è';
                    color = '#2196F3';
                    break;
                case 'down':
                    selectedBtn = downBtn;
                    emoji = '‚¨áÔ∏è';
                    color = '#FF9800';
                    break;
                case 'left':
                    selectedBtn = leftBtn;
                    emoji = '‚¨ÖÔ∏è';
                    color = '#F44336';
                    break;
                case 'right':
                    selectedBtn = rightBtn;
                    emoji = '‚û°Ô∏è';
                    color = '#4CAF50';
                    break;
            }
            
            if (selectedBtn) {
                selectedBtn.style.background = color;
                selectedBtn.style.color = 'white';
                selectedBtn.style.borderColor = color;
                selectedBtn.style.boxShadow = `0 4px 15px ${color}66`;
            }
            
            // Update status
            if (statusDiv) {
                statusDiv.style.background = color;
                statusDiv.innerHTML = `${emoji} Goes ${direction.toUpperCase()}`;
            }
            
            // Store the direction
            if (!window.wallDirections) window.wallDirections = {};
            window.wallDirections[wallNum] = direction;
            console.log('window.wallDirections:', window.wallDirections);
            
            showToast(`${emoji} Wall ${wallNum} ‚Üí Goes ${direction.toUpperCase()}`);
            
            // Update live preview
            livePreview();
        }


        function livePreview() {
            // Safety checks
            if (!window.canvas2D) return;
            
            const wallCountElem = document.getElementById('wallCount');
            if (!wallCountElem) return;
            
            const wallCount = parseInt(wallCountElem.value);
            if (!wallCount || wallCount < 3) return;
            
            // Get wall lengths
            const wallLengths = [];
            for (let i = 1; i <= wallCount; i++) {
                const input = document.getElementById(`wall${i}Length`);
                const val = input ? parseFloat(input.value) : 0;
                wallLengths.push(val || 0);
            }
            
            // Check if any values entered
            const hasValues = wallLengths.some(len => len > 0);
            if (!hasValues) return;
            
            // Get wall directions
            const wallDirections = [];
            console.log('[PREVIEW] Reading wall directions...');
            for (let i = 1; i <= wallCount; i++) {
                let dir;
                if (i === 1) {
                    dir = window.wallDirections && window.wallDirections[i] ? window.wallDirections[i] : 'right';
                } else if (window.wallDirections && window.wallDirections[i]) {
                    dir = window.wallDirections[i];
                } else {
                    dir = 'auto';
                }
                wallDirections.push(dir);
                console.log(`[PREVIEW] Wall ${i}: ${dir}`);
            }
            console.log('[PREVIEW] window.wallDirections:', window.wallDirections);
            
            try {
                // Build preview shape in world coordinates (feet)
                const scale = 30; // pixels per foot
                
                const points = [];
                let x = 0; // Start at origin in world space
                let y = 0;
                let currentDir = wallDirections[0];
                
                points.push({ x, y });
                
                // Build walls in world space
                const actualDirections = []; // Track what direction each wall actually uses
                for (let i = 0; i < wallCount - 1; i++) {
                    const length = wallLengths[i]; // Length in feet
                    
                    let dir = wallDirections[i];
                    if (dir === 'auto') dir = currentDir;
                    
                    actualDirections.push(dir);
                    console.log(`[PREVIEW] Wall ${i+1}: goes ${dir.toUpperCase()}`);
                    
                    // Move in world space (feet)
                    switch(dir) {
                        case 'right': x += length; break;
                        case 'down': y += length; break;
                        case 'left': x -= length; break;
                        case 'up': y -= length; break;
                    }
                    
                    points.push({ x, y });
                    currentDir = dir;
                }
                
                // Convert points to pixels for bounds calculation
                const pixelPoints = points.map(p => ({ x: p.x * scale, y: p.y * scale }));
                
                // Calculate bounding box for auto-fit
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                pixelPoints.forEach(pt => {
                    minX = Math.min(minX, pt.x);
                    maxX = Math.max(maxX, pt.x);
                    minY = Math.min(minY, pt.y);
                    maxY = Math.max(maxY, pt.y);
                });
                
                const roomWidth = maxX - minX;
                const roomHeight = maxY - minY;
                const padding = 100; // Extra space around room in pixels
                
                // Calculate zoom to fit entire room
                const canvasWidth = canvas2D.width;
                const canvasHeight = canvas2D.height;
                const zoomX = canvasWidth / (roomWidth + padding * 2);
                const zoomY = canvasHeight / (roomHeight + padding * 2);
                const autoZoom = Math.min(zoomX, zoomY, 1.5); // Cap at 1.5x to avoid too much zoom
                
                // Center view on room (in pixel space)
                const roomCenterX = (minX + maxX) / 2;
                const roomCenterY = (minY + maxY) / 2;
                
                // Apply auto-fit
                state.zoom = autoZoom;
                state.panX = canvasWidth / 2 - roomCenterX * state.zoom;
                state.panY = canvasHeight / 2 - roomCenterY * state.zoom;
                
                // Draw
                redraw2D();
                
                const ctx = canvas2D.getContext('2d');
                ctx.save();
                
                // Apply pan/zoom transformations to match redraw2D
                ctx.translate(state.panX, state.panY);
                ctx.scale(state.zoom, state.zoom);
                
                // Preview shape
                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 4 / state.zoom; // Adjust line width for zoom
                ctx.setLineDash([8 / state.zoom, 4 / state.zoom]); // Adjust dash for zoom
                ctx.beginPath();
                
                for (let i = 0; i < pixelPoints.length; i++) {
                    if (i === 0) ctx.moveTo(pixelPoints[i].x, pixelPoints[i].y);
                    else ctx.lineTo(pixelPoints[i].x, pixelPoints[i].y);
                }
                
                // Close back to start
                ctx.lineTo(pixelPoints[0].x, pixelPoints[0].y);
                ctx.stroke();
                
                // Draw corner dots
                ctx.fillStyle = '#2196F3';
                pixelPoints.forEach(pt => {
                    ctx.beginPath();
                    ctx.arc(pt.x, pt.y, 6 / state.zoom, 0, Math.PI * 2); // Adjust dot size for zoom
                    ctx.fill();
                });
                
                // Label walls
                ctx.font = `bold ${13 / state.zoom}px Arial`; // Adjust font size for zoom
                ctx.fillStyle = '#1976D2';
                for (let i = 0; i < pixelPoints.length - 1; i++) {
                    if (wallLengths[i] > 0) {
                        const mx = (pixelPoints[i].x + pixelPoints[i + 1].x) / 2;
                        const my = (pixelPoints[i].y + pixelPoints[i + 1].y) / 2;
                        ctx.fillText(`${wallLengths[i]} ft`, mx - 20 / state.zoom, my - 8 / state.zoom);
                    }
                }
                
                ctx.restore(); // Restore to screen space for labels
                ctx.save();
                
                // PREVIEW label (in screen space)
                const cx = canvas2D.width / 2;
                ctx.font = 'bold 18px Arial';
                ctx.fillStyle = '#FF9800';
                ctx.fillText('PREVIEW', cx - 45, 30);
                
                // Show wall directions on canvas (in screen space)
                ctx.font = 'bold 12px Arial';
                let yPos = 50;
                for (let i = 0; i < actualDirections.length; i++) {
                    const dir = actualDirections[i];
                    let color, emoji;
                    switch(dir) {
                        case 'up': color = '#2196F3'; emoji = '‚¨ÜÔ∏è'; break;
                        case 'down': color = '#FF9800'; emoji = '‚¨áÔ∏è'; break;
                        case 'left': color = '#F44336'; emoji = '‚¨ÖÔ∏è'; break;
                        case 'right': color = '#4CAF50'; emoji = '‚û°Ô∏è'; break;
                        default: color = '#999'; emoji = '‚ö™';
                    }
                    ctx.fillStyle = color;
                    ctx.fillText(`W${i+1}: ${emoji} ${dir.toUpperCase()}`, 10, yPos);
                    yPos += 15;
                }
                
                ctx.restore();
            } catch(e) {
                console.warn('Preview error:', e);
            }
        }

        function previewFloorPlan() {
            // Compatibility wrapper
            livePreview();
        }


        function applyQuickEntry() {
            const room = getCurrentRoom();
            if (!room) return;
            
            const wallCount = parseInt(document.getElementById('wallCount').value);
            const wallLengths = [];
            const wallDirections = [];
            
            // Get wall lengths
            for (let i = 1; i <= wallCount; i++) {
                const val = parseFloat(document.getElementById(`wall${i}Length`).value);
                if (!val || val <= 0) {
                    showToast('‚ùå Enter all wall lengths');
                    return;
                }
                wallLengths.push(val);
            }
            
            // Get wall directions
            console.log('=== READING DIRECTIONS ===');
            for (let i = 1; i <= wallCount; i++) {
                let dir;
                if (i === 1) {
                    // Wall 1 defaults to right if not set
                    dir = window.wallDirections && window.wallDirections[i] ? window.wallDirections[i] : 'right';
                } else if (window.wallDirections && window.wallDirections[i]) {
                    // Use explicit direction if set
                    dir = window.wallDirections[i];
                } else {
                    // Auto: continue in same direction as previous wall
                    dir = 'auto';
                }
                wallDirections.push(dir);
                console.log(`Wall ${i} direction: ${dir}`);
            }
            
            room.ceilingHeight = parseFloat(document.getElementById('ceilingHeight').value);
            room.wallThickness = parseFloat(document.getElementById('wallThickness').value) || 4;
            
            const cx = canvas2D.width / 2;
            const cy = canvas2D.height / 2;
            const scale = 30;
            
            // Build floor plan using directions
            const points = [];
            let x = cx - 100;
            let y = cy - 100;
            let currentDir = wallDirections[0]; // First wall's direction
            
            // Starting point
            points.push({ x, y });
            
            console.log('=== BUILDING WALLS ===');
            console.log('Start:', { x, y });
            
            // Build each wall
            for (let i = 0; i < wallCount - 1; i++) {
                const length = wallLengths[i] * scale;
                
                // Determine this wall's direction
                let dir = wallDirections[i];
                if (dir === 'auto') {
                    dir = currentDir; // Continue in same direction
                }
                
                
                // Move in the specified direction
                switch(dir) {
                    case 'right': x += length; console.log('  Going RIGHT (east)'); break;
                    case 'down': y += length; console.log('  Going DOWN (south)'); break;
                    case 'left': x -= length; console.log('  Going LEFT (west)'); break;
                    case 'up': y -= length; console.log('  Going UP (north)'); break;
                }
                
                points.push({ x, y });
                console.log('  New position:', { x, y });
                
                // Update current direction for next auto wall
                currentDir = dir;
            }
            
            // Last wall back to start (auto-calculated)
            console.log(`\nWall ${wallCount}: Auto-close back to start`);
            
            // Create walls
            room.floorPoints = points;
            room.walls = [];
            
            for (let i = 0; i < wallCount; i++) {
                const nextIdx = (i + 1) % points.length;
                room.walls.push({
                    name: `Wall ${i+1}`,
                    start: points[i],
                    end: points[nextIdx],
                    length: i < wallLengths.length ? wallLengths[i].toFixed(1) : '?'
                });
            }
            
            // WELD CORNERS - Fix tiny gaps at corners
            const WELD_THRESHOLD = 0.1; // 0.1 feet = 1.2 inches
            for (let i = 0; i < room.walls.length; i++) {
                for (let j = i + 1; j < room.walls.length; j++) {
                    const wall1 = room.walls[i];
                    const wall2 = room.walls[j];
                    
                    const checks = [
                        { p1: wall1.start, p2: wall2.start },
                        { p1: wall1.start, p2: wall2.end },
                        { p1: wall1.end, p2: wall2.start },
                        { p1: wall1.end, p2: wall2.end }
                    ];
                    
                    checks.forEach(({ p1, p2 }) => {
                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) / 30;
                        
                        if (dist < WELD_THRESHOLD && dist > 0) {
                            const avgX = (p1.x + p2.x) / 2;
                            const avgY = (p1.y + p2.y) / 2;
                            p1.x = avgX;
                            p1.y = avgY;
                            p2.x = avgX;
                            p2.y = avgY;
                        }
                    });
                }
            }
            
            // Recalculate wall lengths after welding
            room.walls.forEach(wall => {
                const dx = wall.end.x - wall.start.x;
                const dy = wall.end.y - wall.start.y;
                const lengthPixels = Math.sqrt(dx * dx + dy * dy);
                const lengthFeet = lengthPixels / 30;
                wall.length = lengthFeet.toFixed(1);
            });
            
            console.log('=== FLOOR PLAN CREATED ===');
            console.log('Total points:', points.length);
            console.log('Total walls:', room.walls.length);
            
            redraw2D();
            updateStats();
            showToast('‚úì Floor plan created!');
        }

        function selectFeature(feature, ev) {
            console.log('===========================================');
            console.log('üîî selectFeature CALLED');
            console.log('Feature:', feature);
            console.log('Event:', ev);
            console.log('===========================================');
            
            const room = getCurrentRoom();
            if (!room || room.walls.length === 0) {
                console.log('‚ùå No room or no walls');
                showToast('‚ö†Ô∏è First: Enter wall lengths and click "‚úì Apply Measurements"');
                return;
            }
            
            console.log('‚úÖ Room exists with', room.walls.length, 'walls');
            
            // CRITICAL: Clear any wall drawing in progress
            if (state.wallDrawingCorners && state.wallDrawingCorners.length > 0) {
                console.log('üö´ Clearing wall drawing mode - had', state.wallDrawingCorners.length, 'corners');
                state.wallDrawingCorners = [];
            }
            
            console.log('Setting state.currentFeature to:', feature);
            console.log('Setting state.wallSelectionMode to: true (for placing feature)');
            
            state.currentFeature = feature;
            state.wallSelectionMode = true; // Enable wall selection for placing features
            state.pendingFeature = null;
            
            console.log('After setting - state.currentFeature:', state.currentFeature);
            console.log('After setting - state.wallSelectionMode:', state.wallSelectionMode);
            
            // DIAGNOSTIC: Flash screen green to confirm mode activated
            document.body.style.backgroundColor = '#00FF00';
            setTimeout(() => { document.body.style.backgroundColor = ''; }, 300);
            
            document.querySelectorAll('.feature-btn').forEach(b => b.classList.remove('active'));
            const btn = (ev && (ev.currentTarget || ev.target)) ? (ev.currentTarget || ev.target) : null;
            if (btn) {
                btn.classList.add('active');
                console.log('‚úÖ Button activated:', btn.textContent);
            }
            
            // Show instruction banner with specific text
            const banner = document.getElementById('instructionBanner');
            if (feature === 'door') {
                banner.textContent = 'üö™ Click on a wall to place door';
            } else if (feature === 'window') {
                banner.textContent = 'ü™ü Click on a wall to place window';
            } else if (feature === 'opening') {
                banner.textContent = 'üîì Click on a wall to add opening/passage';
            } else if (feature === 'missing-wall') {
                banner.textContent = 'üß± Click on a wall to add missing section';
            } else {
                banner.textContent = '‚ö†Ô∏è Click to place damage marker';
            }
            banner.classList.add('active');
            console.log('‚úÖ Banner shown:', banner.textContent);
            
            updateModeIndicator();
            showToast('Walls highlighted - click on any wall');
            redraw2D(); // Redraw to clear any wall drawing preview
            console.log('‚úÖ selectFeature completed');
            console.log('===========================================');
        }

        canvas2D.addEventListener('mouseup', (e) => {
            if (state.currentView !== '2d') return; // Only handle in 2D mode
            
            // ===== CREATING ADJACENT ROOM END (XACTIMATE CTRL+DRAG) =====
            if (state.creatingAdjacentRoom && state.adjacentRoomPreview) {
                const preview = state.adjacentRoomPreview;
                
                // Only create if depth is at least 1 foot
                if (preview.depth >= 1) {
                    const sourceRoom = state.creatingAdjacentRoom.sourceRoom;
                    
                    // Create new room with the preview dimensions
                    const newRoom = {
                        name: `Room ${state.rooms.length + 1}`,
                        level: state.currentLevel,
                        floorPoints: [
                            {x: preview.p1.x, y: preview.p1.y},
                            {x: preview.p2.x, y: preview.p2.y},
                            {x: preview.p3.x, y: preview.p3.y},
                            {x: preview.p4.x, y: preview.p4.y}
                        ],
                        walls: [],
                        doors: [],
                        windows: [],
                        // Copy properties from source room (Xactimate behavior)
                        ceilingHeight: sourceRoom.ceilingHeight || 8,
                        ceilingType: sourceRoom.ceilingType || 'Flat',
                        floorType: sourceRoom.floorType || 'Standard'
                    };
                    
                    // Calculate walls from floor points
                    updateRoomWallsFromPoints(newRoom);
                    
                    // Add to rooms array
                    state.rooms.push(newRoom);
                    state.currentRoomIndex = state.rooms.length - 1;
                    
                    showToast(`‚úÖ Adjacent room created! ${preview.depth.toFixed(1)}' deep`, 3000);
                    console.log('‚úÖ Created adjacent room using CTRL+Drag (Xactimate style)');
                    
                    updateRoomList();
                    updateLevelButtons();
                }
                
                // Clear preview
                state.creatingAdjacentRoom = null;
                state.adjacentRoomPreview = null;
                canvas2D.style.cursor = 'default';
                redraw2D();
                return;
            }
            
            // ===== ROOM EDIT MODE HANDLE DRAG END =====
            if (state.draggingHandle) {
                // XACTIMATE-STYLE: If dragging edge handle with preview, check for CTRL key
                if (state.draggingHandle.type === 'edge' && state.wallDragPreview) {
                    const room = getCurrentRoom();
                    if (room && state.wallDragPreview.distance > 0.5) { // Only if moved at least 6 inches
                        
                        // CHECK FOR CTRL KEY:
                        // CTRL pressed = Create new room
                        // CTRL not pressed = Expand current room
                        const createNewRoom = e.ctrlKey || e.metaKey; // metaKey for Mac Command key
                        
                        if (createNewRoom) {
                            // CREATE NEW ROOM - Fill the gap with a new room
                            createRoomInGap(room, state.draggingHandle, state.wallDragPreview);
                            showToast(`‚úÖ New room created! ${state.wallDragPreview.distance.toFixed(1)}' deep`, 3000);
                        } else {
                            // EXPAND ROOM - Move the wall to preview position
                            const edgeIndex = state.wallDragPreview.edgeIndex;
                            const p1Index = edgeIndex;
                            const p2Index = (edgeIndex + 1) % room.floorPoints.length;
                            
                            // Check if this edge is shared with another room BEFORE moving
                            const sharedEdgeBefore = findRoomSharingEdge(room, edgeIndex);
                            
                            // Move this room's wall
                            room.floorPoints[p1Index].x = state.wallDragPreview.p1.x;
                            room.floorPoints[p1Index].y = state.wallDragPreview.p1.y;
                            room.floorPoints[p2Index].x = state.wallDragPreview.p2.x;
                            room.floorPoints[p2Index].y = state.wallDragPreview.p2.y;
                            
                            // If this edge WAS shared, update the adjacent room's matching edge
                            if (sharedEdgeBefore) {
                                const adjRoom = sharedEdgeBefore.room;
                                const adjP1Index = sharedEdgeBefore.edgeIndex;
                                const adjP2Index = (adjP1Index + 1) % adjRoom.floorPoints.length;
                                
                                // Update adjacent room's matching points to keep wall aligned
                                adjRoom.floorPoints[adjP1Index].x = state.wallDragPreview.p1.x;
                                adjRoom.floorPoints[adjP1Index].y = state.wallDragPreview.p1.y;
                                adjRoom.floorPoints[adjP2Index].x = state.wallDragPreview.p2.x;
                                adjRoom.floorPoints[adjP2Index].y = state.wallDragPreview.p2.y;
                                
                                updateRoomWallsFromPoints(adjRoom);
                            }
                            
                            // CRITICAL: Check if the NEW position creates a shared wall with ANY room
                            // This handles the case where expanding creates a NEW shared wall
                            const roomsOnLevel = state.rooms.filter(r => r.level === state.currentLevel);
                            const newP1 = room.floorPoints[p1Index];
                            const newP2 = room.floorPoints[p2Index];
                            const snapTolerance = 30; // 30 pixels = 1 foot
                            
                            for (const otherRoom of roomsOnLevel) {
                                if (otherRoom === room) continue;
                                if (!otherRoom.floorPoints || otherRoom.floorPoints.length < 3) continue;
                                
                                // Check each edge of other room
                                for (let i = 0; i < otherRoom.floorPoints.length; i++) {
                                    const op1 = otherRoom.floorPoints[i];
                                    const op2 = otherRoom.floorPoints[(i + 1) % otherRoom.floorPoints.length];
                                    
                                    // Check if walls are very close (within 1 foot)
                                    const p1Close = Math.abs(newP1.x - op1.x) < snapTolerance && Math.abs(newP1.y - op1.y) < snapTolerance;
                                    const p2Close = Math.abs(newP2.x - op2.x) < snapTolerance && Math.abs(newP2.y - op2.y) < snapTolerance;
                                    const p1CloseReverse = Math.abs(newP1.x - op2.x) < snapTolerance && Math.abs(newP1.y - op2.y) < snapTolerance;
                                    const p2CloseReverse = Math.abs(newP2.x - op1.x) < snapTolerance && Math.abs(newP2.y - op1.y) < snapTolerance;
                                    
                                    if ((p1Close && p2Close) || (p1CloseReverse && p2CloseReverse)) {
                                        // SNAP to exact coordinates to create perfect shared wall
                                        if (p1Close && p2Close) {
                                            newP1.x = op1.x;
                                            newP1.y = op1.y;
                                            newP2.x = op2.x;
                                            newP2.y = op2.y;
                                        } else {
                                            newP1.x = op2.x;
                                            newP1.y = op2.y;
                                            newP2.x = op1.x;
                                            newP2.y = op1.y;
                                        }
                                        break;
                                    }
                                }
                            }
                            
                            // Update this room
                            updateRoomWallsFromPoints(room);
                            
                            // CRITICAL: Redraw ALL rooms on this level
                            // This forces them to recalculate shared walls after snapping
                            redraw2D();
                            
                            showToast(`‚úÖ Room expanded by ${state.wallDragPreview.distance.toFixed(1)}'`, 3000);
                        }
                    }
                }
                
                state.draggingHandle = null;
                state.wallDragPreview = null;
                redraw2D();
                return;
            }
            
            // ===== ZOOM WINDOW EXECUTION =====
            if (state.zoomWindowMode && state.zoomWindowStart && state.zoomWindowEnd) {
                if (typeof window.executeZoomWindow === 'function') {
                    window.executeZoomWindow(
                        state.zoomWindowStart.x,
                        state.zoomWindowStart.y,
                        state.zoomWindowEnd.x,
                        state.zoomWindowEnd.y
                    );
                }
                return;
            }
            
            if (isPanning) {
                isPanning = false;
                canvas2D.style.cursor = 'default';
            }
            
            // Feature dragging cleanup
            if (state.draggingFeature) {
                const featureNames = {
                    'door': 'üö™ Door',
                    'window': 'ü™ü Window',
                    'missing': 'üß± Missing wall'
                };
                showToast(`${featureNames[state.draggingFeatureType] || 'Feature'} repositioned`);
                state.draggingFeature = null;
                state.draggingFeatureType = null;
                state.draggingFeatureIndex = null;
                state.draggingFeatureWallIndex = null;
                canvas2D.style.cursor = 'default';
                
                // Update 3D view if active
                if (state.currentView === '3d') {
                    render3D();
                }
                updateStats();
                return;
            }
            
            if (state.draggingRoom !== null) {
                const room = state.rooms[state.draggingRoom];
                if (state.lastSnapped) {
                    const snapMsg = state.snapType ? 
                        `${state.snapType} ${room.name} at (${Math.round(room.positionX)}, ${Math.round(room.positionZ)})` :
                        `‚ö° ${room.name} snapped to (${Math.round(room.positionX)}, ${Math.round(room.positionZ)})`;
                    showToast(snapMsg);
                } else {
                    showToast(`üìç ${room.name} moved to (${Math.round(room.positionX)}, ${Math.round(room.positionZ)})`);
                }
                state.draggingRoom = null;
                state.lastSnapped = false;
                state.snapType = '';
                canvas2D.style.cursor = 'default';
                redraw2D(); // CRITICAL: Redraw to clear snap indicator
                if (state.currentView === '3d') {
                    render3D();
                }
            }
        });

        canvas2D.addEventListener('mouseleave', () => {
            if (state.currentView !== '2d') return; // Only handle in 2D mode
            
            if (isPanning) {
                isPanning = false;
                canvas2D.style.cursor = 'default';
            }
            
            // Feature dragging cleanup
            if (state.draggingFeature) {
                state.draggingFeature = null;
                state.draggingFeatureType = null;
                state.draggingFeatureIndex = null;
                state.draggingFeatureWallIndex = null;
                canvas2D.style.cursor = 'default';
            }
            
            if (state.draggingRoom !== null) {
                state.draggingRoom = null;
                state.lastSnapped = false;
                state.snapType = '';
                canvas2D.style.cursor = 'default';
                redraw2D(); // Redraw to clear any snap indicators
            }
        });

        // ========== TOUCH SUPPORT FOR IPAD ==========
        // Add touch-based panning for iPad/iOS devices
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartPanX = 0;
        let touchStartPanY = 0;
        let isTouchPanning = false;
        let lastTouchDistance = 0;
        let touchStartPosition = { x: 0, y: 0 }; // Track where touch started
        let touchMoved = false; // Track if finger actually moved

        canvas2D.addEventListener('touchstart', (e) => {
            if (state.currentView !== '2d') return;
            
            console.log('üëÜ Canvas touch start, touches:', e.touches.length);
            
            if (e.touches.length === 1) {
                // Single finger - might be tap, pan, drag feature, or drag room
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas2D.getBoundingClientRect();
                
                // Calculate touch position
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                const x = (touchX - state.panX) / state.zoom;
                const y = (touchY - state.panY) / state.zoom;
                
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                touchStartPosition = { x: touch.clientX, y: touch.clientY }; // Remember start position
                touchMoved = false; // Reset movement flag
                touchStartPanX = state.panX;
                touchStartPanY = state.panY;
                
                // Check if touching a room for dragging (when Show All Rooms is enabled)
                if (state.showAllRooms && !state.wallSelectionMode && !state.currentFeature) {
                    for (let i = state.rooms.length - 1; i >= 0; i--) {
                        const room = state.rooms[i];
                        if (room.floorPoints.length < 3) continue;
                        
                        const offsetX = (room.positionX || 0) * 30;
                        const offsetZ = (room.positionZ || 0) * 30;
                        
                        // Check if touch point is inside room polygon
                        let inside = false;
                        for (let j = 0, k = room.floorPoints.length - 1; j < room.floorPoints.length; k = j++) {
                            const xi = room.floorPoints[j].x + offsetX;
                            const yi = room.floorPoints[j].y + offsetZ;
                            const xk = room.floorPoints[k].x + offsetX;
                            const yk = room.floorPoints[k].y + offsetZ;
                            
                            if ((yi > y) !== (yk > y) && x < (xk - xi) * (y - yi) / (yk - yi) + xi) {
                                inside = !inside;
                            }
                        }
                        
                        if (inside) {
                            state.draggingRoom = i;
                            state.dragStartX = x;
                            state.dragStartY = y;
                            state.dragStartRoomX = room.positionX || 0;
                            state.dragStartRoomZ = room.positionZ || 0;
                            state.currentRoomIndex = i;
                            isTouchPanning = false; // Don't pan, we're dragging room
                            updateRoomList();
                            redraw2D();
                            console.log('üè† Started dragging room:', room.name);
                            return;
                        }
                    }
                }
                
                // Check if touching a feature (but don't start dragging yet - wait to see if finger moves)
                if (!state.wallSelectionMode && !state.currentFeature) {
                    const room = getCurrentRoom();
                    if (room) {
                        // Check doors
                        for (let i = room.doors.length - 1; i >= 0; i--) {
                            const door = room.doors[i];
                            const dist = Math.sqrt(Math.pow(x - door.x, 2) + Math.pow(y - door.y, 2));
                            if (dist < 50) {
                                // Store potential drag target, but don't start dragging yet
                                state.potentialDragFeature = door;
                                state.potentialDragType = 'door';
                                state.potentialDragIndex = i;
                                isTouchPanning = false; // Don't pan if on feature
                                console.log('üö™ Touching door - waiting to see if tap or drag');
                                return;
                            }
                        }
                        
                        // Check windows
                        for (let i = room.windows.length - 1; i >= 0; i--) {
                            const win = room.windows[i];
                            const dist = Math.sqrt(Math.pow(x - win.x, 2) + Math.pow(y - win.y, 2));
                            if (dist < 50) {
                                // Store potential drag target
                                state.potentialDragFeature = win;
                                state.potentialDragType = 'window';
                                state.potentialDragIndex = i;
                                isTouchPanning = false;
                                console.log('ü™ü Touching window - waiting to see if tap or drag');
                                return;
                            }
                        }
                        
                        // Check wall cuts (openings created with Opening button)
                        const hitCut = findClickedCut(room, x, y);
                        if (hitCut) {
                            const wall = room.walls[hitCut.wallIdx];
                            if (wall && wall.cuts && wall.cuts[hitCut.cutIdx]) {
                                // Store potential drag target for wall cut
                                state.potentialDragFeature = wall.cuts[hitCut.cutIdx];
                                state.potentialDragType = 'cut';
                                state.potentialDragIndex = hitCut.cutIdx;
                                state.potentialDragWallIndex = hitCut.wallIdx;
                                isTouchPanning = false;
                                console.log('üîì Touching opening/cut - waiting to see if tap or drag');
                                return;
                            }
                        }
                        
                        // Check openings/missing walls
                        const hitMissing = findMissingAtPoint(room, x, y);
                        if (hitMissing) {
                            const wall = room.walls[hitMissing.wallIdx];
                            if (wall && wall.missingWalls && wall.missingWalls[hitMissing.missIdx]) {
                                // Store potential drag target
                                state.potentialDragFeature = wall.missingWalls[hitMissing.missIdx];
                                state.potentialDragType = 'missing';
                                state.potentialDragIndex = hitMissing.missIdx;
                                state.potentialDragWallIndex = hitMissing.wallIdx;
                                isTouchPanning = false;
                                console.log('üß± Touching opening - waiting to see if tap or drag');
                                return;
                            }
                        }
                    }
                }
                
                // Always track touches for tap detection
                isTouchPanning = true;
                console.log('‚úÖ Single-finger touch started (tap or pan)');
            } else if (e.touches.length === 2) {
                // Two fingers - start pinch zoom
                e.preventDefault();
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate center point for zoom
                touchStartX = (touch1.clientX + touch2.clientX) / 2;
                touchStartY = (touch1.clientY + touch2.clientY) / 2;
                touchStartPanX = state.panX;
                touchStartPanY = state.panY;
                
                // Calculate initial distance for pinch zoom
                const dx = touch2.clientX - touch1.clientX;
                const dy = touch2.clientY - touch1.clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                
                isTouchPanning = true;
                touchMoved = true; // Two-finger is always a gesture, not a tap
                console.log('‚úÖ Two-finger pinch zoom started');
            }
        }, { passive: false });

        canvas2D.addEventListener('touchmove', (e) => {
            if (state.currentView !== '2d') return;
            if (!isTouchPanning && !state.draggingFeature && !state.potentialDragFeature && !state.draggingRoom) return;
            
            e.preventDefault();
            
            const touch = e.touches[0];
            
            // Handle room dragging
            if (state.draggingRoom !== null) {
                const rect = canvas2D.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                const x = (touchX - state.panX) / state.zoom;
                const y = (touchY - state.panY) / state.zoom;
                
                const room = state.rooms[state.draggingRoom];
                const dx = (x - state.dragStartX) / 30; // Convert pixels to position units
                const dy = (y - state.dragStartY) / 30;
                
                let newX = state.dragStartRoomX + dx;
                let newZ = state.dragStartRoomZ + dy;
                
                // Calculate room bounds for snapping
                if (room.floorPoints.length >= 3) {
                    let minX = Infinity, maxX = -Infinity;
                    let minZ = Infinity, maxZ = -Infinity;
                    
                    room.floorPoints.forEach(p => {
                        minX = Math.min(minX, p.x / 30);
                        maxX = Math.max(maxX, p.x / 30);
                        minZ = Math.min(minZ, p.y / 30);
                        maxZ = Math.max(maxZ, p.y / 30);
                    });
                    
                    const roomWidth = maxX - minX;
                    const roomDepth = maxZ - minZ;
                    
                    // Calculate this room's corners in world space
                    const myCorners = [
                        { x: newX + minX, z: newZ + minZ, name: 'TL' },
                        { x: newX + maxX, z: newZ + minZ, name: 'TR' },
                        { x: newX + maxX, z: newZ + maxZ, name: 'BR' },
                        { x: newX + minX, z: newZ + maxZ, name: 'BL' }
                    ];
                    
                    // Check for snapping to other rooms
                    const snapTolerance = 1.0; // Snap if within 1 foot
                    let snapped = false;
                    let snapType = '';
                    
                    state.rooms.forEach((otherRoom, idx) => {
                        if (idx === state.draggingRoom || otherRoom.floorPoints.length < 3) return;
                        
                        let otherMinX = Infinity, otherMaxX = -Infinity;
                        let otherMinZ = Infinity, otherMaxZ = -Infinity;
                        
                        otherRoom.floorPoints.forEach(p => {
                            otherMinX = Math.min(otherMinX, p.x / 30);
                            otherMaxX = Math.max(otherMaxX, p.x / 30);
                            otherMinZ = Math.min(otherMinZ, p.y / 30);
                            otherMaxZ = Math.max(otherMaxZ, p.y / 30);
                        });
                        
                        const otherX = (otherRoom.positionX || 0);
                        const otherZ = (otherRoom.positionZ || 0);
                        
                        // Other room's corners in world space
                        const otherCorners = [
                            { x: otherX + otherMinX, z: otherZ + otherMinZ, name: 'TL' },
                            { x: otherX + otherMaxX, z: otherZ + otherMinZ, name: 'TR' },
                            { x: otherX + otherMaxX, z: otherZ + otherMaxZ, name: 'BR' },
                            { x: otherX + otherMinX, z: otherZ + otherMaxZ, name: 'BL' }
                        ];
                        
                        // CORNER TO CORNER SNAPPING (highest priority)
                        if (!snapped) {
                            for (let i = 0; i < myCorners.length && !snapped; i++) {
                                for (let j = 0; j < otherCorners.length && !snapped; j++) {
                                    const dist = Math.sqrt(
                                        Math.pow(myCorners[i].x - otherCorners[j].x, 2) + 
                                        Math.pow(myCorners[i].z - otherCorners[j].z, 2)
                                    );
                                    
                                    if (dist < snapTolerance * 1.5) {
                                        // Snap this corner to that corner
                                        const offsetX = otherCorners[j].x - myCorners[i].x;
                                        const offsetZ = otherCorners[j].z - myCorners[i].z;
                                        newX += offsetX;
                                        newZ += offsetZ;
                                        snapped = true;
                                        snapType = '‚ö° CORNER';
                                        
                                        // Update corner positions after snap
                                        myCorners[0] = { x: newX + minX, z: newZ + minZ };
                                        myCorners[1] = { x: newX + maxX, z: newZ + minZ };
                                        myCorners[2] = { x: newX + maxX, z: newZ + maxZ };
                                        myCorners[3] = { x: newX + minX, z: newZ + maxZ };
                                        
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // EDGE TO EDGE SNAPPING (if no corner snap)
                        if (!snapped) {
                            // My room's edges
                            const myLeft = newX + minX;
                            const myRight = newX + maxX;
                            const myTop = newZ + minZ;
                            const myBottom = newZ + maxZ;
                            
                            // Other room's edges
                            const otherLeft = otherX + otherMinX;
                            const otherRight = otherX + otherMaxX;
                            const otherTop = otherZ + otherMinZ;
                            const otherBottom = otherZ + otherMaxZ;
                            
                            // Snap right edge to left edge of other room
                            if (Math.abs(myRight - otherLeft) < snapTolerance) {
                                newX = otherLeft - maxX;
                                snapped = true;
                                snapType = '‚ö° EDGE';
                            }
                            // Snap left edge to right edge of other room
                            if (Math.abs(myLeft - otherRight) < snapTolerance) {
                                newX = otherRight - minX;
                                snapped = true;
                                snapType = '‚ö° EDGE';
                            }
                            // Snap bottom edge to top edge of other room
                            if (Math.abs(myBottom - otherTop) < snapTolerance) {
                                newZ = otherTop - maxZ;
                                snapped = true;
                                snapType = '‚ö° EDGE';
                            }
                            // Snap top edge to bottom edge of other room
                            if (Math.abs(myTop - otherBottom) < snapTolerance) {
                                newZ = otherBottom - minZ;
                                snapped = true;
                                snapType = '‚ö° EDGE';
                            }
                        }
                    });
                    
                    state.snapType = snapType;
                    
                    if (snapped) {
                        state.lastSnapped = true;
                    } else {
                        state.lastSnapped = false;
                    }
                }
                
                room.positionX = newX;
                room.positionZ = newZ;
                
                touchMoved = true; // Room was dragged
                redraw2D();
                return;
            }
            
            // Check if finger moved enough to start dragging a potential feature
            if (state.potentialDragFeature && !state.draggingFeature) {
                const distX = Math.abs(touch.clientX - touchStartPosition.x);
                const distY = Math.abs(touch.clientY - touchStartPosition.y);
                
                if (distX > 10 || distY > 10) {
                    // Finger moved enough - convert potential drag to actual drag
                    console.log('üéØ Finger moved - starting drag');
                    saveStateForUndo();
                    state.draggingFeature = state.potentialDragFeature;
                    state.draggingFeatureType = state.potentialDragType;
                    state.draggingFeatureIndex = state.potentialDragIndex;
                    state.draggingFeatureWallIndex = state.potentialDragWallIndex;
                    
                    // Clear potential
                    state.potentialDragFeature = null;
                    state.potentialDragType = null;
                    state.potentialDragIndex = null;
                    state.potentialDragWallIndex = null;
                    
                    touchMoved = true;
                }
            }
            
            // Handle feature dragging
            if (state.draggingFeature) {
                const rect = canvas2D.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                const x = (touchX - state.panX) / state.zoom;
                const y = (touchY - state.panY) / state.zoom;
                
                const room = getCurrentRoom();
                if (!room) return;
                
                if (state.draggingFeatureType === 'door' || state.draggingFeatureType === 'window') {
                    const feature = state.draggingFeatureType === 'door' ? room.doors[state.draggingFeatureIndex] : room.windows[state.draggingFeatureIndex];
                    if (!feature) return;
                    
                    const wall = room.walls[feature.wallIndex];
                    if (!wall) return;
                    
                    // Find closest point on the wall to the touch
                    const wallDx = wall.end.x - wall.start.x;
                    const wallDy = wall.end.y - wall.start.y;
                    const wallLength = Math.sqrt(wallDx * wallDx + wallDy * wallDy);
                    
                    // Project touch position onto wall
                    const touchToWallStartX = x - wall.start.x;
                    const touchToWallStartY = y - wall.start.y;
                    const projection = (touchToWallStartX * wallDx + touchToWallStartY * wallDy) / (wallLength * wallLength);
                    const clampedProjection = Math.max(0, Math.min(1, projection));
                    
                    // Calculate new position on wall
                    feature.x = wall.start.x + clampedProjection * wallDx;
                    feature.y = wall.start.y + clampedProjection * wallDy;
                    
                    // Update distanceFromLeft
                    const wallLengthFt = parseFloat(wall.length);
                    const featureWidthFt = feature.width / 12;
                    const distanceFromStartFt = clampedProjection * wallLengthFt;
                    const edgePosition = distanceFromStartFt - (featureWidthFt / 2);
                    feature.distanceFromLeft = Math.max(0, Math.min(wallLengthFt - featureWidthFt, edgePosition));
                    
                    redraw2D();
                    return;
                    
                } else if (state.draggingFeatureType === 'cut') {
                    // Dragging a wall cut (opening) - TOUCH
                    const wall = room.walls[state.draggingFeatureWallIndex];
                    const cut = wall.cuts[state.draggingFeatureIndex];
                    if (!wall || !cut) return;
                    
                    // Find closest point on the wall to the touch
                    const wallDx = wall.end.x - wall.start.x;
                    const wallDy = wall.end.y - wall.start.y;
                    const wallLength = Math.sqrt(wallDx * wallDx + wallDy * wallDy);
                    
                    // Project touch position onto wall
                    const touchToWallStartX = x - wall.start.x;
                    const touchToWallStartY = y - wall.start.y;
                    const projection = (touchToWallStartX * wallDx + touchToWallStartY * wallDy) / (wallLength * wallLength);
                    const clampedProjection = Math.max(0, Math.min(1, projection));
                    
                    // Calculate segment center position
                    const segmentCenter = clampedProjection * wallLength / 30; // Convert to feet
                    const segmentWidthFt = (cut.endDist - cut.startDist);
                    
                    // Update both start and end to move the whole segment
                    const newStart = Math.max(0, segmentCenter - segmentWidthFt / 2);
                    const newEnd = Math.min(wallLength / 30, segmentCenter + segmentWidthFt / 2);
                    
                    cut.startDist = newStart;
                    cut.endDist = newEnd;
                    
                    redraw2D();
                    return;
                    
                } else if (state.draggingFeatureType === 'missing') {
                    const wall = room.walls[state.draggingFeatureWallIndex];
                    const missing = wall.missingWalls[state.draggingFeatureIndex];
                    if (!wall || !missing) return;
                    
                    // Find closest point on the wall to the touch
                    const wallDx = wall.end.x - wall.start.x;
                    const wallDy = wall.end.y - wall.start.y;
                    const wallLength = Math.sqrt(wallDx * wallDx + wallDy * wallDy);
                    
                    // Project touch position onto wall
                    const touchToWallStartX = x - wall.start.x;
                    const touchToWallStartY = y - wall.start.y;
                    const projection = (touchToWallStartX * wallDx + touchToWallStartY * wallDy) / (wallLength * wallLength);
                    const clampedProjection = Math.max(0, Math.min(1, projection));
                    
                    // Calculate segment center position
                    const segmentCenter = clampedProjection * wallLength / 30; // Convert to feet (30 pixels = 1 foot)
                    const segmentWidthFt = (missing.endDist - missing.startDist);
                    
                    // Update both start and end to move the whole segment
                    const newStart = Math.max(0, segmentCenter - segmentWidthFt / 2);
                    const newEnd = Math.min(wallLength / 30, segmentCenter + segmentWidthFt / 2);
                    
                    missing.startDist = newStart;
                    missing.endDist = newEnd;
                    
                    redraw2D();
                    return;
                }
            }
            
            // Handle panning if not dragging
            if (isTouchPanning && e.touches.length === 1) {
                // Single finger pan
                const touch = e.touches[0];
                
                // Check if finger moved more than 20 pixels from start (increased threshold)
                const distX = Math.abs(touch.clientX - touchStartPosition.x);
                const distY = Math.abs(touch.clientY - touchStartPosition.y);
                const totalMovement = Math.sqrt(distX * distX + distY * distY);
                
                console.log(`Finger movement: ${totalMovement.toFixed(0)}px`);
                
                if (totalMovement > 20) {
                    touchMoved = true; // Finger moved significantly = pan, not tap
                    console.log('‚ö†Ô∏è Movement exceeded 20px - treating as PAN');
                } else {
                    console.log('‚úì Movement under 20px - still a TAP');
                }
                
                // Only actually pan if NOT in wall selection mode AND finger moved enough
                if (!state.wallSelectionMode && !state.currentFeature && totalMovement > 20) {
                    const dx = touch.clientX - touchStartX;
                    const dy = touch.clientY - touchStartY;
                    
                    state.panX = touchStartPanX + dx;
                    state.panY = touchStartPanY + dy;
                    
                    redraw2D();
                }
            } else if (e.touches.length === 2) {
                // Two finger pinch zoom + pan
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate new center
                const centerX = (touch1.clientX + touch2.clientX) / 2;
                const centerY = (touch1.clientY + touch2.clientY) / 2;
                
                // Pan based on center movement
                const dx = centerX - touchStartX;
                const dy = centerY - touchStartY;
                state.panX = touchStartPanX + dx;
                state.panY = touchStartPanY + dy;
                
                // Calculate new distance for zoom
                const dx2 = touch2.clientX - touch1.clientX;
                const dy2 = touch2.clientY - touch1.clientY;
                const newDistance = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                
                // Apply pinch zoom
                if (lastTouchDistance > 0) {
                    const zoomFactor = newDistance / lastTouchDistance;
                    const oldZoom = state.zoom;
                    state.zoom = Math.max(0.1, Math.min(5, state.zoom * zoomFactor));
                    
                    // Adjust pan to zoom toward touch point
                    const rect = canvas2D.getBoundingClientRect();
                    const mouseX = centerX - rect.left;
                    const mouseY = centerY - rect.top;
                    const worldX = (mouseX - state.panX) / oldZoom;
                    const worldY = (mouseY - state.panY) / oldZoom;
                    state.panX = mouseX - worldX * state.zoom;
                    state.panY = mouseY - worldY * state.zoom;
                    
                    document.getElementById('zoomLevel').textContent = Math.round(state.zoom * 100) + '%';
                }
                
                lastTouchDistance = newDistance;
                redraw2D();
            }
        }, { passive: false });

        canvas2D.addEventListener('touchend', (e) => {
            // Store touch info for tap detection
            const fingerMoved = touchMoved; // Did the finger actually move?
            const touchCount = e.changedTouches.length;
            
            // Room dragging cleanup
            if (state.draggingRoom !== null) {
                const room = state.rooms[state.draggingRoom];
                if (state.lastSnapped) {
                    const snapMsg = state.snapType ? 
                        `${state.snapType} ${room.name} at (${Math.round(room.positionX)}, ${Math.round(room.positionZ)})` :
                        `‚ö° ${room.name} snapped to (${Math.round(room.positionX)}, ${Math.round(room.positionZ)})`;
                    showToast(snapMsg);
                } else {
                    showToast(`üìç ${room.name} moved to (${Math.round(room.positionX)}, ${Math.round(room.positionZ)})`);
                }
                state.draggingRoom = null;
                state.lastSnapped = false;
                state.snapType = '';
                if (state.currentView === '3d') {
                    render3D();
                }
                console.log('‚úÖ Room drag ended');
                return; // Don't treat room drag end as a tap
            }
            
            // Feature dragging cleanup
            if (state.draggingFeature) {
                const featureNames = {
                    'door': 'üö™ Door',
                    'window': 'ü™ü Window',
                    'cut': 'üîì Opening',
                    'missing': 'üß± Opening'
                };
                showToast(`${featureNames[state.draggingFeatureType] || 'Feature'} repositioned`);
                state.draggingFeature = null;
                state.draggingFeatureType = null;
                state.draggingFeatureIndex = null;
                state.draggingFeatureWallIndex = null;
                console.log('‚úÖ Drag ended');
                return; // Don't treat drag end as a tap
            }
            
            // If we had a potential drag but finger didn't move, it's a TAP to EDIT
            if (state.potentialDragFeature && !fingerMoved) {
                console.log('üéØ Quick tap on feature - opening edit modal');
                const room = getCurrentRoom();
                if (room) {
                    if (state.potentialDragType === 'door') {
                        showPositionModal('door', state.potentialDragIndex);
                    } else if (state.potentialDragType === 'window') {
                        showPositionModal('window', state.potentialDragIndex);
                    } else if (state.potentialDragType === 'cut') {
                        showCutWallEditModal(state.currentRoomIndex, state.potentialDragWallIndex, state.potentialDragIndex);
                    } else if (state.potentialDragType === 'missing') {
                        showMissingWallEditModal(state.currentRoomIndex, state.potentialDragWallIndex, state.potentialDragIndex);
                    }
                }
                
                // Clear potential drag
                state.potentialDragFeature = null;
                state.potentialDragType = null;
                state.potentialDragIndex = null;
                state.potentialDragWallIndex = null;
                return; // Don't continue to wall click logic
            }
            
            // Clear potential drag if it exists
            if (state.potentialDragFeature) {
                state.potentialDragFeature = null;
                state.potentialDragType = null;
                state.potentialDragIndex = null;
                state.potentialDragWallIndex = null;
            }
            
            if (e.touches.length === 0) {
                isTouchPanning = false;
                lastTouchDistance = 0;
                console.log('‚úÖ Touch panning ended');
                console.log('Final touchMoved status:', fingerMoved);
                console.log('Touch count:', touchCount);
                console.log('Wall selection mode:', state.wallSelectionMode);
                console.log('Current feature:', state.currentFeature);
                
                // If finger DIDN'T move (tap, not pan), trigger click logic for PLACEMENT
                // FIXED: Always call handleWallClick on tap, not just in wallSelectionMode
                if (!fingerMoved && touchCount === 1) {
                    const touch = e.changedTouches[0];
                    console.log('üéØ TAP DETECTED (no movement)! Calling handleWallClick...');
                    console.log('wallSelectionMode:', state.wallSelectionMode);
                    console.log('currentFeature:', state.currentFeature);
                    
                    // DIAGNOSTIC: Flash screen blue to show tap was detected
                    document.body.style.backgroundColor = '#0000FF';
                    setTimeout(() => { document.body.style.backgroundColor = ''; }, 200);
                    
                    // Show visible feedback
                    if (state.wallSelectionMode && state.currentFeature) {
                        showToast('üéØ Tap detected - checking walls...');
                    }
                    
                    // Create a fake click event for the wall selection logic
                    const fakeEvent = {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        shiftKey: false,
                        preventDefault: () => {},
                        stopPropagation: () => {}
                    };
                    
                    console.log('Calling handleWallClick with coordinates:', touch.clientX, touch.clientY);
                    
                    // Manually trigger the wall click logic
                    handleWallClick(fakeEvent);
                } else {
                    console.log('‚ùå NOT calling handleWallClick - fingerMoved:', fingerMoved, 'touchCount:', touchCount);
                }
            } else if (e.touches.length === 1 && isTouchPanning) {
                // One finger lifted during two-finger gesture, restart with one finger
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                touchStartPanX = state.panX;
                touchStartPanY = state.panY;
                lastTouchDistance = 0;
            }
        }, { passive: false });

        canvas2D.addEventListener('touchcancel', () => {
            isTouchPanning = false;
            lastTouchDistance = 0;
            
            // Room dragging cleanup
            if (state.draggingRoom !== null) {
                state.draggingRoom = null;
                state.lastSnapped = false;
                state.snapType = '';
            }
            
            // Feature dragging cleanup
            if (state.draggingFeature) {
                state.draggingFeature = null;
                state.draggingFeatureType = null;
                state.draggingFeatureIndex = null;
                state.draggingFeatureWallIndex = null;
            }
            
            // Potential drag cleanup
            if (state.potentialDragFeature) {
                state.potentialDragFeature = null;
                state.potentialDragType = null;
                state.potentialDragIndex = null;
                state.potentialDragWallIndex = null;
            }
            
            console.log('Touch cancelled');
        }, { passive: false });

        // Handle wall clicks for feature placement (called from both mouse and touch events)
        function handleWallClick(e) {
            if (state.currentView !== '2d') return; // Only handle in 2D mode
            
            const room = getCurrentRoom();
            if (!room) return;
            
            const rect = canvas2D.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            // Transform click coordinates to account for zoom and pan
            const x = (clickX - state.panX) / state.zoom;
            const y = (clickY - state.panY) / state.zoom;
            
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('CANVAS CLICKED');
            console.log('Raw click:', clickX, clickY);
            console.log('After zoom/pan:', x, y);
            console.log('Zoom:', state.zoom, 'Pan:', state.panX, state.panY);
            console.log('wallSelectionMode:', state.wallSelectionMode);
            console.log('currentFeature:', state.currentFeature);
            console.log('Room has', room.doors.length, 'doors and', room.windows.length, 'windows');
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            
            // MODE 1: Reposition OR Delete doors/windows - when NOT in any placement mode
            if (!state.wallSelectionMode && !state.currentFeature) {
                console.log('‚úì IN REPOSITION/DELETE MODE');
                console.log('Shift key:', e.shiftKey);
                console.log('Checking doors and windows...');
                
                
            // Check wall cuts (Shift+Click to delete, Click to edit)
            if (!state.wallSelectionMode && !state.currentFeature) {
                const hitCut = findClickedCut(room, x, y);
                if (hitCut) {
                    if (e.shiftKey) {
                        // Quick delete
                        const wall = room.walls[hitCut.wallIdx];
                        if (wall && wall.cuts && wall.cuts[hitCut.cutIdx]) {
                            saveStateForUndo();
                            wall.cuts.splice(hitCut.cutIdx, 1);
                            if (wall.cuts.length === 0) delete wall.cuts;
                            showToast('üóëÔ∏è Cut removed (Shift+Click)');
                            redraw2D();
                            if (state.currentView === '3d') render3D();
                            updateStats();
                        }
                    } else {
                        showCutWallEditModal(state.currentRoomIndex, hitCut.wallIdx, hitCut.cutIdx);
                    }
                    return;
                }
            }

// Check doors first
                
                // Check missing walls (Shift+Click to delete, Click to edit)
                const hitMissing = findMissingAtPoint(room, x, y);
                if (hitMissing) {
                    const wall = room.walls[hitMissing.wallIdx];
                    if (e.shiftKey) {
                        if (wall && wall.missingWalls && wall.missingWalls[hitMissing.missIdx]) {
                            saveStateForUndo();
                            wall.missingWalls.splice(hitMissing.missIdx, 1);
                            if (wall.missingWalls.length === 0) delete wall.missingWalls;
                            showToast('üß± Missing wall deleted (Shift+Click)');
                            redraw2D();
                            if (state.currentView === '3d') render3D();
                            updateStats();
                            return;
                        }
                    } else {
                        showMissingWallEditModal(state.currentRoomIndex, hitMissing.wallIdx, hitMissing.missIdx);
                        return;
                    }
                }

for (let i = room.doors.length - 1; i >= 0; i--) {
                    const door = room.doors[i];
                    const dist = Math.sqrt(Math.pow(x - door.x, 2) + Math.pow(y - door.y, 2));
                    console.log(`  Door ${i}: position=(${door.x}, ${door.y}), distance=${dist.toFixed(2)}`);
                    if (dist < 50) {
                        if (e.shiftKey) {
                            // Delete with Shift+Click
                            console.log(`  ‚úì‚úì‚úì DOOR ${i} IS CLOSE ENOUGH (${dist.toFixed(2)} < 50) - DELETING NOW`);
                            room.doors.splice(i, 1);
                            console.log('  ‚úì‚úì‚úì DOOR DELETED');
                            showToast('üö™ Door deleted (Shift+Click)');
                            redraw2D();
                            updateStats();
                            return;
                        } else {
                            // Reposition with regular click
                            console.log(`  ‚úì OPENING POSITION EDITOR for Door ${i}`);
                            showPositionModal('door', i);
                            return;
                        }
                    }
                }
                
                // Check windows
                for (let i = room.windows.length - 1; i >= 0; i--) {
                    const win = room.windows[i];
                    const dist = Math.sqrt(Math.pow(x - win.x, 2) + Math.pow(y - win.y, 2));
                    console.log(`  Window ${i}: position=(${win.x}, ${win.y}), distance=${dist.toFixed(2)}`);
                    if (dist < 50) {
                        if (e.shiftKey) {
                            // Delete with Shift+Click
                            console.log(`  ‚úì‚úì‚úì WINDOW ${i} IS CLOSE ENOUGH (${dist.toFixed(2)} < 50) - DELETING NOW`);
                            room.windows.splice(i, 1);
                            console.log('  ‚úì‚úì‚úì WINDOW DELETED');
                            showToast('ü™ü Window deleted (Shift+Click)');
                            redraw2D();
                            updateStats();
                            return;
                        } else {
                            // Reposition with regular click
                            console.log(`  ‚úì OPENING POSITION EDITOR for Window ${i}`);
                            showPositionModal('window', i);
                            return;
                        }
                    }
                }
                
                console.log('‚úó No door/window close enough to click point');
                return; // Exit - didn't click on anything
            }
            
            // MODE 2A: DRAW NEW WALLS (Wall tool active, no feature selected)
            if (state.wallSelectionMode && !state.currentFeature) {
                console.log('‚úì IN WALL DRAWING MODE - Drawing new wall');
                
                const room = getCurrentRoom();
                if (!room) {
                    showToast('‚ö†Ô∏è Please select a room first');
                    return;
                }
                
                // AUTO-CREATE NEW ROOM: If current room has walls and user is starting fresh (no corners placed)
                if (room.walls && room.walls.length > 0 && state.wallDrawingCorners.length === 0) {
                    console.log('üè† Current room has walls - creating new room for next drawing');
                    
                    // Create new room
                    const newRoomNumber = state.rooms.length + 1;
                    state.rooms.push({
                        name: `Room ${newRoomNumber}`,
                        floorPoints: [],
                        walls: [],
                        ceilingHeight: 8.0,
                        wallThickness: state.currentWallThickness || 4,
                        doors: [],
                        windows: [],
                        damageMarkers: [],
                        openings: [],
                        positionX: state.rooms.length * 30,
                        positionZ: 0
                    });
                    
                    // Switch to new room
                    state.currentRoomIndex = state.rooms.length - 1;
                    updateRoomList();
                    
                    showToast(`‚úÖ Created "Room ${newRoomNumber}" - Drawing here now`, 3000);
                    console.log(`‚úÖ Switched to Room ${newRoomNumber}`);
                }
                
                // Initialize wall drawing corners array if needed
                if (!state.wallDrawingCorners) {
                    state.wallDrawingCorners = [];
                }
                
                // Calculate actual world coordinates
                let cornerX = x;
                let cornerY = y;
                
                // Apply ortho mode if enabled
                if (state.orthoMode && state.wallDrawingCorners.length > 0) {
                    const lastCorner = state.wallDrawingCorners[state.wallDrawingCorners.length - 1];
                    const dx = Math.abs(x - lastCorner.x);
                    const dy = Math.abs(y - lastCorner.y);
                    
                    // Snap to horizontal or vertical
                    if (dx > dy) {
                        // Make horizontal
                        cornerY = lastCorner.y;
                    } else {
                        // Make vertical
                        cornerX = lastCorner.x;
                    }
                }
                
                // Add corner to sequence
                // Check if we should close the room (only if we have 3+ corners and click near first)
                let shouldClose = false;
                
                if (state.wallDrawingCorners.length >= 3) {
                    const firstCorner = state.wallDrawingCorners[0];
                    const distToFirst = Math.sqrt(
                        Math.pow(cornerX - firstCorner.x, 2) + 
                        Math.pow(cornerY - firstCorner.y, 2)
                    );
                    
                    const CLOSE_THRESHOLD = 30; // 30 pixels
                    shouldClose = distToFirst < CLOSE_THRESHOLD;
                }
                
                if (shouldClose) {
                    // DON'T ADD A NEW CORNER - the room closes back to the first corner automatically
                    console.log('‚úÖ CLOSING ROOM - Room will close back to first corner (no duplicate corner added)');
                    
                    // Close the room!
                    console.log('‚úÖ Creating room with', state.wallDrawingCorners.length, 'corners');
                    
                    saveStateForUndo();
                    
                    // Clear existing room
                    room.floorPoints = [];
                    room.walls = [];
                    
                    // Add all corners
                    state.wallDrawingCorners.forEach(corner => {
                        room.floorPoints.push({ 
                            x: corner.x, 
                            y: corner.y  // Use y as 2D canvas coordinate, not z
                        });
                    });
                    
                    // Create walls between sequential corners
                    for (let i = 0; i < room.floorPoints.length; i++) {
                        const start = room.floorPoints[i];
                        const end = room.floorPoints[(i + 1) % room.floorPoints.length];
                        
                        const dx = end.x - start.x;
                        const dy = end.y - start.y;  // Use y not z
                        const lengthPixels = Math.sqrt(dx * dx + dy * dy);
                        const lengthFeet = lengthPixels / 30;
                        
                        room.walls.push({
                            name: `Wall ${i + 1}`,
                            length: lengthFeet.toFixed(2),
                            start: { x: start.x, y: start.y },  // Use y not z
                            end: { x: end.x, y: end.y }  // Use y not z
                        });
                    }
                    
                    // WELD CORNERS - Fix tiny gaps at corners
                    const WELD_THRESHOLD = 0.1; // 0.1 feet = 1.2 inches
                    for (let i = 0; i < room.walls.length; i++) {
                        for (let j = i + 1; j < room.walls.length; j++) {
                            const wall1 = room.walls[i];
                            const wall2 = room.walls[j];
                            
                            // Check all endpoint combinations
                            const checks = [
                                { p1: wall1.start, p2: wall2.start },
                                { p1: wall1.start, p2: wall2.end },
                                { p1: wall1.end, p2: wall2.start },
                                { p1: wall1.end, p2: wall2.end }
                            ];
                            
                            checks.forEach(({ p1, p2 }) => {
                                const dx = p1.x - p2.x;
                                const dy = p1.y - p2.y;
                                const dist = Math.sqrt(dx * dx + dy * dy) / 30; // Convert to feet
                                
                                if (dist < WELD_THRESHOLD && dist > 0) {
                                    // Snap to average position
                                    const avgX = (p1.x + p2.x) / 2;
                                    const avgY = (p1.y + p2.y) / 2;
                                    p1.x = avgX;
                                    p1.y = avgY;
                                    p2.x = avgX;
                                    p2.y = avgY;
                                }
                            });
                        }
                    }
                    
                    // Recalculate wall lengths after welding
                    room.walls.forEach(wall => {
                        const dx = wall.end.x - wall.start.x;
                        const dy = wall.end.y - wall.start.y;
                        const lengthPixels = Math.sqrt(dx * dx + dy * dy);
                        const lengthFeet = lengthPixels / 30;
                        wall.length = lengthFeet.toFixed(2);
                    });
                    
                    // Clear wall drawing corners but KEEP wall mode active
                    state.wallDrawingCorners = [];
                    // state.wallSelectionMode stays TRUE - user can draw more walls!
                    console.log('‚úÖ Wall drawing corners cleared - ready for next wall');
                    
                    // Keep Wall button active
                    document.querySelectorAll('.toolbar-btn').forEach(btn => {
                        btn.classList.remove('toolbar-btn-active');
                    });
                    // Re-activate the wall button
                    const wallButtons = document.querySelectorAll('.toolbar-btn');
                    wallButtons.forEach(btn => {
                        if (btn.textContent.includes('Wall')) {
                            btn.classList.add('toolbar-btn-active');
                        }
                    });
                    
                    // Keep cursor as crosshair for continued drawing
                    const canvas = document.getElementById('canvas2D');
                    canvas.style.cursor = 'crosshair';
                    
                    const wallThickness = state.currentWallThickness || room.wallThickness || 4;
                    showToast(`‚úÖ Room created! Click anywhere to start next room`, 3000);
                    
                    // Update instruction banner for next wall
                    const banner = document.getElementById('instructionBanner');
                    if (banner) {
                        banner.textContent = `üìè WALL MODE (${wallThickness}") - Click to create & draw next room`;
                        banner.style.display = 'block';
                        banner.style.background = '#2196F3';
                        banner.style.color = 'white';
                    }
                    
                    // Auto-zoom to fit the new room
                    setTimeout(() => {
                        if (typeof window.zoomAll === 'function') {
                            window.zoomAll();
                        }
                    }, 100);
                    
                    // Redraw
                    redraw2D();
                    if (state.currentView === '3d') render3D();
                    updateStats();
                    
                } else {
                    // Continue adding corners - ADD THE CORNER
                    state.wallDrawingCorners.push({ x: cornerX, y: cornerY });
                    console.log(`‚úì Corner ${state.wallDrawingCorners.length} added at:`, cornerX, cornerY);
                    
                    const nextNum = state.wallDrawingCorners.length + 1;
                    
                    // Update banner
                    const banner = document.getElementById('instructionBanner');
                    if (banner) {
                        if (state.wallDrawingCorners.length < 3) {
                            banner.textContent = `üìè WALL MODE - Click corner #${nextNum} (need at least 3)`;
                        } else {
                            banner.textContent = `üìè WALL MODE - Click corner #${nextNum} or click near start to close`;
                        }
                        banner.style.background = '#4CAF50';
                    }
                    
                    showToast(`‚úì Corner ${state.wallDrawingCorners.length} placed - ${state.wallDrawingCorners.length < 3 ? 'need ' + (3 - state.wallDrawingCorners.length) + ' more' : 'click near start to close'}`, 2000);
                    
                    redraw2D();
                }
                
                return; // Exit - handled wall drawing
            }
            
            // MODE 2B: Place door/window on wall
            if (state.wallSelectionMode && (state.currentFeature === 'door' || state.currentFeature === 'window' || state.currentFeature === 'opening')) {
                console.log('‚úì IN WALL SELECTION MODE - placing', state.currentFeature);
                
                // Find which wall was clicked and exact click point on wall
                // CHECK ALL POLYGON EDGES - including those marked as skip (shared walls)
                let clickedWall = null;
                let minDist = Infinity;
                let closestPoint = null;
                
                const numPoints = room.floorPoints.length;
                for (let i = 0; i < numPoints; i++) {
                    const p1 = room.floorPoints[i];
                    const p2 = room.floorPoints[(i + 1) % numPoints];
                    
                    const dist = distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                    console.log(`Edge ${i}: distance = ${dist.toFixed(1)} pixels`);
                    if (dist < 100 && dist < minDist) {  // Increased tolerance for easier clicking
                        minDist = dist;
                        
                        // Calculate closest point on the wall line
                        const A = x - p1.x;
                        const B = y - p1.y;
                        const C = p2.x - p1.x;
                        const D = p2.y - p1.y;
                        
                        const dot = A * C + B * D;
                        const lenSq = C * C + D * D;
                        let param = -1;
                        if (lenSq !== 0) param = dot / lenSq;
                        
                        // Clamp to wall segment
                        param = Math.max(0, Math.min(1, param));
                        
                        const pointX = p1.x + param * C;
                        const pointY = p1.y + param * D;
                        
                        // Calculate distance from start of wall in feet
                        const wallLength = Math.sqrt(C * C + D * D);
                        const distanceFromStart = Math.sqrt(
                            Math.pow(pointX - p1.x, 2) + 
                            Math.pow(pointY - p1.y, 2)
                        );
                        const distanceInFeet = (distanceFromStart / 30) * 1; // 30 pixels = 1 foot scale
                        
                        // Create a compatible wall object for backward compatibility
                        const wallObj = {
                            start: p1,
                            end: p2,
                            name: `Edge ${i}`
                        };
                        
                        clickedWall = { wall: wallObj, index: i };
                        closestPoint = { 
                            x: pointX, 
                            y: pointY,
                            distanceFromStart: distanceInFeet
                        };
                    }
                }
                
                if (clickedWall && closestPoint) {
                    console.log('‚úÖ‚úÖ‚úÖ WALL FOUND! Wall index:', clickedWall.index, 'Distance:', minDist.toFixed(1), 'px');
                    
                    // DIAGNOSTIC: Flash screen orange to show wall was found
                    document.body.style.backgroundColor = '#FFA500';
                    setTimeout(() => { document.body.style.backgroundColor = ''; }, 200);
                    
                    state.selectedWall = clickedWall.index;
                    state.clickPoint = closestPoint;
                    if (state.currentFeature === 'missing-wall') {
                        // Missing wall uses its own modal
                        showMissingWallModal();
                        // keep edit mode after opening modal
                        state.wallSelectionMode = false;
                        updateModeIndicator();
                    } else {
                        showPlacementDialog();
                    }
                } else {
                    const closestDist = minDist === Infinity ? 'far away' : `${minDist.toFixed(0)}px away`;
                    showToast(`‚ùå Tap closer to a wall (closest: ${closestDist}, need <100px)`);
                    console.log('‚ùå No wall close enough. Closest distance:', minDist);
                }
                return;
            }
            // MODE 2b: Add Missing Wall segment on a wall (Xactimate-style)
            if (state.wallSelectionMode && state.currentFeature === 'missing-wall') {
                console.log('‚úì IN WALL SELECTION MODE - missing wall');

                // Find which wall was clicked
                // CHECK ALL POLYGON EDGES - including those marked as skip (shared walls)
                let clickedWall = null;
                let minDist = Infinity;

                const numPoints = room.floorPoints.length;
                for (let i = 0; i < numPoints; i++) {
                    const p1 = room.floorPoints[i];
                    const p2 = room.floorPoints[(i + 1) % numPoints];
                    
                    const dist = distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                    console.log(`Edge ${i}: distance = ${dist}`);
                    if (dist < 60 && dist < minDist) {  // Increased tolerance for easier clicking
                        minDist = dist;
                        
                        // Create a compatible wall object for backward compatibility
                        const wallObj = {
                            start: p1,
                            end: p2,
                            name: `Edge ${i}`
                        };
                        
                        clickedWall = { wall: wallObj, index: i };
                    }
                }

                if (!clickedWall) {
                    showToast('‚ùå Click on a wall');
                    return;
                }

                // Select this wall, open modal, and exit selection mode
                state.selectedWall = clickedWall.index;
                showMissingWallModal();

                state.currentFeature = null;
                state.wallSelectionMode = false;
                document.querySelectorAll('.feature-btn').forEach(b => b.classList.remove('active'));
                document.getElementById('instructionBanner').classList.remove('active');
                redraw2D();
                return;
            }

            
            // MODE 3: Place damage marker (anywhere on floor)
            if (state.currentFeature && state.currentFeature.includes('damage')) {
                console.log('‚úì IN DAMAGE MARKER MODE - placing', state.currentFeature);
                room.damageMarkers.push({
                    type: state.currentFeature,
                    x: x - 50,
                    y: y - 50,
                    width: 100,
                    height: 100
                });
                showToast('‚ö†Ô∏è Damage marked');
                state.currentFeature = null;
                state.wallSelectionMode = false;
                document.querySelectorAll('.feature-btn').forEach(b => b.classList.remove('active'));
                document.getElementById('instructionBanner').classList.remove('active');
                redraw2D();
                updateStats();
            }
        }
        
        // Add click event listener
        canvas2D.addEventListener('click', handleWallClick);

        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) param = dot / lenSq;
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function updatePositionPreview() {
            const room = getCurrentRoom();
            if (!room || state.selectedWall === null) return;
            
            const wall = room.walls[state.selectedWall];
            const wallLength = parseFloat(wall.length);
            const widthInput = parseFloat(document.getElementById('featureWidth').value) || 3.0;
            
            // Handle width differently for openings (feet) vs doors/windows (inches)
            let widthFt;
            if (state.currentFeature === 'opening') {
                widthFt = widthInput; // Already in feet for openings
            } else {
                widthFt = widthInput / 12; // Convert inches to feet for doors/windows
            }
            
            const distanceFromCorner = parseFloat(document.getElementById('distanceFromCorner').value) || 0;
            const reference = document.getElementById('positionReference').value;
            
            let leftEdgePosition;
            if (reference === 'left') {
                leftEdgePosition = distanceFromCorner;
            } else {
                // From right corner
                leftEdgePosition = wallLength - distanceFromCorner - widthFt;
            }
            
            const rightEdgePosition = leftEdgePosition + widthFt;
            const centerPosition = leftEdgePosition + widthFt / 2;
            
            // Validation
            let previewText = '';
            if (leftEdgePosition < 0 || rightEdgePosition > wallLength) {
                previewText = '‚ö†Ô∏è Warning: Feature extends beyond wall!';
                document.getElementById('positionPreview').style.color = '#d32f2f';
            } else {
                previewText = `‚úì Left edge: ${leftEdgePosition.toFixed(1)} ft | Center: ${centerPosition.toFixed(1)} ft | Right edge: ${rightEdgePosition.toFixed(1)} ft`;
                document.getElementById('positionPreview').style.color = '#2e7d32';
            }
            
            document.getElementById('positionPreview').textContent = previewText;
        }

        function showPlacementDialog() {
            const dialog = document.getElementById('placementDialog');
            const title = document.getElementById('dialogTitle');
            const heightField = document.getElementById('heightField');
            
            if (!dialog) {
                console.error('‚ùå placementDialog element not found!');
                showToast('‚ö†Ô∏è Error: Dialog not found. Please refresh.');
                return;
            }
            
            if (!title || !heightField) {
                console.error('‚ùå Dialog sub-elements not found!', {title, heightField});
                showToast('‚ö†Ô∏è Error: Dialog elements missing. Please refresh.');
                return;
            }
            
            // Get wall info for positioning
            const room = getCurrentRoom();
            const wall = room.walls[state.selectedWall];
            const wallLength = parseFloat(wall.length);
            const clickDistance = state.clickPoint ? state.clickPoint.distanceFromStart : 0;
            
            // Update wall length display
            document.getElementById('wallLengthInfo').textContent = `Wall length: ${wallLength.toFixed(1)} ft`;
            
            if (state.currentFeature === 'door') {
                title.textContent = 'Add Door';
                document.getElementById('featureWidth').value = 36; // 3.0 feet
                document.getElementById('featureWidth').step = 1; // Inches
                document.getElementById('featureWidth').min = 12;
                document.getElementById('featureWidth').max = 120;
                document.getElementById('featureHeight').value = 80; // 6'8" standard height
                heightField.style.display = 'block';
                document.getElementById('heightFieldLabel').textContent = 'Height (inches)';
                document.getElementById('heightHelpText').textContent = 'Standard door: 80" (6\'8")';
                
                // Reset width field label to inches for doors
                const widthLabel = document.querySelector('label[for="featureWidth"]') || 
                                   document.querySelector('.dialog-field label');
                if (widthLabel) {
                    widthLabel.textContent = 'Width (inches)';
                }
                
                const windowHeightField = document.getElementById('windowHeightField');
                if (windowHeightField) windowHeightField.style.display = 'none';
                
                // Set initial position from click
                const doorWidthFt = 36 / 12; // 3 feet
                const clickedCenter = clickDistance;
                const leftEdge = Math.max(0, clickedCenter - doorWidthFt / 2);
                document.getElementById('distanceFromCorner').value = leftEdge.toFixed(1);
                document.getElementById('positionReference').value = 'left';
                
            } else if (state.currentFeature === 'window') {
                title.textContent = 'Add Window';
                document.getElementById('featureWidth').value = 36; // 3.0 feet width
                document.getElementById('featureWidth').step = 1; // Inches
                document.getElementById('featureWidth').min = 12;
                document.getElementById('featureWidth').max = 120;
                document.getElementById('featureWindowHeight').value = 36; // 3.0 feet height
                document.getElementById('featureHeight').value = 3.0; // 3.0 feet from floor
                heightField.style.display = 'block';
                document.getElementById('heightFieldLabel').textContent = 'Height from Floor (feet)';
                document.getElementById('heightHelpText').textContent = 'Enter 0 for floor-level windows';
                
                // Reset width field label to inches for windows
                const widthLabel = document.querySelector('label[for="featureWidth"]') || 
                                   document.querySelector('.dialog-field label');
                if (widthLabel) {
                    widthLabel.textContent = 'Width (inches)';
                }
                
                const windowHeightField = document.getElementById('windowHeightField');
                if (windowHeightField) windowHeightField.style.display = 'block';
                
                // Set initial position from click
                const windowWidthFt = 36 / 12; // 3 feet
                const clickedCenter = clickDistance;
                const leftEdge = Math.max(0, clickedCenter - windowWidthFt / 2);
                document.getElementById('distanceFromCorner').value = leftEdge.toFixed(1);
                document.getElementById('positionReference').value = 'left';
                
            } else if (state.currentFeature === 'opening') {
                title.textContent = 'Add Opening / Passage';
                document.getElementById('featureWidth').value = 3.0; // 3.0 feet default opening (changed to feet)
                document.getElementById('featureWidth').step = 0.5; // Better step for feet
                document.getElementById('featureWidth').min = 0.5;
                document.getElementById('featureWidth').max = 20;
                document.getElementById('featureHeight').value = 8.0; // 8 feet ceiling height (changed to feet)
                heightField.style.display = 'block';
                document.getElementById('heightFieldLabel').textContent = 'Height (feet)';
                document.getElementById('heightHelpText').textContent = 'Full height opening (floor to ceiling)';
                
                // Change width field label for openings
                const widthLabel = document.querySelector('label[for="featureWidth"]') || 
                                   document.querySelector('.dialog-field label');
                if (widthLabel && widthLabel.textContent === 'Width (inches)') {
                    widthLabel.setAttribute('data-original', 'Width (inches)');
                    widthLabel.textContent = 'Width (feet)';
                }
                
                const windowHeightField = document.getElementById('windowHeightField');
                if (windowHeightField) windowHeightField.style.display = 'none';
                
                // Set initial position from click
                const openingWidthFt = 3.0; // Now in feet
                const clickedCenter = clickDistance;
                const leftEdge = Math.max(0, clickedCenter - openingWidthFt / 2);
                document.getElementById('distanceFromCorner').value = leftEdge.toFixed(1);
                document.getElementById('positionReference').value = 'left';
            }
            
            updatePositionPreview();
            dialog.classList.add('active');
        }

        function cancelPlacement() {
            document.getElementById('placementDialog').classList.remove('active');
            document.getElementById('instructionBanner').classList.remove('active');
            state.wallSelectionMode = false;
            state.selectedWall = null;
            state.hoveredWall = null;
            state.clickPoint = null;
            state.currentFeature = null;
            document.querySelectorAll('.feature-btn').forEach(b => b.classList.remove('active'));
            updateModeIndicator();
            redraw2D();
        }

        function confirmPlacement() {
            const room = getCurrentRoom();
            if (!room || state.selectedWall === null) return;
            
            const wall = room.walls[state.selectedWall];
            
            // Handle width differently for openings (feet) vs doors/windows (inches)
            let widthFt;
            if (state.currentFeature === 'opening') {
                widthFt = parseFloat(document.getElementById('featureWidth').value); // Already in feet for openings
            } else {
                const width = parseFloat(document.getElementById('featureWidth').value);
                widthFt = width / 12; // Convert inches to feet for doors/windows
            }
            
            const heightFromFloor = state.currentFeature === 'window' ? 
                parseFloat(document.getElementById('featureHeight').value) || 0 : 0; // Allow 0 explicitly
            
            // Get positioning from user inputs
            const distanceFromCorner = parseFloat(document.getElementById('distanceFromCorner').value) || 0;
            const reference = document.getElementById('positionReference').value;
            const wallLength = parseFloat(wall.length);
            
            // Calculate left edge position based on reference
            let edgePosition;
            if (reference === 'left') {
                edgePosition = distanceFromCorner;
            } else {
                // From right corner
                edgePosition = wallLength - distanceFromCorner - widthFt;
            }
            
            // Validate and adjust if necessary
            if (edgePosition < 0 || (edgePosition + widthFt) > wallLength) {
                const adjustedEdge = Math.max(0, Math.min(edgePosition, wallLength - widthFt));
                showToast(`‚ö†Ô∏è Position adjusted to fit on wall`);
                edgePosition = adjustedEdge;
            }
            
            // Calculate center position for x, y coordinates
            const centerPosition = edgePosition + (widthFt / 2);
            const param = centerPosition / wallLength;
            
            // Calculate x, y coordinates at center position
            const wallDx = wall.end.x - wall.start.x;
            const wallDy = wall.end.y - wall.start.y;
            const x = wall.start.x + param * wallDx;
            const y = wall.start.y + param * wallDy;
            
            // Calculate rotation to match wall angle
            const rotation = Math.atan2(wallDy, wallDx) * 180 / Math.PI;
            
            if (state.currentFeature === 'door') {
                const width = parseFloat(document.getElementById('featureWidth').value); // Get inches for door
                const feature = {
                    x,
                    y,
                    width,
                    rotation,
                    wallIndex: state.selectedWall,
                    distanceFromLeft: edgePosition
                };
                feature.height = parseFloat(document.getElementById('featureHeight').value); // Store door height in inches
                feature.hinge = 'right'; // Default hinge side (right)
                feature.swingDirection = 'in'; // Default swing direction (into room)
                feature.doorType = 'single'; // Default door type
                room.doors.push(feature);
                showToast(`üö™ Door added - ${(width/12).toFixed(1)} ft wide at ${edgePosition.toFixed(1)} ft from left`);
            } else if (state.currentFeature === 'window') {
                const width = parseFloat(document.getElementById('featureWidth').value); // Get inches for window
                const feature = {
                    x,
                    y,
                    width,
                    rotation,
                    wallIndex: state.selectedWall,
                    distanceFromLeft: edgePosition
                };
                feature.heightFromFloor = heightFromFloor;
                feature.height = parseFloat(document.getElementById('featureWindowHeight').value); // Get window height from input
                feature.windowType = 'double-hung'; // Default window type
                room.windows.push(feature);
                showToast(`ü™ü Window added - ${(width/12).toFixed(1)} ft wide at ${edgePosition.toFixed(1)} ft from left`);
            } else if (state.currentFeature === 'opening') {
                // Add as wall cut/opening
                if (!wall.cuts) wall.cuts = [];
                const heightFeet = parseFloat(document.getElementById('featureHeight').value); // Now in feet
                wall.cuts.push({
                    startDist: edgePosition,
                    endDist: edgePosition + widthFt,
                    width: widthFt, // Width already in feet
                    height: heightFeet, // Already in feet
                    floorDistance: 0 // Opening goes from floor
                });
                showToast(`üîì Opening added - ${widthFt.toFixed(1)} ft wide √ó ${heightFeet.toFixed(1)} ft tall at ${edgePosition.toFixed(1)} ft from left`);
            }
            
            // Reset state
            document.getElementById('placementDialog').classList.remove('active');
            document.getElementById('instructionBanner').classList.remove('active');
            state.wallSelectionMode = false;
            state.selectedWall = null;
            state.hoveredWall = null;
            state.clickPoint = null;
            state.currentFeature = null;
            document.querySelectorAll('.feature-btn').forEach(b => b.classList.remove('active'));
            
            updateModeIndicator();
            redraw2D();
            updateStats();
        }

        function zoomIn() {
            state.zoom = Math.min(state.zoom * 1.2, 5);
            document.getElementById('zoomLevel').textContent = Math.round(state.zoom * 100) + '%';
            redraw2D();
        }

        function zoomOut() {
            state.zoom = Math.max(state.zoom / 1.2, 0.1);
            document.getElementById('zoomLevel').textContent = Math.round(state.zoom * 100) + '%';
            redraw2D();
        }

        function resetZoom() {
            state.zoom = 1;
            state.panX = 0;
            state.panY = 0;
            document.getElementById('zoomLevel').textContent = '100%';
            redraw2D();
        }


        function toggleShowAllRooms() {
            state.showAllRooms = document.getElementById('showAllRooms').checked;
            document.getElementById('allRoomsHelp').style.display = state.showAllRooms ? 'block' : 'none';
            
            if (state.showAllRooms) {
                // Calculate bounds of all rooms for auto-fitting
                zoomToFitAllRooms();
                showToast('üèòÔ∏è Showing all rooms - Click and drag to move');
            } else {
                resetZoom();
                showToast('üìê Showing single room');
            }
            
            redraw2D();
        }

        function zoomToFitAllRooms() {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            state.rooms.forEach(room => {
                if (room.floorPoints.length === 0) return;
                
                const offsetX = (room.positionX || 0) * 30;
                const offsetZ = (room.positionZ || 0) * 30;
                
                room.floorPoints.forEach(p => {
                    minX = Math.min(minX, p.x + offsetX);
                    maxX = Math.max(maxX, p.x + offsetX);
                    minY = Math.min(minY, p.y + offsetZ);
                    maxY = Math.max(maxY, p.y + offsetZ);
                });
            });
            
            if (minX === Infinity) {
                resetZoom();
                return;
            }
            
            // Add padding
            const width = maxX - minX;
            const height = maxY - minY;
            const padding = Math.max(width, height) * 0.15;
            
            minX -= padding;
            maxX += padding;
            minY -= padding;
            maxY += padding;
            
            // Calculate zoom
            const canvasWidth = canvas2D.width;
            const canvasHeight = canvas2D.height;
            const totalWidth = maxX - minX;
            const totalHeight = maxY - minY;
            
            const zoomX = canvasWidth / totalWidth;
            const zoomY = canvasHeight / totalHeight;
            state.zoom = Math.min(zoomX, zoomY, 2);
            
            // Center view
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            state.panX = canvasWidth / 2 - centerX * state.zoom;
            state.panY = canvasHeight / 2 - centerY * state.zoom;
            
            document.getElementById('zoomLevel').textContent = Math.round(state.zoom * 100) + '%';
        }

        function drawSingleRoom(room, offsetX, offsetZ, isCurrentRoom) {
            // Safety check - room must have floorPoints
            // Don't warn if we're actively drawing walls (corners are in wallDrawingCorners, not floorPoints yet)
            if (!room || !room.floorPoints || room.floorPoints.length < 3) {
                // Only warn if this is a finalized room (not actively being drawn)
                const isActivelyDrawing = isCurrentRoom && state.wallDrawingCorners && state.wallDrawingCorners.length > 0;
                if (!isActivelyDrawing && room.floorPoints && room.floorPoints.length > 0) {
                    console.warn('‚ö†Ô∏è Room has insufficient points:', room.name, 'Points:', room.floorPoints.length);
                }
                return;
            }
            
            // Get shared edges info (which edges to skip because another room will draw them)
            const roomsOnCurrentLevel = state.rooms.filter(r => r.level === state.currentLevel);
            const sharedInfo = getSharedEdgesInfo(room, roomsOnCurrentLevel);
            
            ctx.save();
            
            // Apply room offset for multi-room view
            if (state.showAllRooms) {
                ctx.translate(offsetX, offsetZ);
            }
            
            // Draw floor (light blue like reference image)
            ctx.fillStyle = isCurrentRoom ? 'rgba(180, 210, 240, 0.4)' : 'rgba(240, 240, 240, 0.3)';
            ctx.beginPath();
            ctx.moveTo(room.floorPoints[0].x, room.floorPoints[0].y);
            room.floorPoints.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.fill();
            
            // CONSISTENT WALL THICKNESS - Use room's wall thickness
            const wallThicknessInches = room.wallThickness || 4;
            const wallThicknessFeet = wallThicknessInches / 12;
            const WALL_THICKNESS = wallThicknessFeet * 30; // Convert to pixels (30px per foot)
            
            // Determine polygon winding order (clockwise or counter-clockwise)
            let signedArea = 0;
            for (let i = 0; i < room.floorPoints.length; i++) {
                const curr = room.floorPoints[i];
                const next = room.floorPoints[(i + 1) % room.floorPoints.length];
                signedArea += (next.x - curr.x) * (next.y + curr.y);
            }
            const isClockwise = signedArea > 0;
            const offsetDirection = isClockwise ? 1 : -1; // Inward direction
            
            // Draw walls as TWO DISTINCT parallel lines (outer and inner edge)
            const numPoints = room.floorPoints.length;
            
            // Calculate inner polygon by finding intersections of offset lines
            const innerPoints = [];
            
            // Create offset lines for each wall
            const offsetLines = [];
            for (let i = 0; i < numPoints; i++) {
                const curr = room.floorPoints[i];
                const next = room.floorPoints[(i + 1) % numPoints];
                
                const dx = next.x - curr.x;
                const dy = next.y - curr.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                
                // Perpendicular offset (inward)
                const perpX = (-dy / len) * offsetDirection * WALL_THICKNESS;
                const perpY = (dx / len) * offsetDirection * WALL_THICKNESS;
                
                offsetLines.push({
                    p1: { x: curr.x + perpX, y: curr.y + perpY },
                    p2: { x: next.x + perpX, y: next.y + perpY }
                });
            }
            
            // Find intersection points between adjacent offset lines
            for (let i = 0; i < numPoints; i++) {
                const line1 = offsetLines[(i - 1 + numPoints) % numPoints];
                const line2 = offsetLines[i];
                
                // Line 1: from line1.p1 to line1.p2
                // Line 2: from line2.p1 to line2.p2
                // Find where they intersect
                
                const x1 = line1.p1.x, y1 = line1.p1.y;
                const x2 = line1.p2.x, y2 = line1.p2.y;
                const x3 = line2.p1.x, y3 = line2.p1.y;
                const x4 = line2.p2.x, y4 = line2.p2.y;
                
                const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                
                if (Math.abs(denom) > 0.001) {
                    // Lines intersect
                    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
                    
                    innerPoints.push({
                        x: x1 + t * (x2 - x1),
                        y: y1 + t * (y2 - y1)
                    });
                } else {
                    // Lines are parallel - use line2.p1 as fallback
                    innerPoints.push({ x: line2.p1.x, y: line2.p1.y });
                }
            }
            
            // Draw walls - segment by segment, checking for shared edges
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3.0 / state.zoom;
            ctx.setLineDash([]);
            
            for (let i = 0; i < numPoints; i++) {
                // Skip this edge if another room (with lower index) will draw it
                if (sharedInfo.skip.has(i)) {
                    continue;
                }
                
                const p1 = room.floorPoints[i];
                const p2 = room.floorPoints[(i + 1) % numPoints];
                const inner1 = innerPoints[i];
                const inner2 = innerPoints[(i + 1) % numPoints];
                
                // Check if this is a shared wall (this room draws it, but other room skips)
                const isSharedWall = sharedInfo.single.has(i);
                
                if (isSharedWall) {
                    // SHARED WALL: Draw single center line only
                    const centerX1 = (p1.x + inner1.x) / 2;
                    const centerY1 = (p1.y + inner1.y) / 2;
                    const centerX2 = (p2.x + inner2.x) / 2;
                    const centerY2 = (p2.y + inner2.y) / 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX1, centerY1);
                    ctx.lineTo(centerX2, centerY2);
                    ctx.stroke();
                } else {
                    // NORMAL WALL: Draw both outer and inner edges
                    // Draw outer edge
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                    
                    // Draw inner edge
                    ctx.beginPath();
                    ctx.moveTo(inner1.x, inner1.y);
                    ctx.lineTo(inner2.x, inner2.y);
                    ctx.stroke();
                    
                    // Connect ends at corners (only if adjacent edges aren't skipped)
                    const prevSkipped = sharedInfo.skip.has((i - 1 + numPoints) % numPoints);
                    const nextSkipped = sharedInfo.skip.has((i + 1) % numPoints);
                    
                    if (!prevSkipped) {
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(inner1.x, inner1.y);
                        ctx.stroke();
                    }
                    
                    if (!nextSkipped) {
                        ctx.beginPath();
                        ctx.moveTo(p2.x, p2.y);
                        ctx.lineTo(inner2.x, inner2.y);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw dimension labels on each wall
            if (room.walls && room.walls.length > 0) {
                room.walls.forEach((wall, idx) => {
                    const midX = (wall.start.x + wall.end.x) / 2;
                    const midY = (wall.start.y + wall.end.y) / 2;
                    
                    // Calculate wall angle for label orientation
                    const dx = wall.end.x - wall.start.x;
                    const dy = wall.end.y - wall.start.y;
                    const perpX = -dy / Math.sqrt(dx * dx + dy * dy) * 15;
                    const perpY = dx / Math.sqrt(dx * dx + dy * dy) * 15;
                    
                    // Position label outside the wall
                    const labelX = midX + perpX;
                    const labelY = midY + perpY;
                    
                    const labelText = wall.length + ' ft';
                    ctx.font = `bold ${11 / state.zoom}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const metrics = ctx.measureText(labelText);
                    const padding = 3 / state.zoom;
                    
                    // Draw label background
                    ctx.fillStyle = 'rgba(30, 60, 114, 0.9)';
                    ctx.fillRect(
                        labelX - metrics.width / 2 - padding,
                        labelY - 7 / state.zoom,
                        metrics.width + padding * 2,
                        14 / state.zoom
                    );
                    
                    // Draw label text
                    ctx.fillStyle = '#FFF';
                    ctx.fillText(labelText, labelX, labelY);
                });
            }
            
            // Draw room label ALWAYS in center of room (clickable to activate handles)
            const centerX = room.floorPoints.reduce((sum, p) => sum + p.x, 0) / room.floorPoints.length;
            const centerY = room.floorPoints.reduce((sum, p) => sum + p.y, 0) / room.floorPoints.length;
            
            // Make room name prominent and clickable
            ctx.font = `bold ${20 / state.zoom}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Background for text (makes it more readable and clickable)
            const metrics = ctx.measureText(room.name);
            const padding = 8 / state.zoom;
            const boxWidth = metrics.width + padding * 2;
            const boxHeight = 28 / state.zoom;
            
            // Draw background box
            ctx.fillStyle = isCurrentRoom ? 'rgba(30, 60, 114, 0.9)' : 'rgba(100, 100, 100, 0.8)';
            ctx.fillRect(
                centerX - boxWidth / 2,
                centerY - boxHeight / 2,
                boxWidth,
                boxHeight
            );
            
            // Draw text
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(room.name, centerX, centerY);
            
            // Store room name bounds for click detection
            if (!room.nameBounds) room.nameBounds = {};
            room.nameBounds.x = centerX;
            room.nameBounds.y = centerY;
            room.nameBounds.width = boxWidth;
            room.nameBounds.height = boxHeight;
            
            // Draw walls with labels (show cuts as gaps)
            room.walls.forEach((wall, wallIdx) => {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 4 / state.zoom;
                
                const wallCuts = [
                    ...(wall.cuts || []).map(c => ({...c, isOpening: false})), 
                    ...(wall.missingWalls || []).map(mw => ({...mw, isOpening: true}))
                ];
                const wallLength = parseFloat(wall.length);
                const scale = 30; // pixels per foot
                
                if (wallCuts.length === 0) {
                    // No cuts - wall is already shown by floor perimeter double-line
                    // Skip drawing to avoid redundancy
                } else {
                    // Draw wall in segments, skipping cut portions
                    const dx = wall.end.x - wall.start.x;
                    const dy = wall.end.y - wall.start.y;
                    const wallPixelLength = Math.sqrt(dx * dx + dy * dy);
                    const unitX = dx / wallPixelLength;
                    const unitY = dy / wallPixelLength;
                    const perpX = -unitY;
                    const perpY = unitX;
                    
                    // Sort cuts by start distance
                    wallCuts.sort((a, b) => a.startDist - b.startDist);
                    
                    // Erase the double-line perimeter at cut locations
                    wallCuts.forEach(cut => {
                        const startPixel = cut.startDist * scale;
                        const endPixel = cut.endDist * scale;
                        
                        // Overdraw with background color to create gap
                        ctx.strokeStyle = '#f5f5f5'; // Match canvas background
                        ctx.lineWidth = 15 / state.zoom; // Wide enough to cover both lines
                        ctx.setLineDash([]);
                        
                        ctx.beginPath();
                        ctx.moveTo(
                            wall.start.x + unitX * startPixel,
                            wall.start.y + unitY * startPixel
                        );
                        ctx.lineTo(
                            wall.start.x + unitX * endPixel,
                            wall.start.y + unitY * endPixel
                        );
                        ctx.stroke();
                    });
                    
                    // Reset for markers
                    let currentPos = 0; // in feet
                    
                    // Draw red markers at cut locations
                    ctx.strokeStyle = '#FF0000';
                    ctx.lineWidth = 3 / state.zoom;
                    ctx.setLineDash([5 / state.zoom, 5 / state.zoom]);
                    
                    wallCuts.forEach(cut => {
                        const startPixel = cut.startDist * scale;
                        const endPixel = cut.endDist * scale;
                        const midPixel = (startPixel + endPixel) / 2;
                        
                        // Draw perpendicular markers
                        const perpX = -unitY * 15 / state.zoom;
                        const perpY = unitX * 15 / state.zoom;
                        
                        // Start marker
                        ctx.beginPath();
                        ctx.moveTo(
                            wall.start.x + unitX * startPixel,
                            wall.start.y + unitY * startPixel
                        );
                        ctx.lineTo(
                            wall.start.x + unitX * startPixel + perpX,
                            wall.start.y + unitY * startPixel + perpY
                        );
                        ctx.stroke();
                        
                        // End marker
                        ctx.beginPath();
                        ctx.moveTo(
                            wall.start.x + unitX * endPixel,
                            wall.start.y + unitY * endPixel
                        );
                        ctx.lineTo(
                            wall.start.x + unitX * endPixel + perpX,
                            wall.start.y + unitY * endPixel + perpY
                        );
                        ctx.stroke();
                        
                        // Check if this is a missingWall (opening) or a regular cut
                        const isMissingWall = cut.isOpening === true;
                        
                        if (isMissingWall) {
                            // OPENING - Show dimension label in colored box (like doors/windows)
                            const openingWidthFeet = cut.endDist - cut.startDist;
                            const openingFeet = Math.floor(openingWidthFeet);
                            const openingInches = Math.round((openingWidthFeet - openingFeet) * 12);
                            const dimensionText = openingInches > 0 
                                ? `${openingFeet}' ${openingInches}"` 
                                : `${openingFeet}'`;
                            
                            ctx.save();
                            ctx.setLineDash([]);
                            ctx.font = `bold ${11 / state.zoom}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            // Position label
                            const centerX = wall.start.x + unitX * midPixel;
                            const centerY = wall.start.y + unitY * midPixel;
                            const labelOffsetX = perpX * 1.8; // Offset perpendicular to wall
                            const labelOffsetY = perpY * 1.8;
                            
                            // Draw background box
                            const metrics = ctx.measureText(dimensionText);
                            const boxPadding = 3 / state.zoom;
                            const boxWidth = metrics.width + boxPadding * 2;
                            const boxHeight = 14 / state.zoom;
                            
                            ctx.fillStyle = 'rgba(192, 57, 43, 0.95)'; // Red background for openings
                            ctx.fillRect(
                                centerX + labelOffsetX - boxWidth / 2,
                                centerY + labelOffsetY - boxHeight / 2,
                                boxWidth,
                                boxHeight
                            );
                            
                            // Draw text
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillText(dimensionText, centerX + labelOffsetX, centerY + labelOffsetY);
                            
                            // ALSO DRAW ON DIMENSION LINE - TEST
                            const dimOffset = 50 / state.zoom;
                            const dimX = centerX + perpX * dimOffset;
                            const dimY = centerY + perpY * dimOffset;
                            
                            ctx.fillStyle = 'rgba(255, 0, 0, 0.95)';
                            ctx.fillRect(dimX - boxWidth/2, dimY - boxHeight/2, boxWidth, boxHeight);
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillText(dimensionText, dimX, dimY);
                            
                            ctx.restore();
                        } else {
                            // REGULAR CUT - Show "CUT" label  
                            ctx.save();
                            ctx.translate(
                                wall.start.x + unitX * midPixel,
                                wall.start.y + unitY * midPixel
                            );
                            ctx.rotate(Math.atan2(dy, dx));
                            ctx.setLineDash([]);
                            ctx.fillStyle = '#FF0000';
                            ctx.font = `bold ${10 / state.zoom}px Arial`;
                            ctx.textAlign = 'center';
                            // Show cut label + cut length dimension
                            const cutLenFt = (cut.endDist - cut.startDist);
                            ctx.fillText('CUT', 0, -8 / state.zoom);
                            ctx.font = `bold ${9 / state.zoom}px Arial`;
                            ctx.fillText(`${cutLenFt.toFixed(2)}'`, 0, 6 / state.zoom);
                            ctx.restore();
                        }
                    });
                    
                    ctx.setLineDash([]);
                    ctx.strokeStyle = '#333';
                    
                    // ADD RUNNING DIMENSIONS HERE - using the SAME wallCuts that just drew successfully
                    if (wallCuts.some(c => c.isOpening)) {
                        const offset = 50 / state.zoom;
                        
                        // Build segments
                        const segments = [];
                        let pos = 0;
                        
                        wallCuts.forEach(cut => {
                            if (cut.startDist > pos) {
                                segments.push({ start: pos, end: cut.startDist, type: 'wall' });
                            }
                            segments.push({ 
                                start: cut.startDist, 
                                end: cut.endDist, 
                                type: cut.isOpening ? 'opening' : 'cut'
                            });
                            pos = cut.endDist;
                        });
                        
                        if (pos < wallLength) {
                            segments.push({ start: pos, end: wallLength, type: 'wall' });
                        }
                        
                        // Draw dimension line
                        ctx.save();
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1 / state.zoom;
                        
                        const dimStart = {
                            x: wall.start.x + perpX * offset,
                            y: wall.start.y + perpY * offset
                        };
                        const dimEnd = {
                            x: wall.end.x + perpX * offset,
                            y: wall.end.y + perpY * offset
                        };
                        
                        ctx.beginPath();
                        ctx.moveTo(dimStart.x, dimStart.y);
                        ctx.lineTo(dimEnd.x, dimEnd.y);
                        ctx.stroke();
                        
                        // Ticks and labels
                        const tickSize = 8 / state.zoom;
                        const allPositions = [0, ...wallCuts.flatMap(c => [c.startDist, c.endDist]), wallLength];
                        const uniquePos = [...new Set(allPositions)].sort((a,b) => a-b);
                        
                        uniquePos.forEach(p => {
                            const px = p * scale;
                            const dimPt = {
                                x: wall.start.x + unitX * px + perpX * offset,
                                y: wall.start.y + unitY * px + perpY * offset
                            };
                            
                            ctx.beginPath();
                            ctx.moveTo(dimPt.x - perpX * tickSize, dimPt.y - perpY * tickSize);
                            ctx.lineTo(dimPt.x + perpX * tickSize, dimPt.y + perpY * tickSize);
                            ctx.stroke();
                        });
                        
                        // Dimension labels
                        ctx.font = `bold ${11 / state.zoom}px Arial`;
                        ctx.textAlign = 'center';
                        
                        segments.forEach(seg => {
                            const len = seg.end - seg.start;
                            const mid = (seg.start + seg.end) / 2;
                            const midPx = mid * scale;
                            
                            const midPt = {
                                x: wall.start.x + unitX * midPx + perpX * offset,
                                y: wall.start.y + unitY * midPx + perpY * offset
                            };
                            
                            const ft = Math.floor(len);
                            const inch = Math.round((len - ft) * 12);
                            const txt = inch > 0 ? `${ft}' ${inch}"` : `${ft}'`;
                            
                            const m = ctx.measureText(txt);
                            const pad = 4 / state.zoom;
                            
                            ctx.fillStyle = seg.type === 'opening' ? 'rgba(255,0,0,0.95)' : 'white';
                            ctx.fillRect(midPt.x - m.width/2 - pad, midPt.y - 8/state.zoom, m.width + pad*2, 16/state.zoom);
                            
                            ctx.fillStyle = seg.type === 'opening' ? '#FFF' : '#000';
                            ctx.fillText(txt, midPt.x, midPt.y);
                        });
                        
                        ctx.restore();
                    }
                }
                
                // Calculate wall angle and midpoint
                const mx = (wall.start.x + wall.end.x) / 2;
                const my = (wall.start.y + wall.end.y) / 2;
                const dx = wall.end.x - wall.start.x;
                const dy = wall.end.y - wall.start.y;
                const angle = Math.atan2(dy, dx);
                
                // ON-WALL DIMENSION LABELS - DISABLED (using architectural dimensioning instead)
                if (false) {
                // Draw dimension text aligned with wall
                ctx.save();
                ctx.translate(mx, my);
                
                // Rotate text to align with wall
                // Keep text upright (don't let it be upside down)
                let textAngle = angle;
                if (Math.abs(angle) > Math.PI / 2) {
                    textAngle = angle + Math.PI;
                }
                ctx.rotate(textAngle);
                
                // CLEAN DIMENSION LABEL (like reference image)
                // Convert decimal feet to feet-inches format
                const wallLengthFeet = parseFloat(wall.length);
                const feet = Math.floor(wallLengthFeet);
                const inches = Math.round((wallLengthFeet - feet) * 12);
                let dimensionText;
                if (inches === 0) {
                    dimensionText = `${feet}'`;
                } else if (inches === 12) {
                    dimensionText = `${feet + 1}'`;
                } else {
                    dimensionText = `${feet}' ${inches}"`;
                }
                
                // Draw clean white background box
                ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
                ctx.font = `bold ${16 / state.zoom}px Arial`;  // Larger font
                const textWidth = ctx.measureText(dimensionText).width;
                const padding = 8 / state.zoom;  // More padding
                const boxHeight = 22 / state.zoom;  // Taller box
                ctx.fillRect(
                    -textWidth/2 - padding, 
                    -boxHeight/2, 
                    textWidth + padding * 2, 
                    boxHeight
                );
                
                // Draw subtle border
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1 / state.zoom;
                ctx.strokeRect(
                    -textWidth/2 - padding, 
                    -boxHeight/2, 
                    textWidth + padding * 2, 
                    boxHeight
                );
                
                // Draw dimension text
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(dimensionText, 0, 0);
                
                ctx.restore();
                }  // END on-wall labels disabled
            });
            
            
            
            // ============================================================================
            // RUNNING DIMENSIONS - FOR ALL FEATURES (DOORS, WINDOWS, OPENINGS, CUTS)
            // ============================================================================
            
            room.walls.forEach((wall, wallIdx) => {
                const wallLength = parseFloat(wall.length);
                if (wallLength <= 0) return;
                
                // Calculate wall geometry
                const dx = wall.end.x - wall.start.x;
                const dy = wall.end.y - wall.start.y;
                const wallPixelLength = Math.sqrt(dx * dx + dy * dy);
                const unitX = dx / wallPixelLength;
                const unitY = dy / wallPixelLength;
                const perpX = -unitY;
                const perpY = unitX;
                
                const offset = 50 / state.zoom;
                const scale = 30;
                
                // Collect ALL features on this wall
                const allFeatures = [];
                
                // Add cuts
                if (wall.cuts) {
                    wall.cuts.forEach(cut => {
                        allFeatures.push({
                            start: cut.startDist,
                            end: cut.endDist,
                            type: 'cut'
                        });
                    });
                }
                
                // Add openings (missingWalls)
                if (wall.missingWalls) {
                    wall.missingWalls.forEach(mw => {
                        allFeatures.push({
                            start: mw.startDist,
                            end: mw.endDist,
                            type: 'opening'
                        });
                    });
                }
                
                // Add doors
                if (room.doors) {
                    room.doors.forEach(door => {
                        if (door.wallIndex === wallIdx) {
                            allFeatures.push({
                                start: door.distanceFromLeft,
                                end: door.distanceFromLeft + (door.width / 12),
                                type: 'door'
                            });
                        }
                    });
                }
                
                // Add windows
                if (room.windows) {
                    room.windows.forEach(win => {
                        if (win.wallIndex === wallIdx) {
                            allFeatures.push({
                                start: win.distanceFromLeft,
                                end: win.distanceFromLeft + (win.width / 12),
                                type: 'window'
                            });
                        }
                    });
                }
                
                // Sort features
                allFeatures.sort((a, b) => a.start - b.start);
                
                // If no features, draw simple dimension
                if (allFeatures.length === 0) {
                    ctx.save();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1 / state.zoom;
                    ctx.font = `bold ${12 / state.zoom}px Arial`;
                    
                    const lineStart = {
                        x: wall.start.x + perpX * offset,
                        y: wall.start.y + perpY * offset
                    };
                    const lineEnd = {
                        x: wall.end.x + perpX * offset,
                        y: wall.end.y + perpY * offset
                    };
                    
                    ctx.beginPath();
                    ctx.moveTo(lineStart.x, lineStart.y);
                    ctx.lineTo(lineEnd.x, lineEnd.y);
                    ctx.stroke();
                    
                    const tickSize = 8 / state.zoom;
                    ctx.beginPath();
                    ctx.moveTo(lineStart.x - perpX * tickSize, lineStart.y - perpY * tickSize);
                    ctx.lineTo(lineStart.x + perpX * tickSize, lineStart.y + perpY * tickSize);
                    ctx.moveTo(lineEnd.x - perpX * tickSize, lineEnd.y - perpY * tickSize);
                    ctx.lineTo(lineEnd.x + perpX * tickSize, lineEnd.y + perpY * tickSize);
                    ctx.stroke();
                    
                    ctx.setLineDash([3 / state.zoom, 3 / state.zoom]);
                    ctx.strokeStyle = '#999';
                    ctx.beginPath();
                    ctx.moveTo(wall.start.x, wall.start.y);
                    ctx.lineTo(lineStart.x, lineStart.y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(wall.end.x, wall.end.y);
                    ctx.lineTo(lineEnd.x, lineEnd.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    const midX = (lineStart.x + lineEnd.x) / 2;
                    const midY = (lineStart.y + lineEnd.y) / 2;
                    
                    const ft = Math.floor(wallLength);
                    const inch = Math.round((wallLength - ft) * 12);
                    const txt = inch > 0 ? `${ft}' ${inch}"` : `${ft}'`;
                    
                    const m = ctx.measureText(txt);
                    const pad = 4 / state.zoom;
                    
                    ctx.fillStyle = 'white';
                    ctx.fillRect(midX - m.width/2 - pad, midY - 8/state.zoom, m.width + pad*2, 16/state.zoom);
                    
                    ctx.fillStyle = '#000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(txt, midX, midY);
                    
                    ctx.restore();
                    return;
                }
                
                // HAS FEATURES - Draw running dimensions
                ctx.save();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1 / state.zoom;
                ctx.font = `bold ${12 / state.zoom}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Build segments
                const segments = [];
                let pos = 0;
                
                allFeatures.forEach(feat => {
                    if (feat.start > pos) {
                        segments.push({ start: pos, end: feat.start, type: 'wall' });
                    }
                    segments.push({ start: feat.start, end: feat.end, type: feat.type });
                    pos = feat.end;
                });
                
                if (pos < wallLength) {
                    segments.push({ start: pos, end: wallLength, type: 'wall' });
                }
                
                // Draw dimension line
                const lineStart = {
                    x: wall.start.x + perpX * offset,
                    y: wall.start.y + perpY * offset
                };
                const lineEnd = {
                    x: wall.end.x + perpX * offset,
                    y: wall.end.y + perpY * offset
                };
                
                ctx.beginPath();
                ctx.moveTo(lineStart.x, lineStart.y);
                ctx.lineTo(lineEnd.x, lineEnd.y);
                ctx.stroke();
                
                // Draw witness lines and ticks
                const allPos = [0, ...allFeatures.flatMap(f => [f.start, f.end]), wallLength];
                const uniquePos = [...new Set(allPos)].sort((a, b) => a - b);
                const tickSize = 8 / state.zoom;
                
                uniquePos.forEach(p => {
                    const px = p * scale;
                    const wallPt = { x: wall.start.x + unitX * px, y: wall.start.y + unitY * px };
                    const dimPt = { x: wallPt.x + perpX * offset, y: wallPt.y + perpY * offset };
                    
                    // Tick
                    ctx.strokeStyle = '#000';
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(dimPt.x - perpX * tickSize, dimPt.y - perpY * tickSize);
                    ctx.lineTo(dimPt.x + perpX * tickSize, dimPt.y + perpY * tickSize);
                    ctx.stroke();
                    
                    // Witness line
                    ctx.setLineDash([3 / state.zoom, 3 / state.zoom]);
                    ctx.strokeStyle = '#999';
                    ctx.beginPath();
                    ctx.moveTo(wallPt.x, wallPt.y);
                    ctx.lineTo(dimPt.x, dimPt.y);
                    ctx.stroke();
                });
                
                ctx.setLineDash([]);
                
                // Draw labels
                segments.forEach(seg => {
                    const len = seg.end - seg.start;
                    const mid = (seg.start + seg.end) / 2;
                    const midPx = mid * scale;
                    
                    const dimPt = {
                        x: wall.start.x + unitX * midPx + perpX * offset,
                        y: wall.start.y + unitY * midPx + perpY * offset
                    };
                    
                    const ft = Math.floor(len);
                    const inch = Math.round((len - ft) * 12);
                    const txt = inch > 0 ? `${ft}' ${inch}"` : `${ft}'`;
                    
                    const m = ctx.measureText(txt);
                    const pad = 4 / state.zoom;
                    
                    // Color based on type
                    let bgColor, textColor;
                    if (seg.type === 'door') {
                        bgColor = 'rgba(76, 175, 80, 0.95)';
                        textColor = '#FFF';
                    } else if (seg.type === 'window') {
                        bgColor = 'rgba(33, 150, 243, 0.95)';
                        textColor = '#FFF';
                    } else if (seg.type === 'opening' || seg.type === 'cut') {
                        bgColor = 'rgba(192, 57, 43, 0.95)';
                        textColor = '#FFF';
                    } else {
                        bgColor = 'white';
                        textColor = '#000';
                    }
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(dimPt.x - m.width/2 - pad, dimPt.y - 8/state.zoom, m.width + pad*2, 16/state.zoom);
                    
                    ctx.fillStyle = textColor;
                    ctx.fillText(txt, dimPt.x, dimPt.y);
                });
                
                ctx.restore();
            });
            
            // ============================================================================
            // CORNER-TO-CORNER OFFSET DIMENSIONS - DISABLED
            // ============================================================================
            // This is also disabled to match the reference image style
            
            if (false) {  // DISABLED - no offset dimensions
            // Show horizontal offsets between adjacent room corners (e.g., Basement Bed 2 to Closet Bed 2)
            
            if (room.floorPoints.length >= 3 && state.showAllRooms) {
                // Work in absolute world coordinates (exit translated context temporarily)
                ctx.restore(); // End translated context
                ctx.save(); // Start fresh for dimensions
                
                let myMinX = Infinity, myMaxX = -Infinity;
                let myMinZ = Infinity, myMaxZ = -Infinity;
                
                room.floorPoints.forEach(p => {
                    myMinX = Math.min(myMinX, p.x);
                    myMaxX = Math.max(myMaxX, p.x);
                    myMinZ = Math.min(myMinZ, p.y);
                    myMaxZ = Math.max(myMaxZ, p.y);
                });
                
                const myOffsetX = (room.positionX || 0) * 30;
                const myOffsetZ = (room.positionZ || 0) * 30;
                const myLeftWorld = myMinX + myOffsetX;
                const myRightWorld = myMaxX + myOffsetX;
                const myTopWorld = myMinZ + myOffsetZ;
                const myBottomWorld = myMaxZ + myOffsetZ;
                
                state.rooms.forEach((otherRoom, otherIdx) => {
                    if (otherRoom === room || otherRoom.floorPoints.length < 3) return;
                    
                    let otherMinX = Infinity, otherMaxX = -Infinity;
                    let otherMinZ = Infinity, otherMaxZ = -Infinity;
                    
                    otherRoom.floorPoints.forEach(p => {
                        otherMinX = Math.min(otherMinX, p.x);
                        otherMaxX = Math.max(otherMaxX, p.x);
                        otherMinZ = Math.min(otherMinZ, p.y);
                        otherMaxZ = Math.max(otherMaxZ, p.y);
                    });
                    
                    const otherOffsetX = (otherRoom.positionX || 0) * 30;
                    const otherOffsetZ = (otherRoom.positionZ || 0) * 30;
                    const otherLeftWorld = otherMinX + otherOffsetX;
                    const otherRightWorld = otherMaxX + otherOffsetX;
                    const otherTopWorld = otherMinZ + otherOffsetZ;
                    const otherBottomWorld = otherMaxZ + otherOffsetZ;
                    
                    const tolerance = 10;
                    
                    // Room is ABOVE other room
                    if (Math.abs(myBottomWorld - otherTopWorld) < tolerance) {
                        if (otherRightWorld > myLeftWorld && otherLeftWorld < myRightWorld) {
                            ctx.save();
                            ctx.strokeStyle = '#000000'; // Black
                            ctx.lineWidth = 1.5 / state.zoom;
                            ctx.font = `bold ${10 / state.zoom}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            const y = myBottomWorld + 30 / state.zoom;
                            const tickSize = 8 / state.zoom;
                            const padding = 3 / state.zoom;
                            
                            // Left offset
                            if (myLeftWorld > otherLeftWorld + 5) {
                                const leftOffset = (myLeftWorld - otherLeftWorld) / 30;
                                
                                ctx.beginPath();
                                ctx.moveTo(otherLeftWorld, y);
                                ctx.lineTo(myLeftWorld, y);
                                ctx.stroke();
                                
                                ctx.beginPath();
                                ctx.moveTo(otherLeftWorld, y - tickSize);
                                ctx.lineTo(otherLeftWorld, y + tickSize);
                                ctx.moveTo(myLeftWorld, y - tickSize);
                                ctx.lineTo(myLeftWorld, y + tickSize);
                                ctx.stroke();
                                
                                ctx.setLineDash([2 / state.zoom, 2 / state.zoom]);
                                ctx.beginPath();
                                ctx.moveTo(otherLeftWorld, otherTopWorld);
                                ctx.lineTo(otherLeftWorld, y);
                                ctx.moveTo(myLeftWorld, myBottomWorld);
                                ctx.lineTo(myLeftWorld, y);
                                ctx.stroke();
                                ctx.setLineDash([]);
                                
                                const midX = (otherLeftWorld + myLeftWorld) / 2;
                                const labelText = toFeetInches(leftOffset);
                                const metrics = ctx.measureText(labelText);
                                
                                ctx.fillStyle = 'white';
                                ctx.fillRect(midX - metrics.width/2 - padding, y - 7/state.zoom, metrics.width + padding*2, 14/state.zoom);
                                
                                ctx.fillStyle = '#000000'; // Black text
                                ctx.fillText(labelText, midX, y);
                            }
                            
                            // Right offset
                            if (myRightWorld < otherRightWorld - 5) {
                                const rightOffset = (otherRightWorld - myRightWorld) / 30;
                                
                                ctx.beginPath();
                                ctx.moveTo(myRightWorld, y);
                                ctx.lineTo(otherRightWorld, y);
                                ctx.stroke();
                                
                                ctx.beginPath();
                                ctx.moveTo(myRightWorld, y - tickSize);
                                ctx.lineTo(myRightWorld, y + tickSize);
                                ctx.moveTo(otherRightWorld, y - tickSize);
                                ctx.lineTo(otherRightWorld, y + tickSize);
                                ctx.stroke();
                                
                                ctx.setLineDash([2 / state.zoom, 2 / state.zoom]);
                                ctx.beginPath();
                                ctx.moveTo(myRightWorld, myBottomWorld);
                                ctx.lineTo(myRightWorld, y);
                                ctx.moveTo(otherRightWorld, otherTopWorld);
                                ctx.lineTo(otherRightWorld, y);
                                ctx.stroke();
                                ctx.setLineDash([]);
                                
                                const midX = (myRightWorld + otherRightWorld) / 2;
                                const labelText = toFeetInches(rightOffset);
                                const metrics = ctx.measureText(labelText);
                                
                                ctx.fillStyle = 'white';
                                ctx.fillRect(midX - metrics.width/2 - padding, y - 7/state.zoom, metrics.width + padding*2, 14/state.zoom);
                                
                                ctx.fillStyle = '#000000'; // Black text
                                ctx.fillText(labelText, midX, y);
                            }
                            
                            ctx.restore();
                        }
                    }
                    
                    // Room is BELOW other room
                    if (Math.abs(myTopWorld - otherBottomWorld) < tolerance) {
                        if (otherRightWorld > myLeftWorld && otherLeftWorld < myRightWorld) {
                            ctx.save();
                            ctx.strokeStyle = '#000000'; // Black
                            ctx.lineWidth = 1.5 / state.zoom;
                            ctx.font = `bold ${10 / state.zoom}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            const y = myTopWorld - 30 / state.zoom;
                            const tickSize = 8 / state.zoom;
                            const padding = 3 / state.zoom;
                            
                            // Left offset
                            if (myLeftWorld > otherLeftWorld + 5) {
                                const leftOffset = (myLeftWorld - otherLeftWorld) / 30;
                                
                                ctx.beginPath();
                                ctx.moveTo(otherLeftWorld, y);
                                ctx.lineTo(myLeftWorld, y);
                                ctx.stroke();
                                
                                ctx.beginPath();
                                ctx.moveTo(otherLeftWorld, y - tickSize);
                                ctx.lineTo(otherLeftWorld, y + tickSize);
                                ctx.moveTo(myLeftWorld, y - tickSize);
                                ctx.lineTo(myLeftWorld, y + tickSize);
                                ctx.stroke();
                                
                                ctx.setLineDash([2 / state.zoom, 2 / state.zoom]);
                                ctx.beginPath();
                                ctx.moveTo(otherLeftWorld, otherBottomWorld);
                                ctx.lineTo(otherLeftWorld, y);
                                ctx.moveTo(myLeftWorld, myTopWorld);
                                ctx.lineTo(myLeftWorld, y);
                                ctx.stroke();
                                ctx.setLineDash([]);
                                
                                const midX = (otherLeftWorld + myLeftWorld) / 2;
                                const labelText = toFeetInches(leftOffset);
                                const metrics = ctx.measureText(labelText);
                                
                                ctx.fillStyle = 'white';
                                ctx.fillRect(midX - metrics.width/2 - padding, y - 7/state.zoom, metrics.width + padding*2, 14/state.zoom);
                                
                                ctx.fillStyle = '#000000'; // Black text
                                ctx.fillText(labelText, midX, y);
                            }
                            
                            // Right offset
                            if (myRightWorld < otherRightWorld - 5) {
                                const rightOffset = (otherRightWorld - myRightWorld) / 30;
                                
                                ctx.beginPath();
                                ctx.moveTo(myRightWorld, y);
                                ctx.lineTo(otherRightWorld, y);
                                ctx.stroke();
                                
                                ctx.beginPath();
                                ctx.moveTo(myRightWorld, y - tickSize);
                                ctx.lineTo(myRightWorld, y + tickSize);
                                ctx.moveTo(otherRightWorld, y - tickSize);
                                ctx.lineTo(otherRightWorld, y + tickSize);
                                ctx.stroke();
                                
                                ctx.setLineDash([2 / state.zoom, 2 / state.zoom]);
                                ctx.beginPath();
                                ctx.moveTo(myRightWorld, myTopWorld);
                                ctx.lineTo(myRightWorld, y);
                                ctx.moveTo(otherRightWorld, otherBottomWorld);
                                ctx.lineTo(otherRightWorld, y);
                                ctx.stroke();
                                ctx.setLineDash([]);
                                
                                const midX = (myRightWorld + otherRightWorld) / 2;
                                const labelText = toFeetInches(rightOffset);
                                const metrics = ctx.measureText(labelText);
                                
                                ctx.fillStyle = 'white';
                                ctx.fillRect(midX - metrics.width/2 - padding, y - 7/state.zoom, metrics.width + padding*2, 14/state.zoom);
                                
                                ctx.fillStyle = '#000000'; // Black text
                                ctx.fillText(labelText, midX, y);
                            }
                            
                            ctx.restore();
                        }
                    }
                });
                
                ctx.restore(); // End dimensions context
                ctx.save(); // Restore translated context for rest of room drawing
                if (state.showAllRooms) {
                    ctx.translate(offsetX, offsetZ);
                }
            }
            }  // END if(false) - corner-to-corner dimensions disabled
            
            // ============================================================================
            // FEATURE DIMENSIONS (Doors, Windows, Openings) - DISABLED
            // ============================================================================
            // Disabled to match reference image - using simple on-wall labels only
            
            if (false) {  // DISABLED - no feature dimension lines
            room.walls.forEach((wall, wallIdx) => {
                const wallLength = parseFloat(wall.length);
                if (wallLength <= 0) return;
                
                const dx = wall.end.x - wall.start.x;
                const dy = wall.end.y - wall.start.y;
                const wallAngle = Math.atan2(dy, dx);
                const wallPixelLength = Math.sqrt(dx * dx + dy * dy);
                const unitX = dx / wallPixelLength;
                const unitY = dy / wallPixelLength;
                
                const perpAngle = wallAngle + Math.PI / 2;
                const offsetDist = 20 / state.zoom;
                const ox = Math.cos(perpAngle) * offsetDist;
                const oy = Math.sin(perpAngle) * offsetDist;
                
                // Draw door dimensions
                room.doors.forEach((door, doorIdx) => {
                    if (door.wallIndex === wallIdx) {
                        const doorWidth = door.width / 12;
                        const startDist = (door.distanceFromLeft || 0);
                        const startPixel = startDist * 30;
                        const endPixel = (startDist + doorWidth) * 30;
                        
                        const x1 = wall.start.x + unitX * startPixel + ox;
                        const y1 = wall.start.y + unitY * startPixel + oy;
                        const x2 = wall.start.x + unitX * endPixel + ox;
                        const y2 = wall.start.y + unitY * endPixel + oy;
                        
                        ctx.save();
                        ctx.strokeStyle = '#3498DB';
                        ctx.lineWidth = 2 / state.zoom;
                        ctx.setLineDash([3 / state.zoom, 2 / state.zoom]);
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        const tickSize = 4 / state.zoom;
                        ctx.beginPath();
                        ctx.moveTo(x1 + Math.cos(perpAngle) * tickSize, y1 + Math.sin(perpAngle) * tickSize);
                        ctx.lineTo(x1 - Math.cos(perpAngle) * tickSize, y1 - Math.sin(perpAngle) * tickSize);
                        ctx.moveTo(x2 + Math.cos(perpAngle) * tickSize, y2 + Math.sin(perpAngle) * tickSize);
                        ctx.lineTo(x2 - Math.cos(perpAngle) * tickSize, y2 - Math.sin(perpAngle) * tickSize);
                        ctx.stroke();
                        
                        const midX = (x1 + x2) / 2;
                        const midY = (y1 + y2) / 2;
                        ctx.translate(midX, midY);
                        
                        let textAngle = wallAngle;
                        if (Math.abs(wallAngle) > Math.PI / 2) {
                            textAngle = wallAngle + Math.PI;
                        }
                        ctx.rotate(textAngle);
                        
                        const fontSize = 11 / state.zoom;
                        ctx.font = `bold ${fontSize}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        const text = `üö™ ${doorWidth.toFixed(2)}'`;
                        const metrics = ctx.measureText(text);
                        
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
                        ctx.fillRect(-metrics.width/2 - 3/state.zoom, -fontSize*0.7, 
                                    metrics.width + 6/state.zoom, fontSize*1.4);
                        
                        ctx.strokeStyle = '#3498DB';
                        ctx.lineWidth = 1 / state.zoom;
                        ctx.strokeRect(-metrics.width/2 - 3/state.zoom, -fontSize*0.7, 
                                      metrics.width + 6/state.zoom, fontSize*1.4);
                        
                        ctx.fillStyle = '#2E5C8A';
                        ctx.fillText(text, 0, 0);
                        
                        ctx.restore();
                    }
                });
                
                // Draw window dimensions
                room.windows.forEach((window, winIdx) => {
                    if (window.wallIndex === wallIdx) {
                        const windowWidth = window.width / 12;
                        const startDist = (window.distanceFromLeft || 0);
                        const startPixel = startDist * 30;
                        const endPixel = (startDist + windowWidth) * 30;
                        
                        const x1 = wall.start.x + unitX * startPixel + ox;
                        const y1 = wall.start.y + unitY * startPixel + oy;
                        const x2 = wall.start.x + unitX * endPixel + ox;
                        const y2 = wall.start.y + unitY * endPixel + oy;
                        
                        ctx.save();
                        ctx.strokeStyle = '#3498DB';
                        ctx.lineWidth = 2 / state.zoom;
                        ctx.setLineDash([3 / state.zoom, 2 / state.zoom]);
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        const tickSize = 4 / state.zoom;
                        ctx.beginPath();
                        ctx.moveTo(x1 + Math.cos(perpAngle) * tickSize, y1 + Math.sin(perpAngle) * tickSize);
                        ctx.lineTo(x1 - Math.cos(perpAngle) * tickSize, y1 - Math.sin(perpAngle) * tickSize);
                        ctx.moveTo(x2 + Math.cos(perpAngle) * tickSize, y2 + Math.sin(perpAngle) * tickSize);
                        ctx.lineTo(x2 - Math.cos(perpAngle) * tickSize, y2 - Math.sin(perpAngle) * tickSize);
                        ctx.stroke();
                        
                        const midX = (x1 + x2) / 2;
                        const midY = (y1 + y2) / 2;
                        ctx.translate(midX, midY);
                        
                        let textAngle = wallAngle;
                        if (Math.abs(wallAngle) > Math.PI / 2) {
                            textAngle = wallAngle + Math.PI;
                        }
                        ctx.rotate(textAngle);
                        
                        const fontSize = 11 / state.zoom;
                        ctx.font = `bold ${fontSize}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        const text = `ü™ü ${windowWidth.toFixed(2)}'`;
                        const metrics = ctx.measureText(text);
                        
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
                        ctx.fillRect(-metrics.width/2 - 3/state.zoom, -fontSize*0.7, 
                                    metrics.width + 6/state.zoom, fontSize*1.4);
                        
                        ctx.strokeStyle = '#3498DB';
                        ctx.lineWidth = 1 / state.zoom;
                        ctx.strokeRect(-metrics.width/2 - 3/state.zoom, -fontSize*0.7, 
                                      metrics.width + 6/state.zoom, fontSize*1.4);
                        
                        ctx.fillStyle = '#2E5C8A';
                        ctx.fillText(text, 0, 0);
                        
                        ctx.restore();
                    }
                });
                
                // Draw opening dimensions
                const wallCuts = [...(wall.cuts || []), ...(wall.missingWalls || [])];
                wallCuts.forEach((cut, cutIdx) => {
                    const startDist = cut.startDist || 0;
                    const endDist = cut.endDist || startDist;
                    const cutWidth = endDist - startDist;
                    
                    if (cutWidth < 0.05) return;
                    
                    const startPixel = startDist * 30;
                    const endPixel = endDist * 30;
                    
                    const x1 = wall.start.x + unitX * startPixel + ox;
                    const y1 = wall.start.y + unitY * startPixel + oy;
                    const x2 = wall.start.x + unitX * endPixel + ox;
                    const y2 = wall.start.y + unitY * endPixel + oy;
                    
                    ctx.save();
                    ctx.strokeStyle = '#3498DB';
                    ctx.lineWidth = 2 / state.zoom;
                    ctx.setLineDash([3 / state.zoom, 2 / state.zoom]);
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    const tickSize = 4 / state.zoom;
                    ctx.beginPath();
                    ctx.moveTo(x1 + Math.cos(perpAngle) * tickSize, y1 + Math.sin(perpAngle) * tickSize);
                    ctx.lineTo(x1 - Math.cos(perpAngle) * tickSize, y1 - Math.sin(perpAngle) * tickSize);
                    ctx.moveTo(x2 + Math.cos(perpAngle) * tickSize, y2 + Math.sin(perpAngle) * tickSize);
                    ctx.lineTo(x2 - Math.cos(perpAngle) * tickSize, y2 - Math.sin(perpAngle) * tickSize);
                    ctx.stroke();
                    
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    ctx.translate(midX, midY);
                    
                    let textAngle = wallAngle;
                    if (Math.abs(wallAngle) > Math.PI / 2) {
                        textAngle = wallAngle + Math.PI;
                    }
                    ctx.rotate(textAngle);
                    
                    const fontSize = 11 / state.zoom;
                    ctx.font = `bold ${fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const text = `‚úÇÔ∏è ${cutWidth.toFixed(2)}'`;
                    const metrics = ctx.measureText(text);
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
                    ctx.fillRect(-metrics.width/2 - 3/state.zoom, -fontSize*0.7, 
                                metrics.width + 6/state.zoom, fontSize*1.4);
                    
                    ctx.strokeStyle = '#3498DB';
                    ctx.lineWidth = 1 / state.zoom;
                    ctx.strokeRect(-metrics.width/2 - 3/state.zoom, -fontSize*0.7, 
                                  metrics.width + 6/state.zoom, fontSize*1.4);
                    
                    ctx.fillStyle = '#2E5C8A';
                    ctx.fillText(text, 0, 0);
                    
                    ctx.restore();
                });
            });
            }  // END if(false) - feature dimensions disabled
            
            
            // Draw doors and windows for all rooms (always visible)
            // Draw doors
            room.doors.forEach((door, index) => {
                    const w = door.width / 12 * 30 / 2; // Half width in pixels
                    const doorType = door.doorType || 'single';
                    
                    // Highlight if hovering
                    if (hoverDoorIndex === index && isCurrentRoom) {
                        ctx.save();
                        ctx.translate(door.x, door.y);
                        ctx.rotate((door.rotation || 0) * Math.PI / 180);
                        
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.fillRect(-w - 20 / state.zoom, -30 / state.zoom, w * 2 + 40 / state.zoom, 60 / state.zoom);
                        
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 5 / state.zoom;
                        ctx.strokeRect(-w - 20 / state.zoom, -30 / state.zoom, w * 2 + 40 / state.zoom, 60 / state.zoom);
                        
                        ctx.restore();
                    }
                    
                    ctx.save();
                    ctx.translate(door.x, door.y);
                    ctx.rotate((door.rotation || 0) * Math.PI / 180);
                    
                    const doorWidth = w * 2; // Full door width in pixels
                    const hingeSide = door.hinge || 'right';
                    const swingDir = door.swingDirection || 'in';
                    
                    // Draw based on door type
                    switch(doorType) {
                        case 'double':
                            drawDoubleDoor(ctx, w, doorWidth, hingeSide, swingDir, state.zoom);
                            break;
                        case 'sliding':
                            drawSlidingDoor(ctx, w, doorWidth, state.zoom);
                            break;
                        case 'french':
                            drawFrenchDoor(ctx, w, doorWidth, hingeSide, swingDir, state.zoom);
                            break;
                        case 'bifold':
                            drawBifoldDoor(ctx, w, doorWidth, state.zoom);
                            break;
                        case 'pocket':
                            drawPocketDoor(ctx, w, doorWidth, state.zoom);
                            break;
                        case 'dutch':
                            drawDutchDoor(ctx, w, doorWidth, hingeSide, swingDir, state.zoom);
                            break;
                        case 'single':
                        default:
                            drawSingleDoor(ctx, w, doorWidth, hingeSide, swingDir, state.zoom);
                            break;
                    }
                    
                    ctx.restore();
                    
                    // ALWAYS show dimension label for doors
                    const doorWidthInches = door.width;
                    const doorWidthFeet = Math.floor(doorWidthInches / 12);
                    const doorWidthRemainingInches = doorWidthInches % 12;
                    const dimensionText = doorWidthRemainingInches > 0 
                        ? `${doorWidthFeet}' ${doorWidthRemainingInches}"` 
                        : `${doorWidthFeet}'`;
                    
                    ctx.save();
                    ctx.font = `bold ${11 / state.zoom}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Draw background box
                    const metrics = ctx.measureText(dimensionText);
                    const boxPadding = 3 / state.zoom;
                    const boxWidth = metrics.width + boxPadding * 2;
                    const boxHeight = 14 / state.zoom;
                    const labelY = door.y - 20 / state.zoom;
                    
                    ctx.fillStyle = 'rgba(76, 175, 80, 0.9)'; // Green background for doors
                    ctx.fillRect(
                        door.x - boxWidth / 2,
                        labelY - boxHeight / 2,
                        boxWidth,
                        boxHeight
                    );
                    
                    // Draw text
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(dimensionText, door.x, labelY);
                    ctx.restore();
                    
                    if (hoverDoorIndex === index && isCurrentRoom) {
                        ctx.font = `bold ${16 / state.zoom}px Arial`;
                        ctx.fillStyle = '#FF0000';
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 3 / state.zoom;
                        const typeLabel = doorType.toUpperCase();
                        ctx.strokeText(typeLabel, door.x, door.y + 45 / state.zoom);
                        ctx.fillText(typeLabel, door.x, door.y + 45 / state.zoom);
                    }
                });
                
                // Draw windows
                room.windows.forEach((win, index) => {
                    const w = win.width / 12 * 30 / 2; // Half width in pixels
                    const windowType = win.windowType || 'double-hung';
                    
                    if (hoverWindowIndex === index && isCurrentRoom) {
                        ctx.save();
                        ctx.translate(win.x, win.y);
                        ctx.rotate((win.rotation || 0) * Math.PI / 180);
                        
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.fillRect(-w - 20 / state.zoom, -30 / state.zoom, w * 2 + 40 / state.zoom, 60 / state.zoom);
                        
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 5 / state.zoom;
                        ctx.strokeRect(-w - 20 / state.zoom, -30 / state.zoom, w * 2 + 40 / state.zoom, 60 / state.zoom);
                        
                        ctx.restore();
                    }
                    
                    ctx.save();
                    ctx.translate(win.x, win.y);
                    ctx.rotate((win.rotation || 0) * Math.PI / 180);
                    
                    // Draw based on window type
                    switch(windowType) {
                        case 'single-hung':
                            drawSingleHungWindow(ctx, w, state.zoom);
                            break;
                        case 'casement':
                            drawCasementWindow(ctx, w, state.zoom);
                            break;
                        case 'sliding':
                            drawSlidingWindow(ctx, w, state.zoom);
                            break;
                        case 'awning':
                            drawAwningWindow(ctx, w, state.zoom);
                            break;
                        case 'hopper':
                            drawHopperWindow(ctx, w, state.zoom);
                            break;
                        case 'bay':
                            drawBayWindow(ctx, w, state.zoom);
                            break;
                        case 'bow':
                            drawBowWindow(ctx, w, state.zoom);
                            break;
                        case 'picture':
                            drawPictureWindow(ctx, w, state.zoom);
                            break;
                        case 'skylight':
                            drawSkylightWindow(ctx, w, state.zoom);
                            break;
                        case 'garden':
                            drawGardenWindow(ctx, w, state.zoom);
                            break;
                        case 'double-hung':
                        default:
                            drawDoubleHungWindow(ctx, w, state.zoom);
                            break;
                    }
                    
                    ctx.restore();
                    
                    // ALWAYS show dimension label for windows
                    const windowWidthInches = win.width;
                    const windowWidthFeet = Math.floor(windowWidthInches / 12);
                    const windowWidthRemainingInches = windowWidthInches % 12;
                    const dimensionText = windowWidthRemainingInches > 0 
                        ? `${windowWidthFeet}' ${windowWidthRemainingInches}"` 
                        : `${windowWidthFeet}'`;
                    
                    ctx.save();
                    ctx.font = `bold ${11 / state.zoom}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Draw background box
                    const metrics = ctx.measureText(dimensionText);
                    const boxPadding = 3 / state.zoom;
                    const boxWidth = metrics.width + boxPadding * 2;
                    const boxHeight = 14 / state.zoom;
                    const labelY = win.y - 20 / state.zoom;
                    
                    ctx.fillStyle = 'rgba(33, 150, 243, 0.9)'; // Blue background for windows
                    ctx.fillRect(
                        win.x - boxWidth / 2,
                        labelY - boxHeight / 2,
                        boxWidth,
                        boxHeight
                    );
                    
                    // Draw text
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(dimensionText, win.x, labelY);
                    ctx.restore();
                    
                    if (hoverWindowIndex === index && isCurrentRoom) {
                        ctx.font = `bold ${16 / state.zoom}px Arial`;
                        ctx.fillStyle = '#FF0000';
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 3 / state.zoom;
                        const typeLabel = windowType.toUpperCase().replace('-', ' ');
                        ctx.strokeText(typeLabel, win.x, win.y + 45 / state.zoom);
                        ctx.fillText(typeLabel, win.x, win.y + 45 / state.zoom);
                    }
                });
            
            ctx.restore();
        }

        // Door type drawing functions
        function drawSingleDoor(ctx, w, doorWidth, hingeSide, swingDir, zoom) {
            // Door opening line
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1 / zoom;
            ctx.beginPath();
            ctx.moveTo(-w, 0);
            ctx.lineTo(w, 0);
            ctx.stroke();
            
            // Door panel and swing arc
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2 / zoom;
            const openAngle = Math.PI / 4;
            
            if (hingeSide === 'right' && swingDir === 'in') {
                ctx.beginPath();
                ctx.moveTo(w, 0);
                const doorAngle = Math.PI - openAngle;
                ctx.lineTo(w + doorWidth * Math.cos(doorAngle), doorWidth * Math.sin(doorAngle));
                ctx.stroke();
                ctx.lineWidth = 1 / zoom;
                ctx.beginPath();
                ctx.arc(w, 0, doorWidth, Math.PI, Math.PI - openAngle, true);
                ctx.stroke();
            } else if (hingeSide === 'right' && swingDir === 'out') {
                ctx.beginPath();
                ctx.moveTo(w, 0);
                const doorAngle = Math.PI + openAngle;
                ctx.lineTo(w + doorWidth * Math.cos(doorAngle), doorWidth * Math.sin(doorAngle));
                ctx.stroke();
                ctx.lineWidth = 1 / zoom;
                ctx.beginPath();
                ctx.arc(w, 0, doorWidth, Math.PI, Math.PI + openAngle, false);
                ctx.stroke();
            } else if (hingeSide === 'left' && swingDir === 'in') {
                ctx.beginPath();
                ctx.moveTo(-w, 0);
                ctx.lineTo(-w + doorWidth * Math.cos(openAngle), doorWidth * Math.sin(openAngle));
                ctx.stroke();
                ctx.lineWidth = 1 / zoom;
                ctx.beginPath();
                ctx.arc(-w, 0, doorWidth, 0, openAngle, false);
                ctx.stroke();
            } else {
                ctx.beginPath();
                ctx.moveTo(-w, 0);
                ctx.lineTo(-w + doorWidth * Math.cos(-openAngle), doorWidth * Math.sin(-openAngle));
                ctx.stroke();
                ctx.lineWidth = 1 / zoom;
                ctx.beginPath();
                ctx.arc(-w, 0, doorWidth, 0, -openAngle, true);
                ctx.stroke();
            }
        }

        function drawDoubleDoor(ctx, w, doorWidth, hingeSide, swingDir, zoom) {
            const halfW = doorWidth / 4;
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1 / zoom;
            ctx.beginPath();
            ctx.moveTo(-w, 0);
            ctx.lineTo(w, 0);
            ctx.stroke();
            
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2 / zoom;
            const openAngle = Math.PI / 4;
            const direction = swingDir === 'in' ? 1 : -1;
            
            // Left door
            ctx.beginPath();
            ctx.moveTo(-w, 0);
            ctx.lineTo(-w + halfW * Math.cos(openAngle * direction), halfW * Math.sin(openAngle * direction));
            ctx.stroke();
            ctx.lineWidth = 1 / zoom;
            ctx.beginPath();
            if (direction === 1) ctx.arc(-w, 0, halfW, 0, openAngle, false);
            else ctx.arc(-w, 0, halfW, 0, -openAngle, true);
            ctx.stroke();
            
            // Right door
            ctx.lineWidth = 2 / zoom;
            ctx.beginPath();
            ctx.moveTo(w, 0);
            ctx.lineTo(w + halfW * Math.cos(Math.PI - openAngle * direction), halfW * Math.sin(Math.PI - openAngle * direction));
            ctx.stroke();
            ctx.lineWidth = 1 / zoom;
            ctx.beginPath();
            if (direction === 1) ctx.arc(w, 0, halfW, Math.PI, Math.PI - openAngle, true);
            else ctx.arc(w, 0, halfW, Math.PI, Math.PI + openAngle, false);
            ctx.stroke();
        }

        function drawSlidingDoor(ctx, w, doorWidth, zoom) {
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2 / zoom;
            // Track
            ctx.beginPath();
            ctx.moveTo(-w, 0);
            ctx.lineTo(w, 0);
            ctx.stroke();
            
            // Sliding panels
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 3 / zoom;
            const panelOffset = doorWidth * 0.15;
            ctx.beginPath();
            ctx.moveTo(-w + panelOffset, -panelOffset);
            ctx.lineTo(0, -panelOffset);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0 + panelOffset, panelOffset);
            ctx.lineTo(w, panelOffset);
            ctx.stroke();
            
            // Arrows showing slide direction
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1 / zoom;
            const arrowSize = 8 / zoom;
            // Left arrow
            ctx.beginPath();
            ctx.moveTo(-w/2, -panelOffset);
            ctx.lineTo(-w/2 - arrowSize, -panelOffset - arrowSize/2);
            ctx.moveTo(-w/2, -panelOffset);
            ctx.lineTo(-w/2 - arrowSize, -panelOffset + arrowSize/2);
            ctx.stroke();
            // Right arrow
            ctx.beginPath();
            ctx.moveTo(w/2, panelOffset);
            ctx.lineTo(w/2 + arrowSize, panelOffset - arrowSize/2);
            ctx.moveTo(w/2, panelOffset);
            ctx.lineTo(w/2 + arrowSize, panelOffset + arrowSize/2);
            ctx.stroke();
        }

        function drawFrenchDoor(ctx, w, doorWidth, hingeSide, swingDir, zoom) {
            // Similar to double door but with grid pattern
            drawDoubleDoor(ctx, w, doorWidth, hingeSide, swingDir, zoom);
            
            // Add grid pattern for glass panes
            ctx.strokeStyle = '#87CEEB';
            ctx.lineWidth = 0.5 / zoom;
            const gridSpacing = doorWidth / 8;
            for (let i = 1; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(-w + i * gridSpacing, -10 / zoom);
                ctx.lineTo(-w + i * gridSpacing, 10 / zoom);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(w - i * gridSpacing, -10 / zoom);
                ctx.lineTo(w - i * gridSpacing, 10 / zoom);
                ctx.stroke();
            }
        }

        function drawBifoldDoor(ctx, w, doorWidth, zoom) {
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1 / zoom;
            ctx.beginPath();
            ctx.moveTo(-w, 0);
            ctx.lineTo(w, 0);
            ctx.stroke();
            
            // Folded panels
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2 / zoom;
            const foldAngle = Math.PI / 6;
            const panelWidth = doorWidth / 4;
            
            // Left side
            ctx.beginPath();
            ctx.moveTo(-w, 0);
            ctx.lineTo(-w + panelWidth * Math.cos(foldAngle), panelWidth * Math.sin(foldAngle));
            ctx.lineTo(-w + panelWidth * Math.cos(foldAngle) + panelWidth * Math.cos(foldAngle * 2), panelWidth * Math.sin(foldAngle) + panelWidth * Math.sin(foldAngle * 2));
            ctx.stroke();
            
            // Right side
            ctx.beginPath();
            ctx.moveTo(w, 0);
            ctx.lineTo(w + panelWidth * Math.cos(Math.PI - foldAngle), panelWidth * Math.sin(Math.PI - foldAngle));
            ctx.lineTo(w + panelWidth * Math.cos(Math.PI - foldAngle) + panelWidth * Math.cos(Math.PI - foldAngle * 2), panelWidth * Math.sin(Math.PI - foldAngle) + panelWidth * Math.sin(Math.PI - foldAngle * 2));
            ctx.stroke();
        }

        function drawPocketDoor(ctx, w, doorWidth, zoom) {
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1 / zoom;
            ctx.beginPath();
            ctx.moveTo(-w, 0);
            ctx.lineTo(w, 0);
            ctx.stroke();
            
            // Door panel (dashed to show it slides into wall)
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2 / zoom;
            ctx.setLineDash([5 / zoom, 5 / zoom]);
            ctx.beginPath();
            ctx.moveTo(-w, 0);
            ctx.lineTo(-w - doorWidth * 0.2, doorWidth * 0.2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Arrow showing pocket direction
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1 / zoom;
            const arrowSize = 8 / zoom;
            ctx.beginPath();
            ctx.moveTo(-w * 0.5, 0);
            ctx.lineTo(-w - arrowSize, arrowSize);
            ctx.moveTo(-w * 0.5, 0);
            ctx.lineTo(-w - arrowSize, -arrowSize);
            ctx.stroke();
        }

        function drawDutchDoor(ctx, w, doorWidth, hingeSide, swingDir, zoom) {
            // Similar to single door but with horizontal dividing line
            drawSingleDoor(ctx, w, doorWidth, hingeSide, swingDir, zoom);
            
            // Horizontal dividing line
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2 / zoom;
            ctx.beginPath();
            ctx.moveTo(-w, 0);
            ctx.lineTo(w, 0);
            ctx.stroke();
            
            // Second horizontal line to show split
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1 / zoom;
            ctx.beginPath();
            const midOffset = hingeSide === 'left' ? -w/2 : w/2;
            ctx.moveTo(midOffset - w/4, 0);
            ctx.lineTo(midOffset + w/4, 0);
            ctx.stroke();
        }

        // Window type drawing functions
        function drawDoubleHungWindow(ctx, w, zoom) {
            ctx.strokeStyle = '#4682B4';
            ctx.lineWidth = 2 / zoom;
            // Three parallel lines (classic double-hung)
            for (let i = -1; i <= 1; i++) {
                ctx.beginPath();
                ctx.moveTo(-w, i * 6 / zoom);
                ctx.lineTo(w, i * 6 / zoom);
                ctx.stroke();
            }
            // Center divider
            ctx.strokeStyle = '#2E5C8A';
            ctx.lineWidth = 1 / zoom;
            ctx.beginPath();
            ctx.moveTo(0, -8 / zoom);
            ctx.lineTo(0, 8 / zoom);
            ctx.stroke();
        }

        function drawSingleHungWindow(ctx, w, zoom) {
            ctx.strokeStyle = '#4682B4';
            ctx.lineWidth = 2 / zoom;
            // Two parallel lines (upper fixed, lower moves)
            ctx.beginPath();
            ctx.moveTo(-w, -4 / zoom);
            ctx.lineTo(w, -4 / zoom);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-w, 4 / zoom);
            ctx.lineTo(w, 4 / zoom);
            ctx.stroke();
            // Single divider at bottom half
            ctx.strokeStyle = '#2E5C8A';
            ctx.lineWidth = 1 / zoom;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, 8 / zoom);
            ctx.stroke();
        }

        function drawCasementWindow(ctx, w, zoom) {
            ctx.strokeStyle = '#4682B4';
            ctx.lineWidth = 2 / zoom;
            // Frame
            ctx.strokeRect(-w, -8 / zoom, w * 2, 16 / zoom);
            // Hinged side indicator (left)
            ctx.lineWidth = 3 / zoom;
            ctx.beginPath();
            ctx.moveTo(-w, -8 / zoom);
            ctx.lineTo(-w, 8 / zoom);
            ctx.stroke();
            // Small crank indicator
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1 / zoom;
            ctx.beginPath();
            ctx.arc(w * 0.6, 0, 3 / zoom, 0, Math.PI * 2);
            ctx.stroke();
        }

        function drawSlidingWindow(ctx, w, zoom) {
            ctx.strokeStyle = '#4682B4';
            ctx.lineWidth = 2 / zoom;
            // Two overlapping panels
            ctx.beginPath();
            ctx.moveTo(-w, -6 / zoom);
            ctx.lineTo(0, -6 / zoom);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, 6 / zoom);
            ctx.lineTo(w, 6 / zoom);
            ctx.stroke();
            // Arrows
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1 / zoom;
            const arrowSize = 5 / zoom;
            ctx.beginPath();
            ctx.moveTo(-w/2, -6 / zoom);
            ctx.lineTo(-w/2 - arrowSize, -6 / zoom - arrowSize);
            ctx.moveTo(-w/2, -6 / zoom);
            ctx.lineTo(-w/2 - arrowSize, -6 / zoom + arrowSize);
            ctx.stroke();
        }

        function drawAwningWindow(ctx, w, zoom) {
            ctx.strokeStyle = '#4682B4';
            ctx.lineWidth = 2 / zoom;
            // Angled to show opens outward at top
            ctx.beginPath();
            ctx.moveTo(-w, 8 / zoom);
            ctx.lineTo(-w, -4 / zoom);
            ctx.lineTo(-w + 10 / zoom, -8 / zoom);
            ctx.lineTo(w - 10 / zoom, -8 / zoom);
            ctx.lineTo(w, -4 / zoom);
            ctx.lineTo(w, 8 / zoom);
            ctx.stroke();
            // Hinge at top
            ctx.lineWidth = 3 / zoom;
            ctx.beginPath();
            ctx.moveTo(-w, -4 / zoom);
            ctx.lineTo(w, -4 / zoom);
            ctx.stroke();
        }

        function drawHopperWindow(ctx, w, zoom) {
            ctx.strokeStyle = '#4682B4';
            ctx.lineWidth = 2 / zoom;
            // Angled to show opens inward at bottom
            ctx.beginPath();
            ctx.moveTo(-w, -8 / zoom);
            ctx.lineTo(-w, 4 / zoom);
            ctx.lineTo(-w + 10 / zoom, 8 / zoom);
            ctx.lineTo(w - 10 / zoom, 8 / zoom);
            ctx.lineTo(w, 4 / zoom);
            ctx.lineTo(w, -8 / zoom);
            ctx.stroke();
            // Hinge at bottom
            ctx.lineWidth = 3 / zoom;
            ctx.beginPath();
            ctx.moveTo(-w, 4 / zoom);
            ctx.lineTo(w, 4 / zoom);
            ctx.stroke();
        }

        function drawBayWindow(ctx, w, zoom) {
            ctx.strokeStyle = '#4682B4';
            ctx.lineWidth = 2 / zoom;
            // Three angled sections forming bay
            const angle = Math.PI / 6;
            const depth = 15 / zoom;
            ctx.beginPath();
            ctx.moveTo(-w, 0);
            ctx.lineTo(-w + w/3 * Math.cos(-angle), w/3 * Math.sin(-angle) - depth);
            ctx.lineTo(w - w/3 * Math.cos(-angle), w/3 * Math.sin(-angle) - depth);
            ctx.lineTo(w, 0);
            ctx.stroke();
            // Vertical dividers
            ctx.beginPath();
            ctx.moveTo(-w + w/3 * Math.cos(-angle), w/3 * Math.sin(-angle) - depth);
            ctx.lineTo(-w + w/3 * Math.cos(-angle), 0);
            ctx.moveTo(w - w/3 * Math.cos(-angle), w/3 * Math.sin(-angle) - depth);
            ctx.lineTo(w - w/3 * Math.cos(-angle), 0);
            ctx.stroke();
        }

        function drawBowWindow(ctx, w, zoom) {
            ctx.strokeStyle = '#4682B4';
            ctx.lineWidth = 2 / zoom;
            // Curved projection
            const radius = w * 1.2;
            const depth = 15 / zoom;
            ctx.beginPath();
            ctx.arc(0, radius - depth, radius, Math.PI, Math.PI * 2, false);
            ctx.stroke();
            // Radial dividers
            for (let i = 0; i < 5; i++) {
                const angle = Math.PI + (i * Math.PI / 4);
                ctx.beginPath();
                ctx.moveTo(0, radius - depth);
                ctx.lineTo(Math.cos(angle) * radius, (radius - depth) + Math.sin(angle) * radius);
                ctx.stroke();
            }
        }

        function drawPictureWindow(ctx, w, zoom) {
            ctx.strokeStyle = '#4682B4';
            ctx.lineWidth = 3 / zoom;
            // Single large pane - thick frame
            ctx.strokeRect(-w, -10 / zoom, w * 2, 20 / zoom);
            // No dividers - emphasize single large pane
            ctx.fillStyle = 'rgba(70, 130, 180, 0.1)';
            ctx.fillRect(-w, -10 / zoom, w * 2, 20 / zoom);
        }

        function drawSkylightWindow(ctx, w, zoom) {
            ctx.strokeStyle = '#4682B4';
            ctx.lineWidth = 2 / zoom;
            // Diamond/tilted square to indicate roof placement
            const size = 12 / zoom;
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(w, 0);
            ctx.lineTo(0, size);
            ctx.lineTo(-w, 0);
            ctx.closePath();
            ctx.stroke();
            // Sun rays
            ctx.strokeStyle = '#FDB813';
            ctx.lineWidth = 1 / zoom;
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI / 4);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * size * 0.7, Math.sin(angle) * size * 0.7);
                ctx.stroke();
            }
        }

        function drawGardenWindow(ctx, w, zoom) {
            ctx.strokeStyle = '#4682B4';
            ctx.lineWidth = 2 / zoom;
            // Box projection with shelf
            const depth = 20 / zoom;
            ctx.beginPath();
            ctx.moveTo(-w, 0);
            ctx.lineTo(-w + 5 / zoom, -depth);
            ctx.lineTo(w - 5 / zoom, -depth);
            ctx.lineTo(w, 0);
            ctx.stroke();
            // Shelf line
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 2 / zoom;
            ctx.beginPath();
            ctx.moveTo(-w + 5 / zoom, -depth / 2);
            ctx.lineTo(w - 5 / zoom, -depth / 2);
            ctx.stroke();
            // Small plant icon
            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 1 / zoom;
            ctx.beginPath();
            ctx.arc(0, -depth / 2, 3 / zoom, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Helper function to check if two edges are the same (shared wall)
        function edgesMatch(p1, p2, p3, p4) {
            const tolerance = 20.0; // Increased to 20px to handle all coordinate variations
            
            // Check for exact endpoint matches
            const dx1 = Math.abs(p1.x - p3.x);
            const dy1 = Math.abs(p1.y - p3.y);
            const dx2 = Math.abs(p2.x - p4.x);
            const dy2 = Math.abs(p2.y - p4.y);
            
            const forwardMatch = dx1 < tolerance && dy1 < tolerance && dx2 < tolerance && dy2 < tolerance;
            
            const dx1r = Math.abs(p1.x - p4.x);
            const dy1r = Math.abs(p1.y - p4.y);
            const dx2r = Math.abs(p2.x - p3.x);
            const dy2r = Math.abs(p2.y - p3.y);
            
            const reverseMatch = dx1r < tolerance && dy1r < tolerance && dx2r < tolerance && dy2r < tolerance;
            
            // Log close calls
            if (forwardMatch) {
                console.log(`      ‚úÖ FORWARD MATCH: dx1=${dx1.toFixed(1)}, dy1=${dy1.toFixed(1)}, dx2=${dx2.toFixed(1)}, dy2=${dy2.toFixed(1)}`);
            } else if (reverseMatch) {
                console.log(`      ‚úÖ REVERSE MATCH: dx1r=${dx1r.toFixed(1)}, dy1r=${dy1r.toFixed(1)}, dx2r=${dx2r.toFixed(1)}, dy2r=${dy2r.toFixed(1)}`);
            } else if ((dx1 < 50 && dy1 < 50) || (dx1r < 50 && dy1r < 50)) {
                console.log(`      ‚ùå NO MATCH: Forward: dx1=${dx1.toFixed(1)}, dy1=${dy1.toFixed(1)}, Reverse: dx1r=${dx1r.toFixed(1)}, dy1r=${dy1r.toFixed(1)}`);
            }
            
            // If BOTH endpoints match (within tolerance), it's the same wall!
            return forwardMatch || reverseMatch;
        }

        // Find room sharing an edge with the current room
        // Returns { room, edgeIndex } if found, null otherwise
        function findRoomSharingEdge(room, edgeIndex) {
            if (!room || !room.floorPoints || room.floorPoints.length < 3) return null;
            
            const p1 = room.floorPoints[edgeIndex];
            const p2 = room.floorPoints[(edgeIndex + 1) % room.floorPoints.length];
            
            // Check all rooms on current level
            const roomsOnLevel = state.rooms.filter(r => r.level === state.currentLevel);
            
            for (const otherRoom of roomsOnLevel) {
                if (otherRoom === room) continue;
                if (!otherRoom.floorPoints || otherRoom.floorPoints.length < 3) continue;
                
                // Check each edge of other room
                for (let i = 0; i < otherRoom.floorPoints.length; i++) {
                    const p3 = otherRoom.floorPoints[i];
                    const p4 = otherRoom.floorPoints[(i + 1) % otherRoom.floorPoints.length];
                    
                    if (edgesMatch(p1, p2, p3, p4)) {
                        return {
                            room: otherRoom,
                            edgeIndex: i
                        };
                    }
                }
            }
            
            return null;
        }

        // Check if a point is inside a polygon using ray casting algorithm
        function pointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                const intersect = ((yi > point.y) !== (yj > point.y))
                    && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // Get shared edges info for a room
        // Returns: { skip: Set, single: Set }
        // - skip: Edge indices to skip completely (other room will draw them)
        // - single: Edge indices to draw as single line (this room draws, but not double)
        function getSharedEdgesInfo(room, roomsOnLevel) {
            const skip = new Set();
            const single = new Set();
            
            if (!room || !room.floorPoints || room.floorPoints.length < 3) {
                return { skip, single };
            }
            
            const numPoints = room.floorPoints.length;
            const roomIndex = state.rooms.indexOf(room);
            
            console.log(`  üîç Checking ${room.name} (index ${roomIndex}) for shared edges...`);
            
            // Check each edge of this room
            for (let i = 0; i < numPoints; i++) {
                const p1 = room.floorPoints[i];
                const p2 = room.floorPoints[(i + 1) % numPoints];
                
                console.log(`    Edge ${i}: (${p1.x.toFixed(1)}, ${p1.y.toFixed(1)}) ‚Üí (${p2.x.toFixed(1)}, ${p2.y.toFixed(1)})`);
                
                // Check against all other rooms
                for (const otherRoom of roomsOnLevel) {
                    if (otherRoom === room) continue;
                    if (!otherRoom.floorPoints || otherRoom.floorPoints.length < 3) continue;
                    
                    const otherRoomIndex = state.rooms.indexOf(otherRoom);
                    const otherNumPoints = otherRoom.floorPoints.length;
                    
                    for (let j = 0; j < otherNumPoints; j++) {
                        const p3 = otherRoom.floorPoints[j];
                        const p4 = otherRoom.floorPoints[(j + 1) % otherNumPoints];
                        
                        if (edgesMatch(p1, p2, p3, p4)) {
                            // Edge is shared!
                            console.log(`      üîó MATCHED with ${otherRoom.name} edge ${j}`);
                            if (otherRoomIndex < roomIndex) {
                                // Other room has lower index - skip this edge (other room will draw it)
                                skip.add(i);
                                console.log(`      ‚Üí ${room.name} will SKIP edge ${i}`);
                            } else {
                                // This room has lower index - draw as single line
                                single.add(i);
                                console.log(`      ‚Üí ${room.name} will DRAW edge ${i}`);
                            }
                            break;
                        }
                    }
                }
            }
            
            console.log(`  üìä ${room.name} result: skip=[${Array.from(skip)}], single=[${Array.from(single)}]`);
            return { skip, single };
        }

        function redraw2D() {
            // Don't redraw 2D canvas when in 3D mode
            if (state.currentView === '3d') {
                console.log('redraw2D called but in 3D mode - skipping');
                return;
            }
            
            // Force complete clear - reset transform first, then clear
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas2D.width, canvas2D.height);
            
            // Now apply our transforms
            ctx.save();
            ctx.translate(state.panX, state.panY);
            ctx.scale(state.zoom, state.zoom);
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1 / state.zoom;
            for (let x = 0; x < canvas2D.width / state.zoom; x += 30) {
                ctx.beginPath();
                ctx.moveTo(x - state.panX / state.zoom, -state.panY / state.zoom);
                ctx.lineTo(x - state.panX / state.zoom, (canvas2D.height - state.panY) / state.zoom);
                ctx.stroke();
            }
            for (let y = 0; y < canvas2D.height / state.zoom; y += 30) {
                ctx.beginPath();
                ctx.moveTo(-state.panX / state.zoom, y - state.panY / state.zoom);
                ctx.lineTo((canvas2D.width - state.panX) / state.zoom, y - state.panY / state.zoom);
                ctx.stroke();
            }
            
            // ROOM DRAWING LOGIC:
            // - Filter to show ONLY rooms on current level
            // - ALL rooms on current level are ALWAYS fully visible
            // - Current room gets special highlighting (handles, thicker outline)
            
            // Filter rooms to current level only
            const roomsOnCurrentLevel = state.rooms.filter(r => r.level === state.currentLevel);
            
            if (state.roomEditMode) {
                // ROOM EDIT MODE: Draw ALL rooms on current level fully (not just names!)
                roomsOnCurrentLevel.forEach((room) => {
                    const roomIndex = state.rooms.indexOf(room);
                    const isCurrentRoom = roomIndex === state.currentRoomIndex;
                    
                    // Draw EVERY room fully, with current room highlighted
                    drawSingleRoom(room, 0, 0, isCurrentRoom);
                });
            } else if (state.showAllRooms) {
                // Draw all rooms on current level at their positions
                roomsOnCurrentLevel.forEach((room) => {
                    const roomIndex = state.rooms.indexOf(room);
                    const offsetX = (room.positionX || 0) * 30;
                    const offsetZ = (room.positionZ || 0) * 30;
                    const isCurrentRoom = roomIndex === state.currentRoomIndex;
                    drawSingleRoom(room, offsetX, offsetZ, isCurrentRoom);
                });
            } else {
                // Draw ALL rooms on current level (not just current room!)
                roomsOnCurrentLevel.forEach((room) => {
                    const roomIndex = state.rooms.indexOf(room);
                    const isCurrentRoom = roomIndex === state.currentRoomIndex;
                    drawSingleRoom(room, 0, 0, isCurrentRoom);
                });
            }
            
            // Draw wall hover effects for current room only
            if (state.wallSelectionMode && !state.showAllRooms) {
                const room = getCurrentRoom();
                if (room) {
                    room.walls.forEach((wall, index) => {
                        if (index === state.hoveredWall) {
                            ctx.strokeStyle = '#00FF00';
                            ctx.lineWidth = 10 / state.zoom;
                            ctx.beginPath();
                            ctx.moveTo(wall.start.x, wall.start.y);
                            ctx.lineTo(wall.end.x, wall.end.y);
                            ctx.stroke();
                        }
                    });
                    
                    if (hoverClickPoint) {
                        ctx.fillStyle = 'gold';
                        ctx.beginPath();
                        ctx.arc(hoverClickPoint.x, hoverClickPoint.y, 8 / state.zoom, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.strokeStyle = 'red';
                        ctx.lineWidth = 3 / state.zoom;
                        ctx.beginPath();
                        ctx.moveTo(hoverClickPoint.x - 15 / state.zoom, hoverClickPoint.y);
                        ctx.lineTo(hoverClickPoint.x + 15 / state.zoom, hoverClickPoint.y);
                        ctx.moveTo(hoverClickPoint.x, hoverClickPoint.y - 15 / state.zoom);
                        ctx.lineTo(hoverClickPoint.x, hoverClickPoint.y + 15 / state.zoom);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw snap indicators when dragging and snapped
            if (state.draggingRoom !== null && state.lastSnapped && state.showAllRooms) {
                const room = state.rooms[state.draggingRoom];
                if (room.floorPoints.length >= 3) {
                    // Calculate room bounds
                    let minX = Infinity, maxX = -Infinity;
                    let minZ = Infinity, maxZ = -Infinity;
                    
                    room.floorPoints.forEach(p => {
                        minX = Math.min(minX, p.x);
                        maxX = Math.max(maxX, p.x);
                        minZ = Math.min(minZ, p.y);
                        maxZ = Math.max(maxZ, p.y);
                    });
                    
                    const offsetX = (room.positionX || 0) * 30;
                    const offsetZ = (room.positionZ || 0) * 30;
                    
                    // Draw bright green lines at room edges to show snap
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 4 / state.zoom;
                    ctx.setLineDash([10 / state.zoom, 5 / state.zoom]);
                    
                    // Draw box around room
                    ctx.beginPath();
                    ctx.rect(minX + offsetX, minZ + offsetZ, maxX - minX, maxZ - minZ);
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                    
                    // Draw "SNAPPED" text
                    ctx.save();
                    ctx.font = `bold ${16 / state.zoom}px Arial`;
                    ctx.fillStyle = '#000000';
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 3 / state.zoom;
                    ctx.textAlign = 'center';
                    const centerX = (minX + maxX) / 2 + offsetX;
                    const centerY = (minZ + maxZ) / 2 + offsetZ;
                    const snapText = state.snapType || '‚ö° SNAPPED';
                    ctx.strokeText(snapText, centerX, centerY);
                    ctx.fillText(snapText, centerX, centerY);
                    ctx.restore();
                }
            }
            
            // BLACK CORNER OFFSET DIMENSIONS - Always visible
            if (state.showAllRooms) {
                // Draw dimensions for each room
                state.rooms.forEach((currentRoom, currentIdx) => {
                    if (!currentRoom || currentRoom.floorPoints.length < 3) return;
                    
                    // Get current room bounds
                    let myMinX = Infinity, myMaxX = -Infinity;
                    let myMinZ = Infinity, myMaxZ = -Infinity;
                    currentRoom.floorPoints.forEach(p => {
                        myMinX = Math.min(myMinX, p.x);
                        myMaxX = Math.max(myMaxX, p.x);
                        myMinZ = Math.min(myMinZ, p.y);
                        myMaxZ = Math.max(myMaxZ, p.y);
                    });
                        
                    const myOffsetX = (currentRoom.positionX || 0) * 30;
                    const myOffsetZ = (currentRoom.positionZ || 0) * 30;
                const myLeftWorld = myMinX + myOffsetX;
                const myRightWorld = myMaxX + myOffsetX;
                const myTopWorld = myMinZ + myOffsetZ;
                const myBottomWorld = myMaxZ + myOffsetZ;
                    
                    // Check against all other rooms
                    state.rooms.forEach((otherRoom, otherIdx) => {
                        if (otherIdx === currentIdx || otherRoom.floorPoints.length < 3) return;
                    
                    // Get other room bounds
                    let otherMinX = Infinity, otherMaxX = -Infinity;
                    let otherMinZ = Infinity, otherMaxZ = -Infinity;
                    otherRoom.floorPoints.forEach(p => {
                        otherMinX = Math.min(otherMinX, p.x);
                        otherMaxX = Math.max(otherMaxX, p.x);
                        otherMinZ = Math.min(otherMinZ, p.y);
                        otherMaxZ = Math.max(otherMaxZ, p.y);
                    });
                    
                    const otherOffsetX = (otherRoom.positionX || 0) * 30;
                    const otherOffsetZ = (otherRoom.positionZ || 0) * 30;
                    const otherLeftWorld = otherMinX + otherOffsetX;
                    const otherRightWorld = otherMaxX + otherOffsetX;
                    const otherTopWorld = otherMinZ + otherOffsetZ;
                    const otherBottomWorld = otherMaxZ + otherOffsetZ;
                    
                    const tolerance = 10; // 10px alignment tolerance
                    
                    // Check if dragged room is ABOVE other room (bottom edge aligns with top edge)
                    if (Math.abs(myBottomWorld - otherTopWorld) < tolerance) {
                        // Check horizontal overlap
                        if (otherRightWorld > myLeftWorld && otherLeftWorld < myRightWorld) {
                            ctx.save();
                            ctx.strokeStyle = '#000000'; // Black
                            ctx.lineWidth = 1.5 / state.zoom;
                            ctx.font = `bold ${10 / state.zoom}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            const y = myBottomWorld + 30 / state.zoom;
                            const tickSize = 8 / state.zoom;
                            const padding = 3 / state.zoom;
                            
                            // Left offset (if dragged room's left is inset from other's left)
                            if (myLeftWorld > otherLeftWorld + 5) {
                                const leftOffset = (myLeftWorld - otherLeftWorld) / 30;
                                
                                // Dimension line
                                ctx.beginPath();
                                ctx.moveTo(otherLeftWorld, y);
                                ctx.lineTo(myLeftWorld, y);
                                ctx.stroke();
                                
                                // Tick marks
                                ctx.beginPath();
                                ctx.moveTo(otherLeftWorld, y - tickSize);
                                ctx.lineTo(otherLeftWorld, y + tickSize);
                                ctx.moveTo(myLeftWorld, y - tickSize);
                                ctx.lineTo(myLeftWorld, y + tickSize);
                                ctx.stroke();
                                
                                // Extension lines
                                ctx.setLineDash([2 / state.zoom, 2 / state.zoom]);
                                ctx.beginPath();
                                ctx.moveTo(otherLeftWorld, otherTopWorld);
                                ctx.lineTo(otherLeftWorld, y);
                                ctx.moveTo(myLeftWorld, myBottomWorld);
                                ctx.lineTo(myLeftWorld, y);
                                ctx.stroke();
                                ctx.setLineDash([]);
                                
                                // Label
                                const midX = (otherLeftWorld + myLeftWorld) / 2;
                                const labelText = toFeetInches(leftOffset);
                                const metrics = ctx.measureText(labelText);
                                
                                ctx.fillStyle = 'white';
                                ctx.fillRect(
                                    midX - metrics.width/2 - padding,
                                    y - 7/state.zoom,
                                    metrics.width + padding*2,
                                    14/state.zoom
                                );
                                
                                ctx.fillStyle = '#000000'; // Black text
                                ctx.fillText(labelText, midX, y);
                            }
                            
                            // Right offset (if dragged room's right is inset from other's right)
                            if (myRightWorld < otherRightWorld - 5) {
                                const rightOffset = (otherRightWorld - myRightWorld) / 30;
                                
                                // Dimension line
                                ctx.beginPath();
                                ctx.moveTo(myRightWorld, y);
                                ctx.lineTo(otherRightWorld, y);
                                ctx.stroke();
                                
                                // Tick marks
                                ctx.beginPath();
                                ctx.moveTo(myRightWorld, y - tickSize);
                                ctx.lineTo(myRightWorld, y + tickSize);
                                ctx.moveTo(otherRightWorld, y - tickSize);
                                ctx.lineTo(otherRightWorld, y + tickSize);
                                ctx.stroke();
                                
                                // Extension lines
                                ctx.setLineDash([2 / state.zoom, 2 / state.zoom]);
                                ctx.beginPath();
                                ctx.moveTo(myRightWorld, myBottomWorld);
                                ctx.lineTo(myRightWorld, y);
                                ctx.moveTo(otherRightWorld, otherTopWorld);
                                ctx.lineTo(otherRightWorld, y);
                                ctx.stroke();
                                ctx.setLineDash([]);
                                
                                // Label
                                const midX = (myRightWorld + otherRightWorld) / 2;
                                const labelText = toFeetInches(rightOffset);
                                const metrics = ctx.measureText(labelText);
                                
                                ctx.fillStyle = 'white';
                                ctx.fillRect(
                                    midX - metrics.width/2 - padding,
                                    y - 7/state.zoom,
                                    metrics.width + padding*2,
                                    14/state.zoom
                                );
                                
                                ctx.fillStyle = '#000000'; // Black text
                                ctx.fillText(labelText, midX, y);
                            }
                            
                            ctx.restore();
                        }
                    }
                    
                    // Check if dragged room is BELOW other room (top edge aligns with bottom edge)
                    if (Math.abs(myTopWorld - otherBottomWorld) < tolerance) {
                        // Check horizontal overlap
                        if (otherRightWorld > myLeftWorld && otherLeftWorld < myRightWorld) {
                            ctx.save();
                            ctx.strokeStyle = '#000000'; // Black
                            ctx.lineWidth = 1.5 / state.zoom;
                            ctx.font = `bold ${10 / state.zoom}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            const y = myTopWorld - 30 / state.zoom;
                            const tickSize = 8 / state.zoom;
                            const padding = 3 / state.zoom;
                            
                            // Left offset (if dragged room's left is inset from other's left)
                            if (myLeftWorld > otherLeftWorld + 5) {
                                const leftOffset = (myLeftWorld - otherLeftWorld) / 30;
                                
                                // Dimension line
                                ctx.beginPath();
                                ctx.moveTo(otherLeftWorld, y);
                                ctx.lineTo(myLeftWorld, y);
                                ctx.stroke();
                                
                                // Tick marks
                                ctx.beginPath();
                                ctx.moveTo(otherLeftWorld, y - tickSize);
                                ctx.lineTo(otherLeftWorld, y + tickSize);
                                ctx.moveTo(myLeftWorld, y - tickSize);
                                ctx.lineTo(myLeftWorld, y + tickSize);
                                ctx.stroke();
                                
                                // Extension lines
                                ctx.setLineDash([2 / state.zoom, 2 / state.zoom]);
                                ctx.beginPath();
                                ctx.moveTo(otherLeftWorld, otherBottomWorld);
                                ctx.lineTo(otherLeftWorld, y);
                                ctx.moveTo(myLeftWorld, myTopWorld);
                                ctx.lineTo(myLeftWorld, y);
                                ctx.stroke();
                                ctx.setLineDash([]);
                                
                                // Label
                                const midX = (otherLeftWorld + myLeftWorld) / 2;
                                const labelText = toFeetInches(leftOffset);
                                const metrics = ctx.measureText(labelText);
                                
                                ctx.fillStyle = 'white';
                                ctx.fillRect(
                                    midX - metrics.width/2 - padding,
                                    y - 7/state.zoom,
                                    metrics.width + padding*2,
                                    14/state.zoom
                                );
                                
                                ctx.fillStyle = '#000000'; // Black text
                                ctx.fillText(labelText, midX, y);
                            }
                            
                            // Right offset (if dragged room's right is inset from other's right)
                            if (myRightWorld < otherRightWorld - 5) {
                                const rightOffset = (otherRightWorld - myRightWorld) / 30;
                                
                                // Dimension line
                                ctx.beginPath();
                                ctx.moveTo(myRightWorld, y);
                                ctx.lineTo(otherRightWorld, y);
                                ctx.stroke();
                                
                                // Tick marks
                                ctx.beginPath();
                                ctx.moveTo(myRightWorld, y - tickSize);
                                ctx.lineTo(myRightWorld, y + tickSize);
                                ctx.moveTo(otherRightWorld, y - tickSize);
                                ctx.lineTo(otherRightWorld, y + tickSize);
                                ctx.stroke();
                                
                                // Extension lines
                                ctx.setLineDash([2 / state.zoom, 2 / state.zoom]);
                                ctx.beginPath();
                                ctx.moveTo(myRightWorld, myTopWorld);
                                ctx.lineTo(myRightWorld, y);
                                ctx.moveTo(otherRightWorld, otherBottomWorld);
                                ctx.lineTo(otherRightWorld, y);
                                ctx.stroke();
                                ctx.setLineDash([]);
                                
                                // Label
                                const midX = (myRightWorld + otherRightWorld) / 2;
                                const labelText = toFeetInches(rightOffset);
                                const metrics = ctx.measureText(labelText);
                                
                                ctx.fillStyle = 'white';
                                ctx.fillRect(
                                    midX - metrics.width/2 - padding,
                                    y - 7/state.zoom,
                                    metrics.width + padding*2,
                                    14/state.zoom
                                );
                                
                                ctx.fillStyle = '#000000'; // Black text
                                ctx.fillText(labelText, midX, y);
                            }
                            
                            ctx.restore();
                        }
                    }
                });
                }); // End forEach over all rooms
            }
            
            // ===== EDIT MODE VISUALS =====
            if (editMode.active && !state.showAllRooms) {
                const room = getCurrentRoom();
                if (room) {
                    // Highlight selected walls for force90 tool
                    if (editMode.tool === 'force90' && editMode.selectedWalls.length > 0) {
                        editMode.selectedWalls.forEach(wallIndex => {
                            const start = room.floorPoints[wallIndex];
                            const end = room.floorPoints[(wallIndex + 1) % room.floorPoints.length];
                            
                            ctx.strokeStyle = '#FF4081';
                            ctx.lineWidth = 6 / state.zoom;
                            ctx.beginPath();
                            ctx.moveTo(start.x, start.y);
                            ctx.lineTo(end.x, end.y);
                            ctx.stroke();
                        });
                    }
                    
                    // Show wall angles
                    if (editMode.showAngles) {
                        ctx.font = `bold ${16 / state.zoom}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        for (let i = 0; i < room.floorPoints.length; i++) {
                            const prev = room.floorPoints[(i - 1 + room.floorPoints.length) % room.floorPoints.length];
                            const curr = room.floorPoints[i];
                            const next = room.floorPoints[(i + 1) % room.floorPoints.length];
                            
                            // Calculate angle at this corner
                            const dx1 = curr.x - prev.x;
                            const dy1 = curr.y - prev.y;
                            const dx2 = next.x - curr.x;
                            const dy2 = next.y - curr.y;
                            
                            const angle1 = Math.atan2(dy1, dx1);
                            const angle2 = Math.atan2(dy2, dx2);
                            
                            let angleDiff = (angle2 - angle1) * 180 / Math.PI;
                            
                            // Normalize to 0-360
                            while (angleDiff < 0) angleDiff += 360;
                            while (angleDiff > 360) angleDiff -= 360;
                            
                            // Interior angle
                            const interiorAngle = 360 - angleDiff;
                            
                            // Display angle at corner
                            const displayAngle = Math.round(interiorAngle);
                            
                            // Color code: green if close to 90¬∞, red if not
                            const is90 = Math.abs(displayAngle - 90) < 2;
                            ctx.fillStyle = is90 ? '#4CAF50' : '#F44336';
                            ctx.fillText(`${displayAngle}¬∞`, curr.x, curr.y - 20 / state.zoom);
                        }
                    }
                }
            }
            // ===== END EDIT MODE VISUALS =====
            
            // ===== ROOM EDIT MODE HANDLES =====
            if (state.roomEditMode && !state.showAllRooms) {
                const room = getCurrentRoom();
                if (room && room.floorPoints && room.floorPoints.length > 0) {
                    ctx.save();
                    
                    const HANDLE_SIZE = 10 / state.zoom; // Handle radius
                    const HOVER_SIZE = 15 / state.zoom; // Larger hover detection
                    
                    // CORNER HANDLES DISABLED - only edge handles are used
                    // (Corner handles removed to prevent accidental room distortion)
                    
                    // Draw EDGE MIDPOINT handles (for moving whole edges)
                    for (let i = 0; i < room.floorPoints.length; i++) {
                        const p1 = room.floorPoints[i];
                        const p2 = room.floorPoints[(i + 1) % room.floorPoints.length];
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        
                        const isHovered = state.hoveredHandle?.type === 'edge' && state.hoveredHandle?.index === i;
                        const isDragging = state.draggingHandle?.type === 'edge' && state.draggingHandle?.index === i;
                        
                        // Check if this edge is shared with another room
                        const isShared = findRoomSharingEdge(room, i) !== null;
                        
                        // Handle appearance - purple/magenta for shared walls, yellow for non-shared
                        let fillColor;
                        if (isDragging) {
                            fillColor = '#FF4081'; // Pink when dragging
                        } else if (isHovered) {
                            fillColor = '#2196F3'; // Blue when hovered
                        } else if (isShared) {
                            fillColor = '#9C27B0'; // Purple for shared walls
                        } else {
                            fillColor = '#FFC107'; // Yellow for non-shared walls
                        }
                        
                        ctx.fillStyle = fillColor;
                        ctx.strokeStyle = '#FFF';
                        ctx.lineWidth = 2 / state.zoom;
                        
                        // Draw edge handle (square)
                        const halfSize = HANDLE_SIZE * 0.8;
                        ctx.fillRect(midX - halfSize, midY - halfSize, halfSize * 2, halfSize * 2);
                        ctx.strokeRect(midX - halfSize, midY - halfSize, halfSize * 2, halfSize * 2);
                        
                        // Draw "S" indicator on shared walls
                        if (isShared && !isDragging) {
                            ctx.fillStyle = '#FFF';
                            ctx.font = `bold ${8 / state.zoom}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('S', midX, midY);
                        }
                    }
                    
                    ctx.restore();
                }
            }
            
            // ===== WALL DRAG PREVIEW (Xactimate-style) =====
            if (state.wallDragPreview && state.roomEditMode) {
                const room = getCurrentRoom();
                if (room && room.floorPoints) {
                    ctx.save();
                    
                    // Determine color based on mode and snap status
                    const isSnapped = state.wallDragPreview.snapped;
                    const isCreateMode = state.wallDragPreview.ctrlPressed;
                    
                    let color, lineWidth, labelText;
                    if (isCreateMode) {
                        // CTRL pressed = Create new room mode
                        color = isSnapped ? '#4CAF50' : '#8BC34A';  // Green if snapped, Light green if not
                        lineWidth = 6 / state.zoom;
                        labelText = isSnapped ? `üÜï ${state.wallDragPreview.distance.toFixed(1)}' - NEW ROOM` : `${state.wallDragPreview.distance.toFixed(1)}' - NEW ROOM`;
                    } else {
                        // Regular mode = Expand room mode
                        color = isSnapped ? '#9C27B0' : '#00BCD4';  // Purple if snapped, Cyan if not
                        lineWidth = isSnapped ? 6 / state.zoom : 4 / state.zoom;
                        labelText = isSnapped ? `üß≤ ${state.wallDragPreview.distance.toFixed(1)}'` : `${state.wallDragPreview.distance.toFixed(1)}'`;
                    }
                    
                    // Draw preview wall
                    ctx.strokeStyle = color;
                    ctx.lineWidth = lineWidth;
                    ctx.setLineDash([10 / state.zoom, 5 / state.zoom]); // Dashed line
                    
                    ctx.beginPath();
                    ctx.moveTo(state.wallDragPreview.p1.x, state.wallDragPreview.p1.y);
                    ctx.lineTo(state.wallDragPreview.p2.x, state.wallDragPreview.p2.y);
                    ctx.stroke();
                    
                    // Draw distance indicator
                    const midX = (state.wallDragPreview.p1.x + state.wallDragPreview.p2.x) / 2;
                    const midY = (state.wallDragPreview.p1.y + state.wallDragPreview.p2.y) / 2;
                    
                    // Show distance and mode
                    ctx.setLineDash([]); // Solid for text background
                    ctx.font = `bold ${14 / state.zoom}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const metrics = ctx.measureText(labelText);
                    const padding = 4 / state.zoom;
                    
                    // Background
                    ctx.fillStyle = color;
                    ctx.fillRect(
                        midX - metrics.width / 2 - padding,
                        midY - 8 / state.zoom,
                        metrics.width + padding * 2,
                        16 / state.zoom
                    );
                    
                    // Text
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(labelText, midX, midY);
                    
                    ctx.restore();
                }
            }
            // ===== END ROOM EDIT MODE HANDLES =====
            
            // ===== ADJACENT ROOM PREVIEW (XACTIMATE CTRL+DRAG) =====
            if (state.adjacentRoomPreview) {
                ctx.save();
                ctx.translate(state.panX, state.panY);
                ctx.scale(state.zoom, state.zoom);
                
                const preview = state.adjacentRoomPreview;
                
                // Draw preview room outline
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 4 / state.zoom;
                ctx.setLineDash([10 / state.zoom, 5 / state.zoom]);
                
                ctx.beginPath();
                ctx.moveTo(preview.p1.x, preview.p1.y);
                ctx.lineTo(preview.p2.x, preview.p2.y);
                ctx.lineTo(preview.p3.x, preview.p3.y);
                ctx.lineTo(preview.p4.x, preview.p4.y);
                ctx.closePath();
                ctx.stroke();
                
                // Fill with semi-transparent green
                ctx.fillStyle = 'rgba(76, 175, 80, 0.2)';
                ctx.fill();
                
                // Draw depth label
                const centerX = (preview.p1.x + preview.p2.x + preview.p3.x + preview.p4.x) / 4;
                const centerY = (preview.p1.y + preview.p2.y + preview.p3.y + preview.p4.y) / 4;
                
                ctx.setLineDash([]);
                ctx.font = `bold ${16 / state.zoom}px Arial`;
                ctx.fillStyle = '#4CAF50';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`üÜï ${preview.depth.toFixed(1)}' NEW ROOM`, centerX, centerY);
                
                ctx.restore();
            }
            
            // ===== WALL DRAWING MODE VISUALS =====
            if (state.wallSelectionMode && !state.currentFeature && state.wallDrawingCorners && state.wallDrawingCorners.length > 0) {
                ctx.save();
                ctx.translate(state.panX, state.panY);
                ctx.scale(state.zoom, state.zoom);
                
                // Draw all placed corners
                state.wallDrawingCorners.forEach((corner, index) => {
                    // Draw corner circle
                    ctx.fillStyle = index === 0 ? '#4CAF50' : '#2196F3';
                    ctx.strokeStyle = index === 0 ? '#388E3C' : '#1976D2';
                    ctx.lineWidth = 2 / state.zoom;
                    ctx.beginPath();
                    ctx.arc(corner.x, corner.y, 8 / state.zoom, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw corner number
                    ctx.fillStyle = '#FFF';
                    ctx.font = `bold ${10 / state.zoom}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(index + 1, corner.x, corner.y);
                });
                
                // Draw lines between corners - SIMPLE DOUBLE LINES to show they'll be parallel
                if (state.wallDrawingCorners.length > 1) {
                    const OFFSET = 6 / state.zoom; // Simple fixed offset for preview
                    
                    ctx.strokeStyle = '#2196F3';
                    ctx.lineWidth = 2.5 / state.zoom;
                    ctx.setLineDash([]);
                    
                    // Draw each wall segment as TWO parallel lines
                    for (let i = 0; i < state.wallDrawingCorners.length - 1; i++) {
                        const p1 = state.wallDrawingCorners[i];
                        const p2 = state.wallDrawingCorners[i + 1];
                        
                        // Calculate perpendicular offset
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        const perpX = (-dy / len) * OFFSET;
                        const perpY = (dx / len) * OFFSET;
                        
                        // Draw first parallel line
                        ctx.beginPath();
                        ctx.moveTo(p1.x + perpX, p1.y + perpY);
                        ctx.lineTo(p2.x + perpX, p2.y + perpY);
                        ctx.stroke();
                        
                        // Draw second parallel line
                        ctx.beginPath();
                        ctx.moveTo(p1.x - perpX, p1.y - perpY);
                        ctx.lineTo(p2.x - perpX, p2.y - perpY);
                        ctx.stroke();
                    }
                    
                    // Draw dimension labels on each wall segment
                    for (let i = 0; i < state.wallDrawingCorners.length - 1; i++) {
                        const p1 = state.wallDrawingCorners[i];
                        const p2 = state.wallDrawingCorners[i + 1];
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        
                        // Calculate length
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const lengthPixels = Math.sqrt(dx * dx + dy * dy);
                        const lengthFeet = lengthPixels / 30;
                        
                        // Draw label background
                        const labelText = lengthFeet.toFixed(1) + ' ft';
                        ctx.font = `bold ${12 / state.zoom}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const metrics = ctx.measureText(labelText);
                        const padding = 4 / state.zoom;
                        
                        ctx.fillStyle = 'rgba(33, 150, 243, 0.9)';
                        ctx.fillRect(
                            midX - metrics.width / 2 - padding,
                            midY - 8 / state.zoom,
                            metrics.width + padding * 2,
                            16 / state.zoom
                        );
                        
                        // Draw label text
                        ctx.fillStyle = '#FFF';
                        ctx.fillText(labelText, midX, midY);
                    }
                }
                
                ctx.restore();
            }
            
            // Draw preview line from last corner to mouse
            if (state.wallSelectionMode && !state.currentFeature && state.wallDrawingCorners && state.wallDrawingCorners.length > 0 && state.mouseX !== undefined) {
                const lastCorner = state.wallDrawingCorners[state.wallDrawingCorners.length - 1];
                const firstCorner = state.wallDrawingCorners[0];
                
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0); // Screen coordinates
                
                // Calculate preview point (with ortho snapping)
                let previewX = state.mouseWorldX;
                let previewY = state.mouseWorldY;
                
                if (state.orthoMode) {
                    const dx = Math.abs(state.mouseWorldX - lastCorner.x);
                    const dy = Math.abs(state.mouseWorldY - lastCorner.y);
                    
                    if (dx > dy) {
                        previewY = lastCorner.y; // Snap horizontal
                    } else {
                        previewX = lastCorner.x; // Snap vertical
                    }
                }
                
                // Convert to screen coordinates
                const screenLastX = lastCorner.x * state.zoom + state.panX;
                const screenLastY = lastCorner.y * state.zoom + state.panY;
                const screenFirstX = firstCorner.x * state.zoom + state.panX;
                const screenFirstY = firstCorner.y * state.zoom + state.panY;
                
                // Check distance to first corner
                const distToFirst = Math.sqrt(
                    Math.pow(previewX - firstCorner.x, 2) + 
                    Math.pow(previewY - firstCorner.y, 2)
                );
                
                const CLOSE_THRESHOLD = 30; // pixels
                
                // SNAP PREVIEW TO FIRST CORNER IF CLOSE ENOUGH (3+ corners)
                if (state.wallDrawingCorners.length >= 3 && distToFirst < CLOSE_THRESHOLD) {
                    previewX = firstCorner.x;
                    previewY = firstCorner.y;
                }
                
                // Calculate screen coordinates AFTER snapping
                const screenPreviewX = previewX * state.zoom + state.panX;
                const screenPreviewY = previewY * state.zoom + state.panY;
                
                // Draw preview line from last corner to preview position
                ctx.strokeStyle = (state.wallDrawingCorners.length >= 3 && distToFirst < CLOSE_THRESHOLD) ? '#4CAF50' : (state.orthoMode ? '#FF9800' : '#2196F3');
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(screenLastX, screenLastY);
                ctx.lineTo(screenPreviewX, screenPreviewY);
                ctx.stroke();
                
                // Show live dimension for preview line
                const previewDx = previewX - lastCorner.x;
                const previewDy = previewY - lastCorner.y;
                const previewLengthPixels = Math.sqrt(previewDx * previewDx + previewDy * previewDy);
                const previewLengthFeet = previewLengthPixels / 30;
                
                if (previewLengthFeet > 0.1) { // Only show if meaningful length
                    const midScreenX = (screenLastX + screenPreviewX) / 2;
                    const midScreenY = (screenLastY + screenPreviewY) / 2;
                    const dimLabel = previewLengthFeet.toFixed(1) + ' ft';
                    
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const metrics = ctx.measureText(dimLabel);
                    
                    // Background
                    ctx.fillStyle = state.orthoMode ? 'rgba(255, 152, 0, 0.9)' : 'rgba(33, 150, 243, 0.9)';
                    ctx.fillRect(midScreenX - metrics.width / 2 - 6, midScreenY - 10, metrics.width + 12, 20);
                    
                    // Text
                    ctx.fillStyle = '#FFF';
                    ctx.fillText(dimLabel, midScreenX, midScreenY);
                }
                
                // If 3+ corners and close to first, draw closing line
                if (state.wallDrawingCorners.length >= 3 && distToFirst < 30) {
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([15, 5]);
                    ctx.beginPath();
                    ctx.moveTo(screenPreviewX, screenPreviewY);
                    ctx.lineTo(screenFirstX, screenFirstY);
                    ctx.stroke();
                    
                    // Show "CLOSE" label
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillText('CLOSE', screenFirstX, screenFirstY - 20);
                }
                
                ctx.setLineDash([]);
                
                // Draw preview corner circle
                ctx.fillStyle = state.orthoMode ? 'rgba(255, 152, 0, 0.5)' : 'rgba(33, 150, 243, 0.5)';
                ctx.strokeStyle = state.orthoMode ? '#FF9800' : '#2196F3';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(screenPreviewX, screenPreviewY, 8, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // Show wall length preview
                const dx = previewX - lastCorner.x;
                const dy = previewY - lastCorner.y;
                const lengthPixels = Math.sqrt(dx * dx + dy * dy);
                const lengthFeet = lengthPixels / 30;
                
                if (lengthFeet >= 0.5) {
                    const midX = (screenLastX + screenPreviewX) / 2;
                    const midY = (screenLastY + screenPreviewY) / 2;
                    
                    const feet = Math.floor(lengthFeet);
                    const inches = Math.round((lengthFeet - feet) * 12);
                    let dimensionText = inches === 0 ? `${feet}'` : 
                                       inches === 12 ? `${feet + 1}'` : 
                                       `${feet}' ${inches}"`;
                    
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // White background
                    const textMetrics = ctx.measureText(dimensionText);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.fillRect(
                        midX - textMetrics.width / 2 - 6,
                        midY - 10,
                        textMetrics.width + 12,
                        20
                    );
                    
                    // Border
                    ctx.strokeStyle = state.orthoMode ? '#FF9800' : '#2196F3';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(
                        midX - textMetrics.width / 2 - 6,
                        midY - 10,
                        textMetrics.width + 12,
                        20
                    );
                    
                    // Text
                    ctx.fillStyle = state.orthoMode ? '#FF9800' : '#2196F3';
                    ctx.fillText(dimensionText, midX, midY);
                }
                
                ctx.restore();
            }
            
            // ===== ZOOM WINDOW RECTANGLE =====
            if (state.zoomWindowMode && state.zoomWindowStart && state.zoomWindowEnd) {
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0); // Screen coordinates
                
                const x1 = state.zoomWindowStart.x;
                const y1 = state.zoomWindowStart.y;
                const x2 = state.zoomWindowEnd.x;
                const y2 = state.zoomWindowEnd.y;
                
                const width = x2 - x1;
                const height = y2 - y1;
                
                // Draw semi-transparent fill
                ctx.fillStyle = 'rgba(156, 39, 176, 0.1)';
                ctx.fillRect(x1, y1, width, height);
                
                // Draw border
                ctx.strokeStyle = '#9C27B0';
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 5]);
                ctx.strokeRect(x1, y1, width, height);
                ctx.setLineDash([]);
                
                // Draw corner markers
                const cornerSize = 10;
                ctx.fillStyle = '#9C27B0';
                ctx.fillRect(x1 - 2, y1 - 2, cornerSize, cornerSize);
                ctx.fillRect(x2 - cornerSize + 2, y1 - 2, cornerSize, cornerSize);
                ctx.fillRect(x1 - 2, y2 - cornerSize + 2, cornerSize, cornerSize);
                ctx.fillRect(x2 - cornerSize + 2, y2 - cornerSize + 2, cornerSize, cornerSize);
                
                ctx.restore();
            }
        }

        let isRendering3D = false; // Prevent re-entrant calls
        const SHOW_3D_DIMENSIONS = false; // keep 3D clean: no wall/door/window dimension labels
        let render3DCallCount = 0;
        
        // 3D Door Type Rendering Functions
        function render3DSingleDoor(scene, pos, width, height, thickness, rotation) {
            // Door panel
            const doorGeom = new THREE.BoxGeometry(width, height, thickness);
            const doorMat = new THREE.MeshLambertMaterial({ 
                color: 0x654321,
                emissive: 0x442200,
                side: THREE.DoubleSide
            });
            const doorMesh = new THREE.Mesh(doorGeom, doorMat);
            doorMesh.position.set(pos.x, pos.y, pos.z);
            doorMesh.rotation.y = rotation;
            doorMesh.castShadow = true;
            scene.add(doorMesh);
            
            // Frame
            const frameGeom = new THREE.BoxGeometry(width + 0.15, height + 0.15, 0.08);
            const frameMat = new THREE.MeshLambertMaterial({ 
                color: 0xFF6B35,
                emissive: 0xFF6B35,
                side: THREE.DoubleSide
            });
            const offsetDist = thickness / 2 + 0.04;
            
            const frameFront = new THREE.Mesh(frameGeom, frameMat);
            frameFront.position.set(pos.x, pos.y, pos.z);
            frameFront.rotation.y = rotation;
            frameFront.position.x += Math.sin(rotation) * offsetDist;
            frameFront.position.z += Math.cos(rotation) * offsetDist;
            scene.add(frameFront);
            
            const frameBack = new THREE.Mesh(frameGeom, frameMat);
            frameBack.position.set(pos.x, pos.y, pos.z);
            frameBack.rotation.y = rotation;
            frameBack.position.x -= Math.sin(rotation) * offsetDist;
            frameBack.position.z -= Math.cos(rotation) * offsetDist;
            scene.add(frameBack);
        }

        function render3DDoubleDoor(scene, pos, width, height, thickness, rotation) {
            const gap = 0.08; // Larger gap for clear separation (8cm)
            const panelWidth = (width - gap) / 2; // Each panel width
            
            const doorMat = new THREE.MeshLambertMaterial({ 
                color: 0x654321,
                emissive: 0x442200,
                side: THREE.DoubleSide
            });
            
            // Calculate perpendicular direction (along the wall)
            const perpX = Math.cos(rotation);
            const perpZ = -Math.sin(rotation);
            
            // Left door panel - offset to the left along wall
            const leftDoorGeom = new THREE.BoxGeometry(panelWidth, height, thickness);
            const leftDoor = new THREE.Mesh(leftDoorGeom, doorMat);
            
            // Position left panel: center minus (panelWidth/2 + gap/2)
            const leftOffset = panelWidth / 2 + gap / 2;
            leftDoor.position.set(
                pos.x - perpX * leftOffset,
                pos.y,
                pos.z - perpZ * leftOffset
            );
            leftDoor.rotation.y = rotation;
            leftDoor.castShadow = true;
            scene.add(leftDoor);
            
            console.log(`Left door at: (${leftDoor.position.x.toFixed(2)}, ${leftDoor.position.y.toFixed(2)}, ${leftDoor.position.z.toFixed(2)})`);
            
            // Right door panel - offset to the right along wall
            const rightDoor = new THREE.Mesh(leftDoorGeom, doorMat);
            
            const rightOffset = panelWidth / 2 + gap / 2;
            rightDoor.position.set(
                pos.x + perpX * rightOffset,
                pos.y,
                pos.z + perpZ * rightOffset
            );
            rightDoor.rotation.y = rotation;
            rightDoor.castShadow = true;
            scene.add(rightDoor);
            
            console.log(`Right door at: (${rightDoor.position.x.toFixed(2)}, ${rightDoor.position.y.toFixed(2)}, ${rightDoor.position.z.toFixed(2)})`);
            
            // Frame - front and back for visibility
            const frameGeom = new THREE.BoxGeometry(width + 0.15, height + 0.15, 0.08);
            const frameMat = new THREE.MeshLambertMaterial({ 
                color: 0xFF6B35,
                emissive: 0xFF6B35,
                side: THREE.DoubleSide
            });
            
            // Calculate forward direction (perpendicular to wall)
            const forwardX = Math.sin(rotation);
            const forwardZ = Math.cos(rotation);
            const frameOffset = thickness / 2 + 0.04;
            
            // Front frame
            const frameFront = new THREE.Mesh(frameGeom, frameMat);
            frameFront.position.set(
                pos.x + forwardX * frameOffset,
                pos.y,
                pos.z + forwardZ * frameOffset
            );
            frameFront.rotation.y = rotation;
            scene.add(frameFront);
            
            // Back frame
            const frameBack = new THREE.Mesh(frameGeom, frameMat);
            frameBack.position.set(
                pos.x - forwardX * frameOffset,
                pos.y,
                pos.z - forwardZ * frameOffset
            );
            frameBack.rotation.y = rotation;
            scene.add(frameBack);
            
            // Center divider line to emphasize double door
            const dividerGeom = new THREE.BoxGeometry(gap, height, thickness + 0.02);
            const dividerMat = new THREE.MeshLambertMaterial({ 
                color: 0x222222,
                emissive: 0x000000,
                side: THREE.DoubleSide
            });
            const divider = new THREE.Mesh(dividerGeom, dividerMat);
            divider.position.set(pos.x, pos.y, pos.z);
            divider.rotation.y = rotation;
            scene.add(divider);
            
            console.log(`Double door gap: ${gap}m, panel width: ${panelWidth.toFixed(3)}m`);
        }

        function render3DSlidingDoor(scene, pos, width, height, thickness, rotation) {
            const panelWidth = width / 2;
            const offset = width * 0.1;
            
            // Back sliding panel
            const backPanelGeom = new THREE.BoxGeometry(panelWidth, height, thickness);
            const glassMat = new THREE.MeshLambertMaterial({ 
                color: 0x87CEEB,
                emissive: 0x4682B4,
                opacity: 0.7,
                transparent: true,
                side: THREE.DoubleSide
            });
            const backPanel = new THREE.Mesh(backPanelGeom, glassMat);
            backPanel.position.set(pos.x, pos.y, pos.z);
            backPanel.rotation.y = rotation;
            backPanel.position.x -= Math.cos(rotation) * offset;
            backPanel.position.z += Math.sin(rotation) * offset;
            scene.add(backPanel);
            
            // Front sliding panel (offset forward)
            const frontPanel = new THREE.Mesh(backPanelGeom, glassMat);
            frontPanel.position.set(pos.x, pos.y, pos.z);
            frontPanel.rotation.y = rotation;
            frontPanel.position.x += Math.cos(rotation) * offset;
            frontPanel.position.z -= Math.sin(rotation) * offset;
            frontPanel.position.x += Math.sin(rotation) * (thickness + 0.05);
            frontPanel.position.z += Math.cos(rotation) * (thickness + 0.05);
            scene.add(frontPanel);
            
            // Track
            const trackGeom = new THREE.BoxGeometry(width + 0.2, 0.05, 0.05);
            const trackMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const topTrack = new THREE.Mesh(trackGeom, trackMat);
            topTrack.position.set(pos.x, pos.y + height / 2 + 0.05, pos.z);
            topTrack.rotation.y = rotation;
            scene.add(topTrack);
        }

        function render3DFrenchDoor(scene, pos, width, height, thickness, rotation) {
            // Similar to double door but with glass panes
            const halfWidth = width / 2;
            const gap = 0.02;
            
            // Glass material for French doors
            const glassMat = new THREE.MeshLambertMaterial({ 
                color: 0xE0F4FF,
                emissive: 0x87CEEB,
                opacity: 0.6,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            // Left door
            const leftDoorGeom = new THREE.BoxGeometry(halfWidth - gap, height, thickness);
            const leftDoor = new THREE.Mesh(leftDoorGeom, glassMat);
            leftDoor.position.set(pos.x, pos.y, pos.z);
            leftDoor.rotation.y = rotation;
            leftDoor.position.x -= Math.cos(rotation) * (halfWidth / 2 + gap / 2);
            leftDoor.position.z += Math.sin(rotation) * (halfWidth / 2 + gap / 2);
            scene.add(leftDoor);
            
            // Right door
            const rightDoor = new THREE.Mesh(leftDoorGeom, glassMat);
            rightDoor.position.set(pos.x, pos.y, pos.z);
            rightDoor.rotation.y = rotation;
            rightDoor.position.x += Math.cos(rotation) * (halfWidth / 2 + gap / 2);
            rightDoor.position.z -= Math.sin(rotation) * (halfWidth / 2 + gap / 2);
            scene.add(rightDoor);
            
            // Frame (wood colored for French doors)
            const frameGeom = new THREE.BoxGeometry(width + 0.15, height + 0.15, 0.08);
            const frameMat = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513,
                emissive: 0x654321,
                side: THREE.DoubleSide
            });
            const offsetDist = thickness / 2 + 0.04;
            
            const frameFront = new THREE.Mesh(frameGeom, frameMat);
            frameFront.position.set(pos.x, pos.y, pos.z);
            frameFront.rotation.y = rotation;
            frameFront.position.x += Math.sin(rotation) * offsetDist;
            frameFront.position.z += Math.cos(rotation) * offsetDist;
            scene.add(frameFront);
        }

        function render3DBifoldDoor(scene, pos, width, height, thickness, rotation) {
            // Four folded panels
            const panelWidth = width / 4;
            const foldAngle = Math.PI / 6;
            
            const doorMat = new THREE.MeshLambertMaterial({ 
                color: 0x654321,
                emissive: 0x442200,
                side: THREE.DoubleSide
            });
            
            for (let i = 0; i < 4; i++) {
                const panelGeom = new THREE.BoxGeometry(panelWidth, height, thickness);
                const panel = new THREE.Mesh(panelGeom, doorMat);
                panel.position.set(pos.x, pos.y, pos.z);
                
                const baseOffset = (i - 1.5) * panelWidth;
                const angleOffset = (i % 2 === 0) ? foldAngle : -foldAngle;
                
                panel.rotation.y = rotation + angleOffset;
                panel.position.x += Math.cos(rotation) * baseOffset + Math.sin(rotation + angleOffset) * thickness;
                panel.position.z -= Math.sin(rotation) * baseOffset + Math.cos(rotation + angleOffset) * thickness;
                scene.add(panel);
            }
            
            // Track
            const trackGeom = new THREE.BoxGeometry(width, 0.05, 0.05);
            const trackMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const track = new THREE.Mesh(trackGeom, trackMat);
            track.position.set(pos.x, pos.y + height / 2, pos.z);
            track.rotation.y = rotation;
            scene.add(track);
        }

        function render3DPocketDoor(scene, pos, width, height, thickness, rotation) {
            // Door panel partially visible sliding into wall
            const doorGeom = new THREE.BoxGeometry(width * 0.3, height, thickness);
            const doorMat = new THREE.MeshLambertMaterial({ 
                color: 0x654321,
                emissive: 0x442200,
                opacity: 0.8,
                transparent: true,
                side: THREE.DoubleSide
            });
            const doorMesh = new THREE.Mesh(doorGeom, doorMat);
            doorMesh.position.set(pos.x, pos.y, pos.z);
            doorMesh.rotation.y = rotation;
            // Offset to side to show it sliding into wall
            doorMesh.position.x -= Math.cos(rotation) * width * 0.35;
            doorMesh.position.z += Math.sin(rotation) * width * 0.35;
            scene.add(doorMesh);
            
            // Pocket opening indicator
            const pocketGeom = new THREE.BoxGeometry(width * 0.7, height, 0.02);
            const pocketMat = new THREE.MeshLambertMaterial({ 
                color: 0x333333,
                emissive: 0x111111,
                side: THREE.DoubleSide
            });
            const pocket = new THREE.Mesh(pocketGeom, pocketMat);
            pocket.position.set(pos.x, pos.y, pos.z);
            pocket.rotation.y = rotation;
            scene.add(pocket);
        }

        function render3DDutchDoor(scene, pos, width, height, thickness, rotation) {
            const topHeight = height * 0.5;
            const bottomHeight = height * 0.5;
            const gap = 0.05;
            
            const doorMat = new THREE.MeshLambertMaterial({ 
                color: 0x654321,
                emissive: 0x442200,
                side: THREE.DoubleSide
            });
            
            // Top half
            const topGeom = new THREE.BoxGeometry(width, topHeight - gap / 2, thickness);
            const topDoor = new THREE.Mesh(topGeom, doorMat);
            topDoor.position.set(pos.x, pos.y + bottomHeight / 2 + gap / 2, pos.z);
            topDoor.rotation.y = rotation;
            scene.add(topDoor);
            
            // Bottom half
            const bottomGeom = new THREE.BoxGeometry(width, bottomHeight - gap / 2, thickness);
            const bottomDoor = new THREE.Mesh(bottomGeom, doorMat);
            bottomDoor.position.set(pos.x, pos.y - topHeight / 2 - gap / 2, pos.z);
            bottomDoor.rotation.y = rotation;
            scene.add(bottomDoor);
            
            // Divider line
            const dividerGeom = new THREE.BoxGeometry(width + 0.1, 0.02, thickness + 0.02);
            const dividerMat = new THREE.MeshLambertMaterial({ 
                color: 0x333333,
                emissive: 0x111111
            });
            const divider = new THREE.Mesh(dividerGeom, dividerMat);
            divider.position.set(pos.x, pos.y, pos.z);
            divider.rotation.y = rotation;
            scene.add(divider);
            
            // Frame
            const frameGeom = new THREE.BoxGeometry(width + 0.15, height + 0.15, 0.08);
            const frameMat = new THREE.MeshLambertMaterial({ 
                color: 0xFF6B35,
                emissive: 0xFF6B35,
                side: THREE.DoubleSide
            });
            const offsetDist = thickness / 2 + 0.04;
            
            const frameFront = new THREE.Mesh(frameGeom, frameMat);
            frameFront.position.set(pos.x, pos.y, pos.z);
            frameFront.rotation.y = rotation;
            frameFront.position.x += Math.sin(rotation) * offsetDist;
            frameFront.position.z += Math.cos(rotation) * offsetDist;
            scene.add(frameFront);
        }
        
        // 3D Window Type Rendering Functions
        function render3DDoubleHungWindow(scene, pos, width, height, wallThick, rotation) {
            // Opening
            const openingGeom = new THREE.BoxGeometry(width, height, wallThick);
            const openingMat = new THREE.MeshLambertMaterial({ 
                color: 0x000000,
                transparent: true, 
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const opening = new THREE.Mesh(openingGeom, openingMat);
            opening.position.set(pos.x, pos.y, pos.z);
            opening.rotation.y = rotation;
            scene.add(opening);
            
            // Glass (two panes)
            const glassMat = new THREE.MeshLambertMaterial({ 
                color: 0x87CEEB,
                transparent: true, 
                opacity: 0.5,
                emissive: 0x4A90E2,
                side: THREE.DoubleSide
            });
            
            // Top pane
            const topGlassGeom = new THREE.BoxGeometry(width * 0.9, height * 0.45, wallThick * 0.3);
            const topGlass = new THREE.Mesh(topGlassGeom, glassMat);
            topGlass.position.set(pos.x, pos.y + height * 0.05, pos.z);
            topGlass.rotation.y = rotation;
            scene.add(topGlass);
            
            // Bottom pane
            const bottomGlass = new THREE.Mesh(topGlassGeom, glassMat);
            bottomGlass.position.set(pos.x, pos.y - height * 0.05, pos.z);
            bottomGlass.rotation.y = rotation;
            scene.add(bottomGlass);
            
            // Frame
            const frameThick = wallThick * 1.1;
            const frameWidth = 0.1;
            const frameMat = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xCCCCCC,
                side: THREE.DoubleSide
            });
            
            // Horizontal divider
            const dividerGeom = new THREE.BoxGeometry(width, 0.03, frameThick);
            const divider = new THREE.Mesh(dividerGeom, frameMat);
            divider.position.set(pos.x, pos.y, pos.z);
            divider.rotation.y = rotation;
            scene.add(divider);
            
            // Outer frame
            addWindowFrame(scene, pos, width, height, frameWidth, frameThick, rotation, frameMat);
        }

        function render3DSingleHungWindow(scene, pos, width, height, wallThick, rotation) {
            // Similar to double hung but bottom pane only
            const openingGeom = new THREE.BoxGeometry(width, height, wallThick);
            const openingMat = new THREE.MeshLambertMaterial({ 
                color: 0x000000,
                transparent: true, 
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const opening = new THREE.Mesh(openingGeom, openingMat);
            opening.position.set(pos.x, pos.y, pos.z);
            opening.rotation.y = rotation;
            scene.add(opening);
            
            // Glass - single pane at bottom
            const glassMat = new THREE.MeshLambertMaterial({ 
                color: 0x87CEEB,
                transparent: true, 
                opacity: 0.5,
                emissive: 0x4A90E2,
                side: THREE.DoubleSide
            });
            const glassGeom = new THREE.BoxGeometry(width * 0.9, height * 0.9, wallThick * 0.3);
            const glass = new THREE.Mesh(glassGeom, glassMat);
            glass.position.set(pos.x, pos.y, pos.z);
            glass.rotation.y = rotation;
            scene.add(glass);
            
            // Frame with emphasis on bottom half
            const frameThick = wallThick * 1.1;
            const frameWidth = 0.1;
            const frameMat = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xCCCCCC,
                side: THREE.DoubleSide
            });
            addWindowFrame(scene, pos, width, height, frameWidth, frameThick, rotation, frameMat);
        }

        function render3DCasementWindow(scene, pos, width, height, wallThick, rotation) {
            // Window slightly open to show it's casement
            const openingGeom = new THREE.BoxGeometry(width, height, wallThick);
            const openingMat = new THREE.MeshLambertMaterial({ 
                color: 0x000000,
                transparent: true, 
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const opening = new THREE.Mesh(openingGeom, openingMat);
            opening.position.set(pos.x, pos.y, pos.z);
            opening.rotation.y = rotation;
            scene.add(opening);
            
            // Glass panel - angled to show opening
            const glassMat = new THREE.MeshLambertMaterial({ 
                color: 0x87CEEB,
                transparent: true, 
                opacity: 0.6,
                emissive: 0x4A90E2,
                side: THREE.DoubleSide
            });
            const glassGeom = new THREE.BoxGeometry(width * 0.85, height * 0.85, 0.02);
            const glass = new THREE.Mesh(glassGeom, glassMat);
            glass.position.set(pos.x, pos.y, pos.z);
            glass.rotation.y = rotation + Math.PI / 6; // Angled open
            // Offset to show it's swung out
            glass.position.x += Math.sin(rotation) * wallThick * 0.3;
            glass.position.z += Math.cos(rotation) * wallThick * 0.3;
            scene.add(glass);
            
            // Frame
            const frameThick = wallThick * 1.1;
            const frameWidth = 0.12;
            const frameMat = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xCCCCCC,
                side: THREE.DoubleSide
            });
            addWindowFrame(scene, pos, width, height, frameWidth, frameThick, rotation, frameMat);
        }

        function render3DSlidingWindow(scene, pos, width, height, wallThick, rotation) {
            const openingGeom = new THREE.BoxGeometry(width, height, wallThick);
            const openingMat = new THREE.MeshLambertMaterial({ 
                color: 0x000000,
                transparent: true, 
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const opening = new THREE.Mesh(openingGeom, openingMat);
            opening.position.set(pos.x, pos.y, pos.z);
            opening.rotation.y = rotation;
            scene.add(opening);
            
            // Two glass panels - overlapping
            const glassMat = new THREE.MeshLambertMaterial({ 
                color: 0x87CEEB,
                transparent: true, 
                opacity: 0.5,
                emissive: 0x4A90E2,
                side: THREE.DoubleSide
            });
            
            const paneWidth = width / 2;
            const paneGeom = new THREE.BoxGeometry(paneWidth, height * 0.9, wallThick * 0.3);
            
            // Left pane (back layer)
            const leftPane = new THREE.Mesh(paneGeom, glassMat);
            leftPane.position.set(pos.x, pos.y, pos.z);
            leftPane.rotation.y = rotation;
            leftPane.position.x -= Math.cos(rotation) * paneWidth * 0.25;
            leftPane.position.z += Math.sin(rotation) * paneWidth * 0.25;
            scene.add(leftPane);
            
            // Right pane (front layer, offset)
            const rightPane = new THREE.Mesh(paneGeom, glassMat);
            rightPane.position.set(pos.x, pos.y, pos.z);
            rightPane.rotation.y = rotation;
            rightPane.position.x += Math.cos(rotation) * paneWidth * 0.25;
            rightPane.position.z -= Math.sin(rotation) * paneWidth * 0.25;
            rightPane.position.x += Math.sin(rotation) * 0.05;
            rightPane.position.z += Math.cos(rotation) * 0.05;
            scene.add(rightPane);
            
            // Frame
            const frameThick = wallThick * 1.1;
            const frameWidth = 0.1;
            const frameMat = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xCCCCCC,
                side: THREE.DoubleSide
            });
            addWindowFrame(scene, pos, width, height, frameWidth, frameThick, rotation, frameMat);
        }

        function render3DAwningWindow(scene, pos, width, height, wallThick, rotation) {
            // Angled at top to show it opens outward
            const openingGeom = new THREE.BoxGeometry(width, height, wallThick);
            const openingMat = new THREE.MeshLambertMaterial({ 
                color: 0x000000,
                transparent: true, 
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const opening = new THREE.Mesh(openingGeom, openingMat);
            opening.position.set(pos.x, pos.y, pos.z);
            opening.rotation.y = rotation;
            scene.add(opening);
            
            // Glass - tilted outward from top
            const glassMat = new THREE.MeshLambertMaterial({ 
                color: 0x87CEEB,
                transparent: true, 
                opacity: 0.6,
                emissive: 0x4A90E2,
                side: THREE.DoubleSide
            });
            const glassGeom = new THREE.BoxGeometry(width * 0.9, height * 0.9, 0.02);
            const glass = new THREE.Mesh(glassGeom, glassMat);
            glass.position.set(pos.x, pos.y, pos.z);
            glass.rotation.y = rotation;
            glass.rotation.x = -Math.PI / 8; // Tilt outward
            // Move out slightly
            glass.position.x += Math.sin(rotation) * wallThick * 0.3;
            glass.position.z += Math.cos(rotation) * wallThick * 0.3;
            glass.position.y += height * 0.1;
            scene.add(glass);
            
            // Frame
            const frameThick = wallThick * 1.1;
            const frameWidth = 0.1;
            const frameMat = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xCCCCCC,
                side: THREE.DoubleSide
            });
            addWindowFrame(scene, pos, width, height, frameWidth, frameThick, rotation, frameMat);
        }

        function render3DHopperWindow(scene, pos, width, height, wallThick, rotation) {
            // Similar to awning but tilts inward from bottom
            render3DDoubleHungWindow(scene, pos, width, height, wallThick, rotation); // Use basic window for now
        }

        function render3DBayWindow(scene, pos, width, height, wallThick, rotation) {
            // Three angled windows
            const sectionWidth = width / 3;
            const angle = Math.PI / 8;
            const depth = width * 0.2;
            
            // Center window
            render3DDoubleHungWindow(scene, 
                {x: pos.x + Math.sin(rotation) * depth, y: pos.y, z: pos.z + Math.cos(rotation) * depth}, 
                sectionWidth, height, wallThick, rotation);
            
            // Left window (angled)
            render3DDoubleHungWindow(scene, 
                {x: pos.x - Math.cos(rotation) * sectionWidth + Math.sin(rotation) * depth * 0.5, 
                 y: pos.y, 
                 z: pos.z + Math.sin(rotation) * sectionWidth + Math.cos(rotation) * depth * 0.5}, 
                sectionWidth, height, wallThick, rotation - angle);
            
            // Right window (angled)
            render3DDoubleHungWindow(scene, 
                {x: pos.x + Math.cos(rotation) * sectionWidth + Math.sin(rotation) * depth * 0.5, 
                 y: pos.y, 
                 z: pos.z - Math.sin(rotation) * sectionWidth + Math.cos(rotation) * depth * 0.5}, 
                sectionWidth, height, wallThick, rotation + angle);
        }

        function render3DBowWindow(scene, pos, width, height, wallThick, rotation) {
            // Similar to bay but more windows in gentle curve
            render3DBayWindow(scene, pos, width, height, wallThick, rotation);
        }

        function render3DPictureWindow(scene, pos, width, height, wallThick, rotation) {
            // Large single pane - extra thick frame
            const openingGeom = new THREE.BoxGeometry(width, height, wallThick);
            const openingMat = new THREE.MeshLambertMaterial({ 
                color: 0x000000,
                transparent: true, 
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const opening = new THREE.Mesh(openingGeom, openingMat);
            opening.position.set(pos.x, pos.y, pos.z);
            opening.rotation.y = rotation;
            scene.add(opening);
            
            // Large glass pane
            const glassMat = new THREE.MeshLambertMaterial({ 
                color: 0x87CEEB,
                transparent: true, 
                opacity: 0.4,
                emissive: 0x4A90E2,
                side: THREE.DoubleSide
            });
            const glassGeom = new THREE.BoxGeometry(width * 0.95, height * 0.95, wallThick * 0.3);
            const glass = new THREE.Mesh(glassGeom, glassMat);
            glass.position.set(pos.x, pos.y, pos.z);
            glass.rotation.y = rotation;
            scene.add(glass);
            
            // Extra thick frame for picture window
            const frameThick = wallThick * 1.2;
            const frameWidth = 0.15;
            const frameMat = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xCCCCCC,
                side: THREE.DoubleSide
            });
            addWindowFrame(scene, pos, width, height, frameWidth, frameThick, rotation, frameMat);
        }

        function render3DSkylightWindow(scene, pos, width, height, wallThick, rotation) {
            // Roof window - angled up
            render3DPictureWindow(scene, pos, width, height, wallThick, rotation);
        }

        function render3DGardenWindow(scene, pos, width, height, wallThick, rotation) {
            // Box projection with glass
            const depth = width * 0.3;
            
            // Main window
            render3DDoubleHungWindow(scene, 
                {x: pos.x + Math.sin(rotation) * depth, y: pos.y, z: pos.z + Math.cos(rotation) * depth}, 
                width, height, wallThick, rotation);
            
            // Side glass panels
            const sideMat = new THREE.MeshLambertMaterial({ 
                color: 0x87CEEB,
                transparent: true, 
                opacity: 0.4,
                emissive: 0x4A90E2,
                side: THREE.DoubleSide
            });
            
            const sideGeom = new THREE.BoxGeometry(depth, height * 0.8, 0.02);
            
            // Left side
            const leftSide = new THREE.Mesh(sideGeom, sideMat);
            leftSide.position.set(pos.x, pos.y, pos.z);
            leftSide.rotation.y = rotation - Math.PI / 2;
            leftSide.position.x -= Math.cos(rotation) * width * 0.5 + Math.sin(rotation) * depth * 0.5;
            leftSide.position.z += Math.sin(rotation) * width * 0.5 + Math.cos(rotation) * depth * 0.5;
            scene.add(leftSide);
            
            // Right side
            const rightSide = new THREE.Mesh(sideGeom, sideMat);
            rightSide.position.set(pos.x, pos.y, pos.z);
            rightSide.rotation.y = rotation + Math.PI / 2;
            rightSide.position.x += Math.cos(rotation) * width * 0.5 + Math.sin(rotation) * depth * 0.5;
            rightSide.position.z -= Math.sin(rotation) * width * 0.5 + Math.cos(rotation) * depth * 0.5;
            scene.add(rightSide);
        }

        // Helper function to add window frame
        function addWindowFrame(scene, pos, width, height, frameWidth, frameThick, rotation, frameMat) {
            // Top
            const topFrameGeom = new THREE.BoxGeometry(width + frameWidth * 2, frameWidth, frameThick);
            const topFrame = new THREE.Mesh(topFrameGeom, frameMat);
            topFrame.position.set(pos.x, pos.y + height / 2 + frameWidth / 2, pos.z);
            topFrame.rotation.y = rotation;
            scene.add(topFrame);
            
            // Bottom
            const bottomFrame = new THREE.Mesh(topFrameGeom, frameMat);
            bottomFrame.position.set(pos.x, pos.y - height / 2 - frameWidth / 2, pos.z);
            bottomFrame.rotation.y = rotation;
            scene.add(bottomFrame);
            
            // Left
            const sideFrameGeom = new THREE.BoxGeometry(frameWidth, height, frameThick);
            const leftFrame = new THREE.Mesh(sideFrameGeom, frameMat);
            leftFrame.position.set(pos.x, pos.y, pos.z);
            leftFrame.rotation.y = rotation;
            leftFrame.position.x -= Math.cos(rotation) * (width / 2 + frameWidth / 2);
            leftFrame.position.z += Math.sin(rotation) * (width / 2 + frameWidth / 2);
            scene.add(leftFrame);
            
            // Right
            const rightFrame = new THREE.Mesh(sideFrameGeom, frameMat);
            rightFrame.position.set(pos.x, pos.y, pos.z);
            rightFrame.rotation.y = rotation;
            rightFrame.position.x += Math.cos(rotation) * (width / 2 + frameWidth / 2);
            rightFrame.position.z -= Math.sin(rotation) * (width / 2 + frameWidth / 2);
            scene.add(rightFrame);
        }
        
        function render3D() {
            render3DCallCount++;
            const callId = render3DCallCount;
            
            console.log('=== render3D called === (Call #' + callId + ')');
            console.log('Call stack:', new Error().stack.split('\n').slice(2, 5).join('\n'));
            console.log('Current view:', state.currentView);
            console.log('Scene children before clear:', scene.children.length);
            console.log('isRendering3D flag:', isRendering3D);
            
            // Prevent re-entrant calls
            if (isRendering3D) {
                console.log('WARNING: render3D already in progress, skipping this call (Call #' + callId + ')');
                return;
            }
            
            // Only render if we're actually in 3D mode
            if (state.currentView !== '3d') {
                console.log('WARNING: render3D called but not in 3D mode, skipping (Call #' + callId + ')');
                return;
            }
            
            // Check if scene and renderer exist
            if (!scene || !renderer) {
                console.error('ERROR: Scene or renderer not initialized! (Call #' + callId + ')');
                return;
            }
            
            isRendering3D = true;
            
            try {
                console.log('Clearing scene objects... (Call #' + callId + ')');
                while(scene.children.length > 3) scene.remove(scene.children[3]);
                console.log('Scene cleared, now has', scene.children.length, 'children (Call #' + callId + ')');
                
                // Calculate total width needed for all rooms to adjust camera
                const totalRooms = state.rooms.filter(r => r.floorPoints.length >= 3).length;
                const roomSpacing = 30;
            
            console.log('Rendering 3D view, total rooms:', totalRooms);
            
            if (totalRooms === 0) {
                console.log('WARNING: No rooms with floor points to render');
                return;
            }
            
            // DISABLED: const renderedWalls = new Set(); (duplicate filtering disabled for multi-room 3D)
            
            state.rooms.forEach((room, idx) => {
                if (room.floorPoints.length < 3) return;
                
                console.log(`Room ${idx}: ${room.name}, Doors: ${room.doors.length}, Windows: ${room.windows.length}, Position: (${room.positionX}, ${room.positionZ})`);
                
                // Use explicit position if set, otherwise use default spacing
                // Need to check for undefined/null, not falsy (because 0 is valid!)
                const offsetX = (room.positionX !== undefined && room.positionX !== null) ? room.positionX : (idx * roomSpacing);
                const offsetZ = (room.positionZ !== undefined && room.positionZ !== null) ? room.positionZ : 0;
                
                console.log(`  üìç Calculated offsets: X=${offsetX}, Z=${offsetZ} (roomSpacing=${roomSpacing})`);
                console.log(`  üìê Floor points: ${room.floorPoints.length} points`);
                
                // Floor and ceiling removed - showing only walls
                
                // Create shape for reference (used for dimensions later)
                const shape = new THREE.Shape();
                shape.moveTo(-(room.floorPoints[0].x / 30 + offsetX), -(room.floorPoints[0].y / 30 + offsetZ));
                room.floorPoints.forEach((p, i) => {
                    if (i > 0) shape.lineTo(-(p.x / 30 + offsetX), -(p.y / 30 + offsetZ));
                });
                shape.closePath();
                
                // Walls - check for cuts and render accordingly
                room.walls.forEach((wall, wallIdx) => {
                    // Skip duplicate walls (DISABLED for multi-room 3D - each room shows its own walls)
                    // const wKey = `${Math.round(wall.start.x/10)*10},${Math.round(wall.start.y/10)*10}-${Math.round(wall.end.x/10)*10},${Math.round(wall.end.y/10)*10}`;
                    // const wKeyRev = `${Math.round(wall.end.x/10)*10},${Math.round(wall.end.y/10)*10}-${Math.round(wall.start.x/10)*10},${Math.round(wall.start.y/10)*10}`;
                    // if (renderedWalls.has(wKey) || renderedWalls.has(wKeyRev)) return;
                    // renderedWalls.add(wKey);
                    
                    const len = Math.sqrt((wall.end.x - wall.start.x)**2 + (wall.end.y - wall.start.y)**2) / 30;
                    const wallThickness = (room.wallThickness || 4) / 12 * 0.3048; // Convert inches to meters
                    
                    const mx = -((wall.start.x + wall.end.x) / 2 / 30 + offsetX);
                    const mz = -((wall.start.y + wall.end.y) / 2 / 30 + offsetZ);
                    const angle = Math.atan2(wall.end.y - wall.start.y, wall.end.x - wall.start.x);
                    
                    // Check if wall has cuts
                    const hasCuts = (wall.cuts && wall.cuts.length > 0) || (wall.missingWalls && wall.missingWalls.length > 0);
                    
                    if (hasCuts) {
                        // Wall has cuts or missing walls - render as separate segments with gaps
                        const sortedCuts = getWallOpenings(wall);
                        
                        console.log(`  Wall ${wallIdx} HAS CUTS - Length: ${wall.length} ft`);
                        console.log(`  Cuts:`, sortedCuts);
                        
                        // Calculate all segments (wall pieces and gaps)
                        const segments = [];
                        let pos = 0;
                        sortedCuts.forEach(cut => {
                            if (cut.startDist > pos) segments.push({ type: 'wall', start: pos, end: cut.startDist });
                            segments.push({ 
                                type: 'gap', 
                                start: cut.startDist, 
                                end: cut.endDist,
                                height: cut.height || room.ceilingHeight,
                                floorDistance: cut.floorDistance || 0
                            });
                            pos = cut.endDist;
                        });
                        if (pos < parseFloat(wall.length)) segments.push({ type: 'wall', start: pos, end: parseFloat(wall.length) });
                        
                        console.log(`  Segments:`, segments);
                        let totalLength = segments.reduce((sum, s) => sum + (s.end - s.start), 0);
                        console.log(`  Total segment length: ${totalLength.toFixed(2)} ft (should be ${wall.length} ft)`);
                        
                        // Render each segment
                        segments.forEach((seg, i) => {
                            if (seg.type === 'wall') {
                                // Render wall segment without extensions
                                const segStart = seg.start;
                                const segEnd = seg.end;
                                
                                // Calculate segment endpoints in pixels
                                const t1 = segStart / parseFloat(wall.length);
                                const t2 = segEnd / parseFloat(wall.length);
                                
                                const x1 = wall.start.x + (wall.end.x - wall.start.x) * t1;
                                const y1 = wall.start.y + (wall.end.y - wall.start.y) * t1;
                                const x2 = wall.start.x + (wall.end.x - wall.start.x) * t2;
                                const y2 = wall.start.y + (wall.end.y - wall.start.y) * t2;
                                
                                // Segment center and length in pixels
                                const segCenterX = (x1 + x2) / 2;
                                const segCenterY = (y1 + y2) / 2;
                                const segPixelLen = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
                                const segLenFeet = segPixelLen / 30;  // Use feet like normal walls
                                
                                // Convert to 3D coordinates
                                const segX = -(segCenterX / 30 + offsetX);
                                const segZ = -(segCenterY / 30 + offsetZ);
                                
                                console.log(`    Segment ${i}: wall ${seg.start.toFixed(1)}-${seg.end.toFixed(1)} ft, pixels (${x1.toFixed(0)}, ${y1.toFixed(0)}) to (${x2.toFixed(0)}, ${y2.toFixed(0)}), 3D pos (${segX.toFixed(2)}, ${segZ.toFixed(2)})`);
                            
                                // Render wall segment (using feet)
                                const segGeom = new THREE.BoxGeometry(segLenFeet, room.ceilingHeight * 0.3048, wallThickness);
                                const segMat = new THREE.MeshLambertMaterial({ color: 0xF5E6D3 }); // Warm beige
                                const segMesh = new THREE.Mesh(segGeom, segMat);
                                segMesh.position.set(segX, room.ceilingHeight * 0.3048 / 2, segZ);
                                segMesh.rotation.y = -angle;
                                segMesh.castShadow = true;
                                segMesh.receiveShadow = true;
                                scene.add(segMesh);
                                
                                if (SHOW_3D_DIMENSIONS) {
                                
                                // Add dimension label
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                canvas.width = 256;
                                canvas.height = 64;
                                ctx.fillStyle = '#FFFFFF';
                                ctx.fillRect(0, 0, 256, 64);
                                ctx.font = 'bold 32px Arial';
                                ctx.fillStyle = '#000000';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(`${(seg.end - seg.start).toFixed(1)} ft`, 128, 32);
                                
                                const tex = new THREE.CanvasTexture(canvas);
                                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
                                const perpX = -Math.sin(angle) * 0.5;
                                const perpZ = Math.cos(angle) * 0.5;
                                sprite.position.set(segX + perpX, room.ceilingHeight * 0.3048 / 2, segZ + perpZ);
                                sprite.scale.set(2, 0.5, 1);
                                scene.add(sprite);
                                
                                }
                            } else if (seg.type === 'gap') {
                                try {
                                    // Render gap with bottom wall, opening, and top wall
                                    const segStart = seg.start;
                                    const segEnd = seg.end;
                                    const openingHeight = seg.height || 3;
                                    const floorDist = seg.floorDistance || 0;
                                    
                                    // Calculate segment endpoints
                                    const t1 = segStart / parseFloat(wall.length);
                                    const t2 = segEnd / parseFloat(wall.length);
                                    
                                    const x1 = wall.start.x + (wall.end.x - wall.start.x) * t1;
                                    const y1 = wall.start.y + (wall.end.y - wall.start.y) * t1;
                                    const x2 = wall.start.x + (wall.end.x - wall.start.x) * t2;
                                    const y2 = wall.start.y + (wall.end.y - wall.start.y) * t2;
                                    
                                    const segCenterX = (x1 + x2) / 2;
                                    const segCenterY = (y1 + y2) / 2;
                                    const segPixelLen = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
                                    const segLenFeet = segPixelLen / 30;
                                    
                                    const segX = -(segCenterX / 30 + offsetX);
                                    const segZ = -(segCenterY / 30 + offsetZ);
                                    
                                    const ceilingHeightFeet = room.ceilingHeight || 8;
                                    
                                    console.log(`    Segment ${i}: GAP ${seg.start.toFixed(1)}-${seg.end.toFixed(1)} ft, height: ${openingHeight} ft, floor dist: ${floorDist} ft`);
                                    
                                    // 1. Bottom wall (floor to opening start)
                                    if (floorDist > 0.01) {
                                        const bottomHeight = floorDist * 0.3048;
                                        const bottomY = bottomHeight / 2;
                                        const bottomGeom = new THREE.BoxGeometry(segLenFeet, bottomHeight, wallThickness);
                                        const bottomMat = new THREE.MeshLambertMaterial({ color: 0xF5E6D3 });
                                        const bottomMesh = new THREE.Mesh(bottomGeom, bottomMat);
                                        bottomMesh.position.set(segX, bottomY, segZ);
                                        bottomMesh.rotation.y = -angle;
                                        bottomMesh.castShadow = true;
                                        bottomMesh.receiveShadow = true;
                                        scene.add(bottomMesh);
                                        console.log(`      Bottom wall: floor to ${floorDist.toFixed(1)} ft`);
                                    }
                                    
                                    // 2. GAP (no wall)
                                    console.log(`      GAP: ${floorDist.toFixed(1)} ft to ${(floorDist + openingHeight).toFixed(1)} ft`);
                                    
                                    // 3. Top wall (opening end to ceiling)
                                    const topStart = floorDist + openingHeight;
                                    if (topStart < ceilingHeightFeet - 0.01) {
                                        const topHeight = (ceilingHeightFeet - topStart) * 0.3048;
                                        const topY = (topStart * 0.3048) + (topHeight / 2);
                                        const topGeom = new THREE.BoxGeometry(segLenFeet, topHeight, wallThickness);
                                        const topMat = new THREE.MeshLambertMaterial({ color: 0xF5E6D3 });
                                        const topMesh = new THREE.Mesh(topGeom, topMat);
                                        topMesh.position.set(segX, topY, segZ);
                                        topMesh.rotation.y = -angle;
                                        topMesh.castShadow = true;
                                        topMesh.receiveShadow = true;
                                        scene.add(topMesh);
                                        console.log(`      Top wall: ${topStart.toFixed(1)} ft to ${ceilingHeightFeet} ft`);
                                    }
                                    
                                    if (SHOW_3D_DIMENSIONS) {
                                        const canvas = document.createElement('canvas');
                                        const ctx = canvas.getContext('2d');
                                        canvas.width = 256;
                                        canvas.height = 64;
                                        ctx.fillStyle = '#FF0000';
                                        ctx.fillRect(0, 0, 256, 64);
                                        ctx.font = 'bold 32px Arial';
                                        ctx.fillStyle = '#FFFFFF';
                                        ctx.textAlign = 'center';
                                        ctx.textBaseline = 'middle';
                                        ctx.fillText(`OPENING ${(seg.end - seg.start).toFixed(1)} ft`, 128, 32);
                                        const tex = new THREE.CanvasTexture(canvas);
                                        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
                                        const perpX = -Math.sin(angle) * 0.5;
                                        const perpZ = Math.cos(angle) * 0.5;
                                        const midHeight = (floorDist + openingHeight / 2) * 0.3048;
                                        sprite.position.set(segX + perpX, midHeight, segZ + perpZ);
                                        sprite.scale.set(2, 0.5, 1);
                                        scene.add(sprite);
                                    }
                                } catch (error) {
                                    console.error(`Error rendering gap segment:`, error);
                                }
                            }
                        });
                    } else {
                        // Normal wall without cuts - render as single piece
                        // Add small extension to close corner gaps (2 inches = 0.167 ft)
                        const extension = wallThickness * 2.0; // overlap ends by ~2x thickness to hide corner seams
                        const extendedLen = len + extension;
                        
                        const wallGeom = new THREE.BoxGeometry(extendedLen, room.ceilingHeight * 0.3048, wallThickness);
                        const wallMat = new THREE.MeshLambertMaterial({ 
                            color: 0xF5E6D3, // Warm beige
                            transparent: false,
                            opacity: 1.0
                        });
                        const wallMesh = new THREE.Mesh(wallGeom, wallMat);
                        
                        wallMesh.position.set(mx, room.ceilingHeight * 0.3048 / 2, mz);
                        wallMesh.rotation.y = -angle;
                        wallMesh.castShadow = true;
                        wallMesh.receiveShadow = true;
                        scene.add(wallMesh);
                        
                        console.log(`  Wall ${wallIdx}: color=BEIGE, thickness=${wallThickness}m, position=(${mx}, ${room.ceilingHeight * 0.3048 / 2}, ${mz}), extended by ${extension.toFixed(3)}m`);
                        
                        if (SHOW_3D_DIMENSIONS) {
                        // Add dimension label to wall
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = 256;
                        canvas.height = 64;
                        
                        context.fillStyle = '#ffffff';
                        context.fillRect(0, 0, canvas.width, canvas.height);
                        context.font = 'bold 32px Arial';
                        context.fillStyle = '#000000';
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillText(`${wall.length} ft`, canvas.width / 2, canvas.height / 2);
                        
                        const texture = new THREE.CanvasTexture(canvas);
                        const labelMaterial = new THREE.SpriteMaterial({ map: texture });
                        const label = new THREE.Sprite(labelMaterial);
                        label.position.set(mx, room.ceilingHeight * 0.3048 / 2, mz);
                        label.scale.set(2, 0.5, 1);
                        scene.add(label);
                        }
                    }
                });

// Corner join posts (hide tiny gaps where wall segments meet)
;

                
                // Ceiling removed - showing only walls
                
                // Room name labels removed per user request
                // Ceiling height labels removed per user request
                
                // Doors - Render based on type
                console.log(`Rendering ${room.doors.length} doors for room ${idx}`);
                room.doors.forEach((door, doorIdx) => {
                    console.log(`  Door ${doorIdx}: x=${door.x}, y=${door.y}, width=${door.width}, rotation=${door.rotation}, type=${door.doorType || 'single'}`);
                    
                    const doorWidth = door.width / 12 * 0.3048;
                    const doorHeightInches = door.height || 80;
                    const doorHeight = doorHeightInches / 12 * 0.3048;
                    const doorThickness = 0.15;
                    const doorType = door.doorType || 'single';
                    
                    const basePosition = {
                        x: -(door.x / 30 + offsetX),
                        y: doorHeight / 2,
                        z: -(door.y / 30 + offsetZ)
                    };
                    const rotation = -(door.rotation || 0) * Math.PI / 180;
                    
                    // Render based on door type
                    switch(doorType) {
                        case 'double':
                            render3DDoubleDoor(scene, basePosition, doorWidth, doorHeight, doorThickness, rotation);
                            break;
                        case 'sliding':
                            render3DSlidingDoor(scene, basePosition, doorWidth, doorHeight, doorThickness, rotation);
                            break;
                        case 'french':
                            render3DFrenchDoor(scene, basePosition, doorWidth, doorHeight, doorThickness, rotation);
                            break;
                        case 'bifold':
                            render3DBifoldDoor(scene, basePosition, doorWidth, doorHeight, doorThickness, rotation);
                            break;
                        case 'pocket':
                            render3DPocketDoor(scene, basePosition, doorWidth, doorHeight, doorThickness, rotation);
                            break;
                        case 'dutch':
                            render3DDutchDoor(scene, basePosition, doorWidth, doorHeight, doorThickness, rotation);
                            break;
                        case 'single':
                        default:
                            render3DSingleDoor(scene, basePosition, doorWidth, doorHeight, doorThickness, rotation);
                            break;
                    }
                    
                    console.log(`  Door mesh position: (${basePosition.x}, ${basePosition.y}, ${basePosition.z})`);
                });
                
                // Windows - Render based on type
                console.log(`Rendering ${room.windows.length} windows for room ${idx}`);
                room.windows.forEach((win, winIdx) => {
                    console.log(`  Window ${winIdx}: x=${win.x}, y=${win.y}, width=${win.width}, height=${win.height}, rotation=${win.rotation}, type=${win.windowType || 'double-hung'}`);
                    
                    const winWidth = win.width / 12 * 0.3048;
                    const winHeightInches = win.height || 36;
                    const winHeight = winHeightInches / 12 * 0.3048;
                    const heightFromFloor = (win.heightFromFloor !== undefined && win.heightFromFloor !== null ? win.heightFromFloor : 3.0) * 0.3048;
                    const wallThick = (room.wallThickness || 4) / 12 * 0.3048;
                    const windowType = win.windowType || 'double-hung';
                    
                    const basePosition = {
                        x: -(win.x / 30 + offsetX),
                        y: heightFromFloor + winHeight / 2,
                        z: -(win.y / 30 + offsetZ)
                    };
                    const rotation = -(win.rotation || 0) * Math.PI / 180;
                    
                    // Render based on window type
                    switch(windowType) {
                        case 'single-hung':
                            render3DSingleHungWindow(scene, basePosition, winWidth, winHeight, wallThick, rotation);
                            break;
                        case 'casement':
                            render3DCasementWindow(scene, basePosition, winWidth, winHeight, wallThick, rotation);
                            break;
                        case 'sliding':
                            render3DSlidingWindow(scene, basePosition, winWidth, winHeight, wallThick, rotation);
                            break;
                        case 'awning':
                            render3DAwningWindow(scene, basePosition, winWidth, winHeight, wallThick, rotation);
                            break;
                        case 'hopper':
                            render3DHopperWindow(scene, basePosition, winWidth, winHeight, wallThick, rotation);
                            break;
                        case 'bay':
                            render3DBayWindow(scene, basePosition, winWidth, winHeight, wallThick, rotation);
                            break;
                        case 'bow':
                            render3DBowWindow(scene, basePosition, winWidth, winHeight, wallThick, rotation);
                            break;
                        case 'picture':
                            render3DPictureWindow(scene, basePosition, winWidth, winHeight, wallThick, rotation);
                            break;
                        case 'skylight':
                            render3DSkylightWindow(scene, basePosition, winWidth, winHeight, wallThick, rotation);
                            break;
                        case 'garden':
                            render3DGardenWindow(scene, basePosition, winWidth, winHeight, wallThick, rotation);
                            break;
                        case 'double-hung':
                        default:
                            render3DDoubleHungWindow(scene, basePosition, winWidth, winHeight, wallThick, rotation);
                            break;
                    }
                    
                    console.log(`  Window assembly complete`);
                });
                
                // Wall dimension labels removed from 3D view per user request
                // Room name labels also removed per user request
                // 3D view is now completely clean - only geometry
            });
            
            console.log('Camera position:', camera.position.x, camera.position.y, camera.position.z);
            console.log('About to render scene (Call #' + callId + ')...');
            console.log('About to render scene (Call #' + callId + ')...');
            console.log('Final scene children count:', scene.children.length);
            renderer.render(scene, camera);
            console.log('3D render complete (Call #' + callId + '), scene has', scene.children.length, 'children');
            
            } catch (error) {
                console.error('ERROR in render3D (Call #' + callId + '):', error);
                console.error('Stack:', error.stack);
            } finally {
                isRendering3D = false;
                console.log('=== render3D complete, flag reset (Call #' + callId + ') ===');
            }
        }

        // Note: This function is disabled - the animate() loop inside init3D() handles all 3D rendering
        // Keeping this here for reference only
        function animate3D() {
            // DISABLED - removed to prevent conflicts with init3D's animate() loop
            // The animate() function inside init3D() already handles all rendering
            console.log('animate3D() called but disabled - init3D animate() loop handles rendering');
        }

        // Calculate net wall area after subtracting doors, windows, and openings
        function calculateNetWallArea(room) {
            if (!room || !room.walls || room.walls.length === 0) return 0;
            
            // Calculate gross wall area (perimeter √ó height)
            const perim = room.walls.reduce((s, w) => s + parseFloat(w.length), 0);
            let grossWallArea = perim * room.ceilingHeight;
            
            // Subtract door areas
            room.doors.forEach(door => {
                const doorWidthFt = door.width / 12; // Convert inches to feet
                const doorHeightFt = door.height / 12; // Convert inches to feet
                const doorArea = doorWidthFt * doorHeightFt;
                grossWallArea -= doorArea;
            });
            
            // Subtract window areas
            room.windows.forEach(window => {
                const windowWidthFt = window.width / 12; // Convert inches to feet
                const windowHeightFt = window.height / 12; // Convert inches to feet
                const windowArea = windowWidthFt * windowHeightFt;
                grossWallArea -= windowArea;
            });
            
            // Subtract wall cut/opening areas
            room.walls.forEach(wall => {
                if (wall.cuts && wall.cuts.length > 0) {
                    wall.cuts.forEach(cut => {
                        // Openings are typically floor to ceiling
                        const openingWidth = cut.width || (cut.endDist - cut.startDist);
                        const openingHeight = cut.height || room.ceilingHeight;
                        const openingArea = openingWidth * openingHeight;
                        grossWallArea -= openingArea;
                    });
                }
            });
            
            return Math.max(0, grossWallArea); // Don't allow negative
        }

        function updateStats() {
            const room = getCurrentRoom();
            if (!room) return;
            
            let area = 0;
            if (room.floorPoints.length >= 3) {
                for (let i = 0; i < room.floorPoints.length; i++) {
                    const j = (i + 1) % room.floorPoints.length;
                    area += room.floorPoints[i].x * room.floorPoints[j].y;
                    area -= room.floorPoints[j].x * room.floorPoints[i].y;
                }
                area = Math.abs(area / 2) / 900;
            }
            
            const perimeter = room.walls.reduce((s, w) => s + parseFloat(w.length), 0);
            
            // REMOVED - Stats panel no longer exists
            // document.getElementById('statArea').textContent = area.toFixed(1) + ' sq ft';
            // document.getElementById('statPerimeter').textContent = perimeter.toFixed(1) + ' ft';
            // document.getElementById('statDoors').textContent = room.doors.length;
            // document.getElementById('statWindows').textContent = room.windows.length;
        }

        function saveProject() {
            showFilenameModal('save');
        }
        
        function exportReport() {
            showFilenameModal('export');
        }
        
        function exportXactimateCSV() {
            showFilenameModal('xactimate-csv');
        }
        
        function exportXactimateReport() {
            showFilenameModal('xactimate-report');
        }
        
        function exportForExcel() {
            showFilenameModal('excel');
        }
        
        function toggleExportMenu() {
            const menu = document.getElementById('exportMenu');
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        }
        
        // Close export menu when clicking outside
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('exportMenu');
            const btn = document.getElementById('exportBtn');
            if (menu && btn && !menu.contains(e.target) && !btn.contains(e.target)) {
                menu.style.display = 'none';
            }
        });
        
        // Filename Modal Functions
        let filenameAction = null;
        
        function showFilenameModal(action) {
            filenameAction = action;
            
            const modal = document.getElementById('filenameModal');
            const input = document.getElementById('filenameInput');
            const title = document.getElementById('filenameModalTitle');
            const confirmBtn = document.getElementById('filenameConfirmBtn');
            
            if (action === 'save') {
                title.textContent = 'üíæ Save Project';
                confirmBtn.textContent = 'Save';
            } else if (action === 'export') {
                title.textContent = 'üìÑ Export Report';
                confirmBtn.textContent = 'Export';
            } else if (action === 'xactimate-csv') {
                title.textContent = 'üìä Export Xactimate CSV';
                confirmBtn.textContent = 'Export CSV';
            } else if (action === 'xactimate-report') {
                title.textContent = 'üìã Export Xactimate Report';
                confirmBtn.textContent = 'Export Report';
            } else if (action === 'excel') {
                title.textContent = 'üìä Export for Excel';
                confirmBtn.textContent = 'Export Excel File';
            }
            
            // Pre-fill with current project name
            input.value = state.projectName;
            
            modal.style.display = 'flex';
            
            // Focus and select input
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
            
            // Close export menu
            const exportMenu = document.getElementById('exportMenu');
            if (exportMenu) exportMenu.style.display = 'none';
        }
        
        function confirmFilename() {
            const input = document.getElementById('filenameInput');
            const filename = input.value.trim();
            
            if (!filename) {
                showToast('‚ùå Please enter a filename');
                return;
            }
            
            // Clean filename (remove invalid characters)
            const cleanFilename = filename.replace(/[<>:"/\\|?*]/g, '-');
            
            // Check if filename already exists (only for save action)
            if (filenameAction === 'save') {
                try {
                    const savedProjects = JSON.parse(localStorage.getItem('cochran_saved_projects') || '{}');
                    if (savedProjects[cleanFilename]) {
                        // Filename exists - show confirmation
                        showDuplicateFilenameDialog(cleanFilename);
                        return; // Don't proceed yet
                    }
                } catch (error) {
                    console.error('Error checking for duplicates:', error);
                }
            }
            
            // Update project name
            state.projectName = cleanFilename;
            updateProjectNameDisplay();
            
            // Close modal
            document.getElementById('filenameModal').style.display = 'none';
            
            // Perform the action
            if (filenameAction === 'save') {
                performSave(cleanFilename);
            } else if (filenameAction === 'export') {
                performExport(cleanFilename);
            } else if (filenameAction === 'xactimate-csv') {
                performXactimateCSV(cleanFilename);
            } else if (filenameAction === 'xactimate-report') {
                performXactimateReport(cleanFilename);
            } else if (filenameAction === 'excel') {
                performExcelExport(cleanFilename);
            }
            
            filenameAction = null;
        }
        
        function showDuplicateFilenameDialog(filename) {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 12px;
                max-width: 450px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #FF9800; font-size: 20px;">‚ö†Ô∏è File Already Exists</h3>
                <p style="margin: 0 0 25px 0; color: #555; line-height: 1.6;">
                    A project named "<strong>${filename}</strong>" already exists.<br>
                    Do you want to replace it or use a different name?
                </p>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="duplicateUseDifferent" style="padding: 10px 20px; background: #999; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 14px;">
                        Use Different Name
                    </button>
                    <button id="duplicateReplace" style="padding: 10px 20px; background: #FF5722; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 14px;">
                        Replace
                    </button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Use Different Name - close this dialog and keep filename modal open
            document.getElementById('duplicateUseDifferent').onclick = () => {
                document.body.removeChild(overlay);
                // Filename modal stays open for user to edit
            };
            
            // Replace - proceed with save
            document.getElementById('duplicateReplace').onclick = () => {
                document.body.removeChild(overlay);
                
                // Update project name
                state.projectName = filename;
                updateProjectNameDisplay();
                
                // Close filename modal
                document.getElementById('filenameModal').style.display = 'none';
                
                // Perform save
                performSave(filename);
                
                filenameAction = null;
            };
        }
        
        function cancelFilename() {
            document.getElementById('filenameModal').style.display = 'none';
            filenameAction = null;
        }
        
        function performSave(filename) {
            const data = {
                projectName: filename,
                rooms: state.rooms,
                savedDate: new Date().toISOString()
            };
            const jsonString = JSON.stringify(data, null, 2);
            
            // Save to localStorage
            try {
                const savedProjects = JSON.parse(localStorage.getItem('cochran_saved_projects') || '{}');
                savedProjects[filename] = data;
                localStorage.setItem('cochran_saved_projects', JSON.stringify(savedProjects));
                
                // Update current project name
                state.projectName = filename;
                updateProjectNameDisplay();
                
                showToast(`‚úì "${filename}" saved to browser storage!`);
                
                // On iPad: Also create downloadable text file
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                             (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                
                if (isIOS) {
                    // Open data in new tab - Safari can save from there
                    const dataUrl = 'data:application/json;charset=utf-8,' + encodeURIComponent(jsonString);
                    const newTab = window.open(dataUrl, '_blank');
                    if (newTab) {
                        showToast(`‚úì Saved! File opened in new tab - tap Share ‚Üí Save to Files`);
                    } else {
                        // Fallback: copy to clipboard
                        navigator.clipboard.writeText(jsonString).then(() => {
                            showToast(`‚úì Saved! Also copied to clipboard - paste into Notes`);
                        });
                    }
                } else {
                    // Desktop: Download file
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${filename}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showToast(`‚úì Saved & downloaded "${filename}.json"`);
                }
            } catch (error) {
                showToast(`‚ùå Save failed: ${error.message}`);
                console.error('Save error:', error);
            }
        }
        
        function copyToClipboardFallback(data, filename) {
            // Fallback: Copy to clipboard
            navigator.clipboard.writeText(data).then(() => {
                showToast(`‚úì Project data copied to clipboard! Paste into Notes app and save as "${filename}.json"`);
            }).catch(() => {
                // Last resort: Show in alert
                showToast(`‚ùå Save failed. Try using desktop browser or copy data manually.`);
                console.log('Project data:', data);
            });
        }
        
        function copyProjectData() {
            const data = {
                projectName: state.projectName || 'Untitled',
                rooms: state.rooms,
                savedDate: new Date().toISOString()
            };
            const jsonString = JSON.stringify(data, null, 2);
            
            navigator.clipboard.writeText(jsonString).then(() => {
                showToast(`‚úì Project data copied! Paste into Notes or text file to save.`);
            }).catch((error) => {
                showToast(`‚ùå Copy failed: ${error.message}`);
            });
        }
        
        // AUTO-SAVE to localStorage (works perfectly on iPad!)
        function autoSaveToLocalStorage() {
            try {
                const data = {
                    projectName: state.projectName || 'Untitled',
                    rooms: state.rooms,
                    savedDate: new Date().toISOString()
                };
                localStorage.setItem('cochran_property_autosave', JSON.stringify(data));
                console.log('‚úì Auto-saved to browser storage');
            } catch (error) {
                console.error('Auto-save failed:', error);
            }
        }
        
        // Auto-save disabled - manual save only
        // setInterval(autoSaveToLocalStorage, 30000);
        
        // Also save on any change
        function triggerAutoSave() {
            autoSaveToLocalStorage();
        }
        
        // Load auto-saved data on startup
        function loadAutoSave() {
            try {
                const saved = localStorage.getItem('cochran_property_autosave');
                if (saved) {
                    const data = JSON.parse(saved);
                    const savedDate = new Date(data.savedDate);
                    const minutes = Math.round((Date.now() - savedDate.getTime()) / 60000);
                    
                    if (confirm(`Found auto-saved project "${data.projectName}" from ${minutes} minutes ago. Load it?`)) {
                        state.rooms = data.rooms;
                        state.projectName = data.projectName;
                        updateProjectNameDisplay();
                        updateRoomList();
                        redraw2D();
                        showToast(`‚úì Loaded auto-saved project: ${data.projectName}`);
                    }
                }
            } catch (error) {
                console.error('Load auto-save failed:', error);
            }
        }
        
        function performExport(filename) {
            let report = `COCHRAN CLAIMS - PROPERTY REPORT\n`;
            report += `Property: ${filename}\n`;
            report += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nRooms (${state.rooms.length}):\n\n`;
            state.rooms.forEach((room, i) => {
                let area = 0;
                if (room.floorPoints.length >= 3) {
                    for (let j = 0; j < room.floorPoints.length; j++) {
                        const k = (j + 1) % room.floorPoints.length;
                        area += room.floorPoints[j].x * room.floorPoints[k].y;
                        area -= room.floorPoints[k].x * room.floorPoints[j].y;
                    }
                    area = Math.abs(area / 2) / 900;
                }
                const perim = room.walls.reduce((s, w) => s + parseFloat(w.length), 0);
                const grossWallArea = perim * room.ceilingHeight;
                const netWallArea = calculateNetWallArea(room);
                
                report += `${i+1}. ${room.name}\n`;
                report += `   Floor Area: ${area.toFixed(1)} sq ft\n`;
                report += `   Perimeter: ${perim.toFixed(1)} ft\n`;
                report += `   Ceiling Height: ${room.ceilingHeight} ft\n`;
                report += `   Wall Area (Gross): ${grossWallArea.toFixed(1)} sq ft\n`;
                report += `   Wall Area (Net): ${netWallArea.toFixed(1)} sq ft\n`;
                
                // Position info
                if (state.rooms.length > 1) {
                    report += `   Position: (${room.positionX || 0}, ${room.positionZ || 0})\n`;
                }
                report += '\n';
                
                // Door details
                if (room.doors.length > 0) {
                    report += `   DOORS (${room.doors.length}):\n`;
                    room.doors.forEach((door, di) => {
                        const wall = room.walls[door.wallIndex];
                        report += `   ${di+1}. ${door.width}" wide on ${wall ? wall.name : 'wall'}\n`;
                        if (door.distanceFromLeft) {
                            report += `      Position: ${door.distanceFromLeft.toFixed(1)} ft from left edge\n`;
                        }
                    });
                    report += '\n';
                }
                
                // Window details
                if (room.windows.length > 0) {
                    report += `   WINDOWS (${room.windows.length}):\n`;
                    room.windows.forEach((win, wi) => {
                        const wall = room.walls[win.wallIndex];
                        report += `   ${wi+1}. ${win.width}" wide on ${wall ? wall.name : 'wall'}\n`;
                        if (win.heightFromFloor !== undefined && win.heightFromFloor !== null) {
                            report += `      Height: ${win.heightFromFloor} ft from floor\n`;
                        }
                        if (win.distanceFromLeft) {
                            report += `      Position: ${win.distanceFromLeft.toFixed(1)} ft from left edge\n`;
                        }
                    });
                    report += '\n';
                }
                
                // Damage markers
                if (room.damageMarkers.length > 0) {
                    report += `   DAMAGE MARKERS: ${room.damageMarkers.length}\n\n`;
                }
                
                report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';
            });
            
            report += `\nReport Generated: ${new Date().toLocaleString()}\n`;
            report += `Generated by: Cochran Claims Property Measurement Tool\n`;
            
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename} - Report.txt`;
            a.click();
            URL.revokeObjectURL(url);
            showToast(`‚úì Report exported as "${filename} - Report.txt"`);
        }
        
        function performXactimateCSV(filename) {
            // Create CSV header
            let csv = 'Room,FloorArea_SF,Perimeter_LF,CeilingHeight_FT,WallArea_Gross_SF,WallArea_Net_SF,Doors,Windows,DoorDetails,WindowDetails\n';
            
            state.rooms.forEach((room, i) => {
                // Calculate area
                let area = 0;
                if (room.floorPoints.length >= 3) {
                    for (let j = 0; j < room.floorPoints.length; j++) {
                        const k = (j + 1) % room.floorPoints.length;
                        area += room.floorPoints[j].x * room.floorPoints[k].y;
                        area -= room.floorPoints[k].x * room.floorPoints[j].y;
                    }
                    area = Math.abs(area / 2) / 900;
                }
                const perim = room.walls.reduce((s, w) => s + parseFloat(w.length), 0);
                const grossWallArea = perim * room.ceilingHeight;
                const netWallArea = calculateNetWallArea(room);
                
                // Door details
                let doorDetails = '';
                room.doors.forEach((door, di) => {
                    const wall = room.walls[door.wallIndex];
                    doorDetails += `${door.width}" on ${wall ? wall.name : 'wall'} at ${door.distanceFromLeft ? door.distanceFromLeft.toFixed(1) : '0'}ft; `;
                });
                
                // Window details
                let windowDetails = '';
                room.windows.forEach((win, wi) => {
                    const wall = room.walls[win.wallIndex];
                    windowDetails += `${win.width}" on ${wall ? wall.name : 'wall'} at ${win.distanceFromLeft ? win.distanceFromLeft.toFixed(1) : '0'}ft; `;
                });
                
                // Add row
                csv += `"${room.name}",${area.toFixed(2)},${perim.toFixed(2)},${room.ceilingHeight},${grossWallArea.toFixed(2)},${netWallArea.toFixed(2)},${room.doors.length},${room.windows.length},"${doorDetails}","${windowDetails}"\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename} - Xactimate.csv`;
            a.click();
            URL.revokeObjectURL(url);
            showToast(`‚úì CSV exported as "${filename} - Xactimate.csv"`);
        }
        
        function performXactimateReport(filename) {
            let report = `XACTIMATE READY REPORT\n`;
            report += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
            report += `PROJECT: ${filename}\n`;
            report += `Date: ${new Date().toLocaleDateString()}\n\n`;
            
            let totalFloorArea = 0;
            let totalWallArea = 0;
            let totalCeilingArea = 0;
            let totalPerimeter = 0;
            let totalDoors = 0;
            let totalWindows = 0;
            
            state.rooms.forEach((room, i) => {
                // Calculate area
                let area = 0;
                if (room.floorPoints.length >= 3) {
                    for (let j = 0; j < room.floorPoints.length; j++) {
                        const k = (j + 1) % room.floorPoints.length;
                        area += room.floorPoints[j].x * room.floorPoints[k].y;
                        area -= room.floorPoints[k].x * room.floorPoints[j].y;
                    }
                    area = Math.abs(area / 2) / 900;
                }
                const perim = room.walls.reduce((s, w) => s + parseFloat(w.length), 0);
                const grossWallArea = perim * room.ceilingHeight;
                const netWallArea = calculateNetWallArea(room);
                
                totalFloorArea += area;
                totalWallArea += netWallArea; // Use NET area for totals
                totalCeilingArea += area;
                totalPerimeter += perim;
                totalDoors += room.doors.length;
                totalWindows += room.windows.length;
                
                report += `\n`;
                report += `ROOM ${i+1}: ${room.name.toUpperCase()}\n`;
                report += `${'‚îÄ'.repeat(50)}\n\n`;
                
                report += `DIMENSIONS:\n`;
                report += `  Floor Area: ${area.toFixed(1)} sq ft\n`;
                report += `  Perimeter: ${perim.toFixed(1)} linear ft\n`;
                report += `  Ceiling Height: ${room.ceilingHeight} ft\n`;
                report += `  Wall Area (Gross): ${grossWallArea.toFixed(1)} sq ft\n`;
                report += `  Wall Area (Net): ${netWallArea.toFixed(1)} sq ft\n\n`;
                
                // Wall breakdown
                report += `WALLS:\n`;
                room.walls.forEach((wall, wi) => {
                    report += `  ${wall.name}: ${wall.length} ft\n`;
                });
                report += `\n`;
                
                // Openings
                if (room.doors.length > 0 || room.windows.length > 0) {
                    report += `OPENINGS:\n`;
                    
                    room.doors.forEach((door, di) => {
                        const wall = room.walls[door.wallIndex];
                        report += `  Door ${di+1}: ${wall ? wall.name : 'Unknown wall'}, ${door.width}" wide`;
                        if (door.distanceFromLeft) {
                            report += `, ${door.distanceFromLeft.toFixed(1)} ft from left`;
                        }
                        report += `\n`;
                    });
                    
                    room.windows.forEach((win, wi) => {
                        const wall = room.walls[win.wallIndex];
                        report += `  Window ${wi+1}: ${wall ? wall.name : 'Unknown wall'}, ${win.width}" wide`;
                        if (win.heightFromFloor !== undefined && win.heightFromFloor !== null) {
                            report += `, ${win.heightFromFloor} ft high`;
                        }
                        if (win.distanceFromLeft) {
                            report += `, ${win.distanceFromLeft.toFixed(1)} ft from left`;
                        }
                        report += `\n`;
                    });
                    report += `\n`;
                }
                
                // Xactimate line items
                report += `XACTIMATE LINE ITEM QUANTITIES:\n`;
                report += `  Paint walls & ceiling: ${(netWallArea + area).toFixed(1)} SF\n`;
                report += `  Baseboard: ${perim.toFixed(1)} LF\n`;
                report += `  Crown molding: ${perim.toFixed(1)} LF\n`;
                report += `  Flooring (carpet/tile/hardwood): ${area.toFixed(1)} SF\n`;
                report += `  Drywall (if damaged): ${netWallArea.toFixed(1)} SF\n`;
                report += `  Ceiling drywall (if damaged): ${area.toFixed(1)} SF\n`;
                if (room.doors.length > 0) {
                    report += `  Door replacement: ${room.doors.length} EA\n`;
                }
                if (room.windows.length > 0) {
                    report += `  Window replacement: ${room.windows.length} EA\n`;
                }
                report += `\n`;
            });
            
            // Summary section
            report += `\n`;
            report += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
            report += `PROJECT TOTALS\n`;
            report += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
            report += `Total Rooms: ${state.rooms.length}\n`;
            report += `Total Floor Area: ${totalFloorArea.toFixed(1)} SF\n`;
            report += `Total Wall Area: ${totalWallArea.toFixed(1)} SF\n`;
            report += `Total Ceiling Area: ${totalCeilingArea.toFixed(1)} SF\n`;
            report += `Total Perimeter: ${totalPerimeter.toFixed(1)} LF\n`;
            report += `Total Doors: ${totalDoors}\n`;
            report += `Total Windows: ${totalWindows}\n\n`;
            
            report += `AGGREGATE LINE ITEMS FOR XACTIMATE:\n`;
            report += `${'‚îÄ'.repeat(50)}\n`;
            report += `Paint (walls & ceilings): ${(totalWallArea + totalCeilingArea).toFixed(1)} SF\n`;
            report += `Baseboard: ${totalPerimeter.toFixed(1)} LF\n`;
            report += `Crown molding: ${totalPerimeter.toFixed(1)} LF\n`;
            report += `Flooring: ${totalFloorArea.toFixed(1)} SF\n`;
            report += `Drywall walls: ${totalWallArea.toFixed(1)} SF\n`;
            report += `Drywall ceiling: ${totalCeilingArea.toFixed(1)} SF\n`;
            report += `Doors: ${totalDoors} EA\n`;
            report += `Windows: ${totalWindows} EA\n\n`;
            
            report += `\nReport Generated: ${new Date().toLocaleString()}\n`;
            report += `Generated by: Cochran Claims Property Measurement Tool\n`;
            report += `\nREADY FOR XACTIMATE ENTRY\n`;
            
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename} - Xactimate Ready.txt`;
            a.click();
            URL.revokeObjectURL(url);
            showToast(`‚úì Xactimate report exported as "${filename} - Xactimate Ready.txt"`);
        }
        
        function performExcelExport(filename) {
            // Create a file input to select the template
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.xltm,.xlsx,.xlsm';
            fileInput.style.display = 'none';
            
            fileInput.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                showToast('üìÇ Reading template file...');
                
                try {
                    // Read the template file
                    const arrayBuffer = await file.arrayBuffer();
                    const workbook = XLSX.read(arrayBuffer, { type: 'array', bookVBA: true });
                    
                    // Find ROOM_DIMENSIONS sheet
                    let sheetName = 'ROOM_DIMENSIONS';
                    if (!workbook.SheetNames.includes(sheetName)) {
                        showToast('‚ùå ROOM_DIMENSIONS sheet not found in template!');
                        return;
                    }
                    
                    // Get the existing sheet
                    const ws = workbook.Sheets[sheetName];
                    
                    // Clear existing data rows (keep row 1 headers)
                    // Find the last row with data
                    const range = XLSX.utils.decode_range(ws['!ref']);
                    for (let row = 2; row <= range.e.r; row++) {
                        for (let col = 0; col <= 9; col++) { // Only clear columns A-J (room data)
                            const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                            delete ws[cellAddress];
                        }
                    }
                    
                    // Insert room data starting at row 2
                    let currentRow = 2;
                    
                    state.rooms.forEach((room, i) => {
                        // Calculate floor area from polygon
                        let floorArea = 0;
                        if (room.floorPoints.length >= 3) {
                            for (let j = 0; j < room.floorPoints.length; j++) {
                                const k = (j + 1) % room.floorPoints.length;
                                floorArea += room.floorPoints[j].x * room.floorPoints[k].y;
                                floorArea -= room.floorPoints[k].x * room.floorPoints[j].y;
                            }
                            floorArea = Math.abs(floorArea / 2) / 900; // Convert to sq ft
                        }
                        
                        // Calculate perimeter
                        const perimeter = room.walls.reduce((sum, w) => sum + parseFloat(w.length), 0);
                        
                        // Count missing wall sections
                        let missingWallCount = 0;
                        room.walls.forEach(wall => {
                            if (wall.missingWalls) {
                                missingWallCount += wall.missingWalls.length;
                            }
                        });
                        
                        // Total openings
                        const totalOpenings = room.doors.length + room.windows.length + missingWallCount;
                        
                        // Insert data into columns A-J only (don't touch pricing columns K-N)
                        const rowIndex = currentRow - 1; // Zero-based
                        
                        // Column A: Room Name
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 0 })] = { t: 's', v: room.name };
                        
                        // Column B: Perimeter
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 1 })] = { t: 'n', v: parseFloat(perimeter.toFixed(1)) };
                        
                        // Column C: Height
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 2 })] = { t: 'n', v: room.ceilingHeight };
                        
                        // Column D: Wall SF - COPY FORMULA FROM ROW 2 if it exists, or create new
                        const formulaCell = ws[XLSX.utils.encode_cell({ r: 1, c: 3 })]; // Row 2 (index 1)
                        if (formulaCell && formulaCell.f) {
                            // Copy formula pattern, adjusting row number
                            const newFormula = formulaCell.f.replace(/2/g, currentRow.toString());
                            ws[XLSX.utils.encode_cell({ r: rowIndex, c: 3 })] = { t: 'n', f: newFormula };
                        } else {
                            // Create formula
                            ws[XLSX.utils.encode_cell({ r: rowIndex, c: 3 })] = { t: 'n', f: `B${currentRow}*C${currentRow}` };
                        }
                        
                        // Column E: Floor SF
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 4 })] = { t: 'n', v: parseFloat(floorArea.toFixed(1)) };
                        
                        // Column F: Ceiling SF
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 5 })] = { t: 'n', v: parseFloat(floorArea.toFixed(1)) };
                        
                        // Column G: Door Count
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 6 })] = { t: 'n', v: room.doors.length };
                        
                        // Column H: Window Count
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 7 })] = { t: 'n', v: room.windows.length };
                        
                        // Column I: Missing Wall Sections
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 8 })] = { t: 'n', v: missingWallCount };
                        
                        // Column J: Total Openings
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 9 })] = { t: 'n', v: totalOpenings };
                        
                        // Copy pricing formulas from row 2 to this row (columns K-N)
                        for (let col = 10; col <= 13; col++) {
                            const templateCell = ws[XLSX.utils.encode_cell({ r: 1, c: col })];
                            if (templateCell) {
                                const newCell = {};
                                newCell.t = templateCell.t || 'n';
                                
                                if (templateCell.f) {
                                    // Formula exists - copy and adjust row number
                                    newCell.f = templateCell.f.replace(/2/g, currentRow.toString());
                                } else if (templateCell.v !== undefined) {
                                    // Value exists - copy it
                                    newCell.v = templateCell.v;
                                }
                                
                                ws[XLSX.utils.encode_cell({ r: rowIndex, c: col })] = newCell;
                            }
                        }
                        
                        currentRow++;
                    });
                    
                    // Update sheet range
                    const newRange = XLSX.utils.encode_range({
                        s: { r: 0, c: 0 },
                        e: { r: currentRow - 1, c: 13 } // A1 to N(lastRow)
                    });
                    ws['!ref'] = newRange;
                    
                    // Generate output filename - NEW file from template, not modified template
                    const outputFilename = `${filename}.xlsm`;
                    
                    // Write as NEW .xlsm file (preserves macros, doesn't modify template)
                    XLSX.writeFile(workbook, outputFilename, { bookVBA: true });
                    
                    showToast(`‚úì Created ${outputFilename} from template with your data!`);
                    
                } catch (error) {
                    console.error('Error processing template:', error);
                    showToast(`‚ùå Error: ${error.message}`);
                }
            };
            
            // Trigger file selection
            document.body.appendChild(fileInput);
            fileInput.click();
            document.body.removeChild(fileInput);
        }


        function updateProjectNameDisplay() {
            const display = document.getElementById('projectNameDisplay');
            if (display) {
                display.textContent = state.projectName;
            }
        }
        
        function loadProject() {
            showSavedProjectsList();
        }
        
        function showSavedProjectsList() {
            const modal = document.getElementById('savedProjectsModal');
            if (!modal) {
                createSavedProjectsModal();
            }
            
            const savedProjects = JSON.parse(localStorage.getItem('cochran_saved_projects') || '{}');
            const projectNames = Object.keys(savedProjects);
            
            if (projectNames.length === 0) {
                showToast('No saved projects. Use "Load from File" to import .json files.');
                loadFromFile();
                return;
            }
            
            // Build list HTML
            let listHTML = '<div style="max-height: 400px; overflow-y: auto;">';
            projectNames.sort().forEach(name => {
                const project = savedProjects[name];
                const date = new Date(project.savedDate);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                const roomCount = project.rooms.length;
                
                listHTML += `
                    <div style="border: 1px solid #ddd; padding: 15px; margin-bottom: 10px; border-radius: 8px; background: #f9f9f9;">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                                <div style="font-weight: bold; font-size: 16px; margin-bottom: 5px;">${name}</div>
                                <div style="font-size: 12px; color: #666;">
                                    ${roomCount} room${roomCount !== 1 ? 's' : ''} ‚Ä¢ Saved ${dateStr}
                                </div>
                            </div>
                            <div style="display: flex; gap: 5px;">
                                <button onclick="loadSavedProject('${name}')" style="padding: 8px 15px; background: #4A90E2; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">
                                    Load
                                </button>
                                <button onclick="deleteSavedProject('${name}')" style="padding: 8px 15px; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">
                                    Delete
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });
            listHTML += '</div>';
            
            listHTML += `
                <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #ddd;">
                    <button onclick="loadFromFile()" style="width: 100%; padding: 12px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold;">
                        üìÇ Load from File (.json)
                    </button>
                </div>
            `;
            
            document.getElementById('savedProjectsList').innerHTML = listHTML;
            document.getElementById('savedProjectsModal').style.display = 'flex';
        }
        
        function createSavedProjectsModal() {
            const modal = document.createElement('div');
            modal.id = 'savedProjectsModal';
            modal.style.cssText = 'display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;';
            
            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 12px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto;">
                    <h2 style="margin: 0 0 20px 0; color: #1e3c72;">üìÇ Load Project</h2>
                    <div id="savedProjectsList"></div>
                    <button onclick="closeSavedProjectsModal()" style="margin-top: 20px; padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; width: 100%;">
                        Cancel
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function closeSavedProjectsModal() {
            document.getElementById('savedProjectsModal').style.display = 'none';
        }
        
        function loadSavedProject(name) {
            const savedProjects = JSON.parse(localStorage.getItem('cochran_saved_projects') || '{}');
            const project = savedProjects[name];
            
            if (project) {
                state.rooms = project.rooms || [];
                state.projectName = project.projectName || name;
                state.currentRoomIndex = 0;
                updateRoomList();
                updateProjectNameDisplay();
                redraw2D();
                updateStats();
                closeSavedProjectsModal();
                showToast(`‚úì Loaded "${name}"`);
            } else {
                showToast(`‚ùå Project "${name}" not found`);
            }
        }
        
        function deleteSavedProject(name) {
            if (confirm(`Delete "${name}"? This cannot be undone.`)) {
                const savedProjects = JSON.parse(localStorage.getItem('cochran_saved_projects') || '{}');
                delete savedProjects[name];
                localStorage.setItem('cochran_saved_projects', JSON.stringify(savedProjects));
                showToast(`‚úì Deleted "${name}"`);
                showSavedProjectsList(); // Refresh list
            }
        }
        
        function loadFromFile() {
            closeSavedProjectsModal();
            document.getElementById('fileInput').click();
        }

        function loadProject() {
            showSavedProjectsList();
        }

        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const data = JSON.parse(ev.target.result);
                        state.rooms = data.rooms || [];
                        state.projectName = data.projectName || 'Untitled Project';
                        state.currentRoomIndex = 0;
                        updateRoomList();
                        updateProjectNameDisplay();
                        redraw2D();
                        updateStats();
                        showToast(`‚úì Loaded "${state.projectName}"`);
                    } catch (err) {
                        showToast('‚ùå Error loading');
                    }
                };
                reader.readAsText(file);
            }
        });

        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('active');
            setTimeout(() => toast.classList.remove('active'), 3000);
        }

        function updateModeIndicator() {
            const indicator = document.getElementById('modeIndicator');
            const clearBtn = document.getElementById('clearModeBtn');
            
            if (state.wallSelectionMode) {
                indicator.textContent = 'WALL SELECTION MODE - Click on a wall';
                indicator.className = 'mode-indicator wall-mode';
                clearBtn.style.display = 'block';
            } else if (state.currentFeature) {
                indicator.textContent = `PLACING ${state.currentFeature.toUpperCase()}`;
                indicator.className = 'mode-indicator wall-mode';
                clearBtn.style.display = 'block';
            } else {
                indicator.textContent = 'üìè EDIT MODE - Click feature to edit/delete';
                indicator.className = 'mode-indicator delete-mode';
                clearBtn.style.display = 'none';
            }
        }

        function clearAllModes() {
            console.log('*** CLEARING ALL MODES ***');
            state.wallSelectionMode = false;
            state.currentFeature = null;
            state.selectedWall = null;
            state.hoveredWall = null;
            state.clickPoint = null;
            
            // Clear wall drawing in progress
            state.wallDrawingCorners = [];
            
            document.querySelectorAll('.feature-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('instructionBanner').classList.remove('active');
            
            updateModeIndicator();
            redraw2D();
            showToast('‚úì Modes cleared - Click to reposition features');
        }
    
        // --- Ensure UI onclick handlers can find functions (prevents "nothing happens" failures) ---
        // Some browsers isolate function declarations depending on how the file is served.
        // Explicitly attach the key UI actions to window.
        try {
            window.addNewRoom = addNewRoom;
            window.loadProject = loadProject;
            window.saveProject = saveProject;
            window.switch2D = switch2D;
            window.switch3D = switch3D;
            window.resetView = resetView;
            window.undo = undo;
            window.zoomIn = zoomIn;
            window.zoomOut = zoomOut;
            window.resetZoom = resetZoom;
            window.zoomAll = zoomAll;
            window.startZoomWindow = startZoomWindow;
            window.setDrawingMode = setDrawingMode;
            window.toggleOrthoMode = toggleOrthoMode;
            window.setFeatureMode = setFeatureMode;
            window.toggleLeftPanel = toggleLeftPanel;
            window.selectFeature = selectFeature;
            window.showMissingWallModal = showMissingWallModal;
            window.confirmMissingWall = confirmMissingWall;
            window.cancelMissingWall = cancelMissingWall;
            window.deleteCurrentMissingWall = deleteCurrentMissingWall;
            window.loadSavedProject = loadSavedProject;
            window.deleteSavedProject = deleteSavedProject;
            window.closeSavedProjectsModal = closeSavedProjectsModal;
            window.loadFromFile = loadFromFile;
            window.setDoorHinge = setDoorHinge;
            window.setDoorSwingDirection = setDoorSwingDirection;
            window.selectDirection = selectDirection;
            window.previewFloorPlan = previewFloorPlan;
            window.livePreview = livePreview;
        } catch (e) {
            console.warn('Window export failed:', e);
        }
        
        // Register Service Worker for PWA functionality - DISABLED for file:// usage
        /*
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then(registration => {
                        console.log('‚úì Service Worker registered:', registration.scope);
                    })
                    .catch(error => {
                        console.log('Service Worker registration failed:', error);
                    });
            });
        }
        */
</script>

<!-- iPad/iOS Compatibility Script -->
<script>
// ========== IPAD/IOS TOUCH FIX ==========
// Makes ALL buttons work reliably on iPad/iPhone
(function() {
    'use strict';
    
    console.log('üéØ Loading iPad compatibility fixes...');
    
    // Wait for DOM to be fully loaded
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initIPadFixes);
    } else {
        initIPadFixes();
    }
    
    function initIPadFixes() {
        console.log('üì± Initializing iPad button fixes...');
        
        // Fix ALL buttons for touch
        const buttons = document.querySelectorAll('button');
        console.log(`Found ${buttons.length} buttons to fix`);
        
        buttons.forEach((btn, index) => {
            // Add touch-friendly CSS
            btn.style.webkitTapHighlightColor = 'rgba(0,0,0,0.1)';
            btn.style.touchAction = 'manipulation';
            btn.style.userSelect = 'none';
            
            // Add active state visual feedback
            btn.addEventListener('touchstart', function() {
                this.style.opacity = '0.7';
            }, { passive: true });
            
            btn.addEventListener('touchend', function() {
                this.style.opacity = '1';
            }, { passive: true });
            
            btn.addEventListener('touchcancel', function() {
                this.style.opacity = '1';
            }, { passive: true });
        });
        
        console.log('‚úÖ All buttons fixed for iPad/iOS!');
        console.log('‚úÖ Tap any button - it should work now!');
    }
    
    // Also fix on window load as backup
    window.addEventListener('load', function() {
        console.log('‚úÖ Page fully loaded - buttons ready!');
    });
})();
</script>

<script>
console.log('üî•üî•üî• ESTIMATOR SCRIPT TAG IS RUNNING! üî•üî•üî•');
console.log('If you see this, the script tag loaded successfully');

// =====================================================================
// QUANTITY ESTIMATOR ENGINE
// =====================================================================
console.log('üì¶ Loading Quantity Estimator classes...');

class QuantityEstimator {
    constructor() {
        this.pricing = {
            drywall_half_inch: 2.27,
            paint_walls: 1.50,
            paint_ceiling: 1.35,
            flooring_carpet: 4.50,
            flooring_hardwood: 8.00,
            flooring_tile: 6.50,
            baseboard: 3.25,
            door_interior: 350.00,
            door_exterior: 650.00,
            window: 450.00
        };
        this.taxRate = 0.08;
        this.overheadProfit = 0.20;
    }
    
    parseDimension(dimStr) {
        if (typeof dimStr === 'number') return dimStr;
        const feetMatch = dimStr.match(/(\d+)'/);
        const inchMatch = dimStr.match(/(\d+)"/);
        let feet = feetMatch ? parseInt(feetMatch[1]) : 0;
        let inches = inchMatch ? parseInt(inchMatch[1]) : 0;
        return feet + (inches / 12);
    }

    
    formatDimension(decimal) {
        const feet = Math.floor(decimal);
        const inches = Math.round((decimal - feet) * 12);
        
        if (inches === 0) {
            return `${feet}'0"`;
        } else if (inches === 12) {
            return `${feet + 1}'0"`;
        } else {
            return `${feet}'${inches}"`;
        }
    }

    
        calculateRoomQuantities(room) {
        const length = parseFloat(room.length) || 0;
        const width = parseFloat(room.width) || 0;
        const height = parseFloat(room.height) || 8;
        
        const floorArea = length * width;
        const ceilingArea = floorArea;
        const grossWallArea = (length * height * 2) + (width * height * 2);
        
        // Calculate total opening area (doors + windows + wall cuts)
        let totalOpeningsArea = 0;
        const openingDetails = [];
        
        // DOORS
        if (room.doors && room.doors.length > 0) {
            room.doors.forEach((door, idx) => {
                // Always use widthInches/heightInches if available, convert to feet
                let w, h;
                if (door.widthInches) {
                    w = door.widthInches / 12;
                } else if (door.width) {
                    // If width > 20, assume it's in inches and convert
                    w = door.width > 20 ? door.width / 12 : door.width;
                } else {
                    w = 2.5; // Default 2'6"
                }
                
                if (door.heightInches) {
                    h = door.heightInches / 12;
                } else if (door.height) {
                    // If height > 20, assume it's in inches and convert
                    h = door.height > 20 ? door.height / 12 : door.height;
                } else {
                    h = 6.67; // Default 6'8"
                }
                
                const area = w * h;
                totalOpeningsArea += area;
                
                openingDetails.push({
                    type: 'door',
                    index: idx,
                    width: w,
                    height: h,
                    widthStr: this.formatDimension(w),
                    heightStr: this.formatDimension(h),
                    area: area,
                    opensTo: door.opensTo || '',
                    wallIndex: door.wallIndex
                });
            });
        }
        
        // WINDOWS
        if (room.windows && room.windows.length > 0) {
            room.windows.forEach((window, idx) => {
                // Always use widthInches/heightInches if available, convert to feet
                let w, h;
                if (window.widthInches) {
                    w = window.widthInches / 12;
                } else if (window.width) {
                    // If width > 20, assume it's in inches and convert
                    w = window.width > 20 ? window.width / 12 : window.width;
                } else {
                    w = 3; // Default 3'0"
                }
                
                if (window.heightInches) {
                    h = window.heightInches / 12;
                } else if (window.height) {
                    // If height > 20, assume it's in inches and convert  
                    h = window.height > 20 ? window.height / 12 : window.height;
                } else {
                    h = 4; // Default 4'0"
                }
                
                const area = w * h;
                totalOpeningsArea += area;
                
                openingDetails.push({
                    type: 'window',
                    index: idx,
                    width: w,
                    height: h,
                    widthStr: this.formatDimension(w),
                    heightStr: this.formatDimension(h),
                    area: area,
                    wallIndex: window.wallIndex
                });
            });
        }
        
        // OPENINGS / WALL CUTS
        if (room.openings && room.openings.length > 0) {
            room.openings.forEach((opening, idx) => {
                const w = opening.width || 3;
                const h = opening.height || height;
                const area = w * h;
                totalOpeningsArea += area;
                
                openingDetails.push({
                    type: 'opening',
                    index: idx,
                    width: w,
                    height: h,
                    widthStr: this.formatDimension(w),
                    heightStr: this.formatDimension(h),
                    area: area,
                    opensTo: opening.opensTo || 'Exterior',
                    wallIndex: opening.wallIndex
                });
            });
        }
        
        const netWallArea = grossWallArea - totalOpeningsArea;
        const wallsCeilingArea = netWallArea + ceilingArea;
        
        console.log(`Room ${room.name}: Gross=${grossWallArea.toFixed(2)}, Openings=${totalOpeningsArea.toFixed(2)}, NET=${netWallArea.toFixed(2)}`);
        
        return {
            name: room.name || 'Unnamed Room',
            dimensions: { length, width, height },
            areas: {
                floor: floorArea,
                ceiling: ceilingArea,
                wallsGross: grossWallArea,
                wallsNet: netWallArea,
                walls: netWallArea,
                wallsAndCeiling: wallsCeilingArea,
                totalOpenings: totalOpeningsArea
            },
            perimeters: {
                floor: 2 * (length + width),
                ceiling: 2 * (length + width)
            },
            features: {
                doors: room.doors || [],
                windows: room.windows || []
            },
            openings: openingDetails
        };
    }
    
    calculateLineItem(description, quantity, unit, unitPrice) {
        const subtotal = quantity * unitPrice;
        const tax = subtotal * this.taxRate;
        const op = subtotal * this.overheadProfit;
        const rcv = subtotal + tax + op;
        const depreciation = 0;
        const acv = rcv - depreciation;
        
        return {
            description,
            quantity: quantity.toFixed(2),
            unit,
            unitPrice: unitPrice.toFixed(2),
            tax: tax.toFixed(2),
            op: op.toFixed(2),
            rcv: rcv.toFixed(2),
            depreciation: depreciation.toFixed(2),
            acv: acv.toFixed(2)
        };
    }
    
    generateRoomLineItems(roomQuantities, roomConfig) {
        const items = [];
        const roomName = roomQuantities.name;
        
        if (roomQuantities.areas.wallsAndCeiling > 0) {
            items.push(this.calculateLineItem(
                `${roomName} - 1/2" drywall`,
                roomQuantities.areas.wallsAndCeiling,
                'SF',
                this.pricing.drywall_half_inch
            ));
        }
        
        if (roomQuantities.areas.walls > 0) {
            items.push(this.calculateLineItem(
                `${roomName} - Paint walls`,
                roomQuantities.areas.walls,
                'SF',
                this.pricing.paint_walls
            ));
        }
        
        if (roomQuantities.areas.ceiling > 0) {
            items.push(this.calculateLineItem(
                `${roomName} - Paint ceiling`,
                roomQuantities.areas.ceiling,
                'SF',
                this.pricing.paint_ceiling
            ));
        }
        
        if (roomQuantities.areas.floor > 0) {
            const floorType = roomConfig.floorType || 'carpet';
            let price = this.pricing.flooring_carpet;
            let desc = 'Carpet';
            
            if (floorType === 'hardwood') {
                price = this.pricing.flooring_hardwood;
                desc = 'Hardwood';
            } else if (floorType === 'tile') {
                price = this.pricing.flooring_tile;
                desc = 'Tile';
            }
            
            items.push(this.calculateLineItem(
                `${roomName} - ${desc}`,
                roomQuantities.areas.floor,
                'SF',
                price
            ));
        }
        
        if (roomQuantities.perimeters.floor > 0) {
            items.push(this.calculateLineItem(
                `${roomName} - Baseboard`,
                roomQuantities.perimeters.floor,
                'LF',
                this.pricing.baseboard
            ));
        }
        
        roomQuantities.features.doors.forEach((door, i) => {
            const type = door.type || 'interior';
            const price = type === 'exterior' ? this.pricing.door_exterior : this.pricing.door_interior;
            items.push(this.calculateLineItem(
                `${roomName} - ${type} door ${i + 1}`,
                1,
                'EA',
                price
            ));
        });
        
        roomQuantities.features.windows.forEach((window, i) => {
            items.push(this.calculateLineItem(
                `${roomName} - Window ${i + 1}`,
                1,
                'EA',
                this.pricing.window
            ));
        });
        
        return items;
    }
    
    generateEstimate(property) {
        // Check if we have claim data loaded from Claims Manager
        const claimData = window.state?.claimData || {};
        
        const estimate = {
            metadata: {
                projectName: claimData.projectName || property.name || 'Property Estimate',
                address: claimData.address || property.address || '',
                date: new Date().toLocaleDateString(),
                claimNumber: claimData.claimNumber || property.claimNumber || '',
                insured: claimData.insured || property.insured || ''
            },
            levels: [],
            lineItems: [],
            totals: { tax: 0, op: 0, rcv: 0, depreciation: 0, acv: 0 }
        };
        
        if (property.levels) {
            property.levels.forEach((level, levelIndex) => {
                const levelData = {
                    name: level.name || `Level ${levelIndex + 1}`,
                    rooms: [],
                    lineItems: []
                };
                
                if (level.rooms) {
                    level.rooms.forEach(room => {
                        const roomQuantities = this.calculateRoomQuantities(room);
                        levelData.rooms.push(roomQuantities);
                        
                        const roomItems = this.generateRoomLineItems(roomQuantities, room);
                        levelData.lineItems.push(...roomItems);
                        estimate.lineItems.push(...roomItems);
                    });
                }
                
                estimate.levels.push(levelData);
            });
        }
        
        estimate.lineItems.forEach(item => {
            estimate.totals.tax += parseFloat(item.tax);
            estimate.totals.op += parseFloat(item.op);
            estimate.totals.rcv += parseFloat(item.rcv);
            estimate.totals.depreciation += parseFloat(item.depreciation);
            estimate.totals.acv += parseFloat(item.acv);
        });
        
        Object.keys(estimate.totals).forEach(key => {
            estimate.totals[key] = estimate.totals[key].toFixed(2);
        });
        
        return estimate;
    }
    
    generateCustomEstimate(property, selectedItems) {
        // Check if we have claim data loaded from Claims Manager
        const claimData = window.state?.claimData || {};
        
        const estimate = {
            metadata: {
                projectName: claimData.projectName || property.name,
                address: claimData.address || property.address,
                claimNumber: claimData.claimNumber || property.claimNumber,
                insured: claimData.insured || property.insured,
                date: new Date().toLocaleDateString(),
                taxRate: (this.taxRate * 100).toFixed(2), // Store as percentage string
                opRate: (this.overheadProfit * 100).toFixed(2) // Store as percentage string
            },
            levels: [],
            totals: {
                subtotal: 0,
                tax: 0,
                op: 0,
                total: 0,
                rcv: 0,
                depreciation: 0,
                acv: 0
            }
        };
        
        // Group selected items by room
        const itemsByRoom = {};
        selectedItems.forEach(item => {
            if (!itemsByRoom[item.room]) {
                itemsByRoom[item.room] = [];
            }
            itemsByRoom[item.room].push(item);
        });
        
        // Create level
        const level = {
            name: "Main Level",
            rooms: [],
            lineItems: []
        };
        
        // Process each room with selected items
        Object.keys(itemsByRoom).forEach(roomName => {
            const items = itemsByRoom[roomName];
            const roomData = property.levels[0].rooms.find(r => r.name === roomName) || {
                name: roomName,
                length: 10,
                width: 10,
                height: 8
            };
            
            // Calculate room quantities
            const roomQuantities = this.calculateRoomQuantities(roomData);
            
            // Add room with safety checks - USE COMBINED OPENINGS FROM QUANTITIES
            level.rooms.push({
                name: roomName,
                dimensions: {
                    length: roomData.length || 10,
                    width: roomData.width || 10,
                    height: roomData.height || 8
                },
                areas: roomQuantities.areas || {},
                perimeters: roomQuantities.perimeters || {
                    ceiling: 0,
                    floor: 0
                },
                openings: roomQuantities.openings || []  // Use combined openings!
            });
            
            // Add line items for this room
            items.forEach(item => {
                // Safety checks - ensure values are numbers
                const qty = parseFloat(item.quantity) || 0;
                const price = parseFloat(item.unitPrice) || 0;
                const taxRate = parseFloat(this.taxRate) || 0;
                const opRate = parseFloat(this.overheadProfit) || 0;
                
                const subtotal = qty * price;
                const tax = subtotal * taxRate;
                const op = subtotal * opRate;
                const rcv = subtotal * (1 + taxRate + opRate);
                
                const lineItem = {
                    description: item.description || 'Unknown Item',
                    quantity: qty.toFixed(2),
                    unit: item.unit || 'EA',
                    unitPrice: price.toFixed(2),
                    subtotal: subtotal.toFixed(2),
                    tax: tax.toFixed(2),
                    op: op.toFixed(2),
                    rcv: rcv.toFixed(2),
                    depreciation: '0.00',
                    acv: rcv.toFixed(2)
                };
                level.lineItems.push(lineItem);
                
                // Update totals
                estimate.totals.subtotal += subtotal;
                estimate.totals.tax += tax;
                estimate.totals.op += op;
                estimate.totals.rcv += rcv;
                estimate.totals.acv += rcv;
            });
        });
        
        estimate.levels.push(level);
        estimate.totals.total = estimate.totals.rcv;
        
        // Format totals
        Object.keys(estimate.totals).forEach(key => {
            estimate.totals[key] = estimate.totals[key].toFixed(2);
        });
        
        return estimate;
    }
    
    setTaxRate(rate) {
        this.taxRate = parseFloat(rate);
    }
    
    setOverheadProfit(rate) {
        this.overheadProfit = parseFloat(rate);
    }
}

// =====================================================================
// HTML REPORT GENERATOR
// =====================================================================
// =============================================================================
// ENHANCED XACTIMATE-STYLE REPORT GENERATOR
// Replace the generateHTMLReport function with this version
// =============================================================================

// =============================================================================
// ENHANCED XACTIMATE-STYLE REPORT WITH VISUAL FLOOR PLANS
// Replace the generateHTMLReport function with this version
// =============================================================================

function generateHTMLReport(estimate) {
    let html = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${estimate.metadata.projectName} - Estimate</title>
    <style>
        @page {
            margin: 0.75in;
        }
        
        body {
            font-family: 'Times New Roman', Times, serif;
            font-size: 11pt;
            line-height: 1.4;
            color: #000;
            max-width: 8.5in;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 3px solid #000;
            padding-bottom: 15px;
        }
        
        .header h1 {
            font-size: 20pt;
            font-weight: bold;
            margin: 0 0 10px 0;
        }
        
        .project-info {
            font-size: 10pt;
            margin: 5px 0;
        }
        
        .room-section {
            page-break-inside: avoid;
            margin-bottom: 40px;
            border: 2px solid #000;
            padding: 15px;
        }
        
        .room-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #000;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        
        .room-name {
            font-size: 14pt;
            font-weight: bold;
        }
        
        .room-height {
            font-size: 11pt;
            font-weight: bold;
        }
        
        .room-content {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 20px;
            margin-bottom: 15px;
        }
        
        .floor-plan-container {
            border: 2px solid #000;
            padding: 20px;
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 200px;
        }
        
        .floor-plan-svg {
            max-width: 100%;
            height: auto;
        }
        
        .quantities {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px 20px;
            font-size: 10pt;
        }
        
        .quantity-item {
            padding: 3px 0;
        }
        
        .features-section {
            margin: 15px 0;
            font-size: 10pt;
        }
        
        .feature-item {
            padding: 3px 0;
            font-weight: bold;
        }
        
        .line-items-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 10pt;
        }
        
        .line-items-table th {
            background: #000;
            color: #fff;
            padding: 8px 5px;
            text-align: left;
            font-weight: bold;
            border: 1px solid #000;
        }
        
        .line-items-table td {
            padding: 6px 5px;
            border: 1px solid #000;
        }
        
        .line-items-table .total-row {
            font-weight: bold;
            background: #f0f0f0;
        }
        
        .totals-section {
            margin-top: 30px;
            border: 2px solid #000;
            padding: 15px;
        }
        
        .totals-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11pt;
        }
        
        .totals-table th {
            background: #000;
            color: #fff;
            padding: 10px;
            text-align: center;
            font-weight: bold;
        }
        
        .totals-table td {
            padding: 10px;
            text-align: center;
            border: 1px solid #000;
            font-weight: bold;
            font-size: 12pt;
        }
        
        @media print {
            body {
                padding: 0;
            }
            .room-section {
                page-break-inside: avoid;
            }
            #editControls {
                display: none !important;
            }
            [contentEditable="true"] {
                background: transparent !important;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>QUANTITY ESTIMATE</h1>
        <div class="project-info"><strong>Project:</strong> ${estimate.metadata.projectName}</div>
        <div class="project-info"><strong>Date:</strong> ${estimate.metadata.date}</div>
        ${estimate.metadata.address ? `<div class="project-info"><strong>Address:</strong> ${estimate.metadata.address}</div>` : ''}
        ${estimate.metadata.claimNumber ? `<div class="project-info"><strong>Claim #:</strong> ${estimate.metadata.claimNumber}</div>` : ''}
        ${estimate.metadata.insured ? `<div class="project-info"><strong>Insured:</strong> ${estimate.metadata.insured}</div>` : ''}
    </div>`;
    
    // Generate each room section
    estimate.levels.forEach(level => {
        level.rooms.forEach((room, roomIndex) => {
            const lineItems = level.lineItems.filter(item => item.description.startsWith(room.name));
            
            // Calculate room totals
            let roomTax = 0, roomOP = 0, roomRCV = 0, roomDeprec = 0, roomACV = 0;
            lineItems.forEach(item => {
                roomTax += parseFloat(item.tax);
                roomOP += parseFloat(item.op);
                roomRCV += parseFloat(item.rcv);
                roomDeprec += parseFloat(item.depreciation);
                roomACV += parseFloat(item.acv);
            });
            
            // Generate visual floor plan
            const floorPlanSVG = generateFloorPlanSVG(room);
            
            html += `
    <div class="room-section">
        <div class="room-header">
            <div class="room-name">${room.name}</div>
            <div class="room-height">Height: ${room.dimensions.height}'</div>
        </div>
        
        <div class="room-content">
            <div class="floor-plan-container">
                ${floorPlanSVG}
            </div>
            
            <div>
                <div class="quantities">
                    <div class="quantity-item">${room.areas.wallsNet.toFixed(2)} SF Walls (NET)</div>
                    <div class="quantity-item">${room.areas.ceiling.toFixed(2)} SF Ceiling</div>
                    <div class="quantity-item">${room.areas.wallsAndCeiling.toFixed(2)} SF Walls & Ceiling</div>
                    <div class="quantity-item">${room.areas.floor.toFixed(2)} SF Floor</div>
                    <div class="quantity-item">${room.perimeters.ceiling.toFixed(2)} LF Ceil. Perimeter</div>
                    <div class="quantity-item">${room.perimeters.floor.toFixed(2)} LF Floor Perimeter</div>
                    ${room.areas.totalOpenings > 0 ? `<div class="quantity-item" style="color: #d32f2f; font-weight: bold;">${room.areas.totalOpenings.toFixed(2)} SF Total Openings</div>` : ''}
                </div>
                
                <div class="features-section">`;
            
            // Display ALL openings from room.openings array
            if (room.openings && room.openings.length > 0) {
                // DOORS
                const doors = room.openings.filter(o => o.type === 'door');
                doors.forEach((door, i) => {
                    const doorNum = doors.length > 1 ? ` ${i + 1}` : '';
                    html += `<div class="feature-item door">üö™ Door${doorNum}: ${door.widthStr} X ${door.heightStr}${door.opensTo ? ' - Opens to ' + door.opensTo : ''}</div>`;
                });
                
                // WINDOWS
                const windows = room.openings.filter(o => o.type === 'window');
                windows.forEach((window, i) => {
                    const winNum = windows.length > 1 ? ` ${i + 1}` : '';
                    html += `<div class="feature-item window">ü™ü Window${winNum}: ${window.widthStr} X ${window.heightStr}</div>`;
                });
                
                // OPENINGS (wall cuts)
                const openings = room.openings.filter(o => o.type === 'opening');
                openings.forEach((opening, i) => {
                    const openNum = openings.length > 1 ? ` ${i + 1}` : '';
                    html += `<div class="feature-item opening">‚¨ú Opening${openNum}: ${opening.widthStr} X ${opening.heightStr}${opening.opensTo ? ' - Opens to ' + opening.opensTo : ''}</div>`;
                });
            }
            
            html += `
                </div>
            </div>
        </div>
        
        <table class="line-items-table">
            <thead>
                <tr>
                    <th style="width: 35%;">DESCRIPTION</th>
                    <th style="width: 10%; text-align: center;">QUANTITY</th>
                    <th style="width: 10%; text-align: center;">UNIT PRICE</th>
                    <th style="width: 9%; text-align: right;">TAX</th>
                    <th style="width: 9%; text-align: right;">O&P</th>
                    <th style="width: 9%; text-align: right;">RCV</th>
                    <th style="width: 9%; text-align: right;">DEPREC.</th>
                    <th style="width: 9%; text-align: right;">ACV</th>
                </tr>
            </thead>
            <tbody>`;
            
            // Add line items for this room
            lineItems.forEach((item, idx) => {
                const desc = item.description.replace(room.name + ' - ', '');
                const itemNum = idx + 1;
                
                html += `
                <tr>
                    <td>${itemNum}. ${desc}</td>
                    <td style="text-align: center;">${item.quantity} ${item.unit}</td>
                    <td style="text-align: center;">${item.unitPrice}</td>
                    <td style="text-align: right;">${item.tax}</td>
                    <td style="text-align: right;">${item.op}</td>
                    <td style="text-align: right;">${item.rcv}</td>
                    <td style="text-align: right;">(${item.depreciation})</td>
                    <td style="text-align: right;">${item.acv}</td>
                </tr>`;
            });
            
            // Room totals
            html += `
                <tr class="total-row">
                    <td colspan="3"><strong>Totals: ${room.name}</strong></td>
                    <td style="text-align: right;"><strong>${roomTax.toFixed(2)}</strong></td>
                    <td style="text-align: right;"><strong>${roomOP.toFixed(2)}</strong></td>
                    <td style="text-align: right;"><strong>${roomRCV.toFixed(2)}</strong></td>
                    <td style="text-align: right;"><strong>${roomDeprec.toFixed(2)}</strong></td>
                    <td style="text-align: right;"><strong>${roomACV.toFixed(2)}</strong></td>
                </tr>
            </tbody>
        </table>
    </div>`;
        });
    });
    
    // Project totals section
    html += `
    <div class="totals-section">
        <h2 style="margin: 0 0 15px 0;">PROJECT TOTALS</h2>
        <table class="totals-table">
            <thead>
                <tr>
                    <th>TAX</th>
                    <th>O&P</th>
                    <th>RCV</th>
                    <th>DEPREC.</th>
                    <th>ACV</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>$${estimate.totals.tax}</td>
                    <td>$${estimate.totals.op}</td>
                    <td>$${estimate.totals.rcv}</td>
                    <td>($${estimate.totals.depreciation})</td>
                    <td>$${estimate.totals.acv}</td>
                </tr>
            </tbody>
        </table>
    </div>
    
    <!-- EDIT MODE CONTROLS -->
    <div id="editControls" style="position: fixed; top: 20px; right: 20px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 1000;">
        <button onclick="toggleEditMode()" id="editModeBtn" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; margin-bottom: 10px; display: block; width: 100%;">
            ‚úèÔ∏è Enable Edit Mode
        </button>
        <button onclick="saveEditedReport()" id="saveBtn" style="display: none; padding: 10px 20px; background: #4caf50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; margin-bottom: 5px; display: block; width: 100%;">
            üíæ Save Changes
        </button>
        <button onclick="downloadHTML()" id="downloadBtn" style="display: none; padding: 10px 20px; background: #ff9800; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; display: block; width: 100%;">
            üì• Download HTML
        </button>
    </div>
    
    <div style="margin-top: 40px; font-size: 9pt; color: #666; text-align: center;">
        Generated by Cochran Claims Property Tool - ${new Date().toLocaleString()}
    </div>
    
    <script>
        let editMode = false;
        
        function toggleEditMode() {
            editMode = !editMode;
            const btn = document.getElementById('editModeBtn');
            const saveBtn = document.getElementById('saveBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            
            if (editMode) {
                btn.textContent = 'üëÅÔ∏è View Mode';
                btn.style.background = '#f44336';
                saveBtn.style.display = 'block';
                downloadBtn.style.display = 'block';
                enableEditing();
            } else {
                btn.textContent = '‚úèÔ∏è Enable Edit Mode';
                btn.style.background = '#667eea';
                saveBtn.style.display = 'none';
                downloadBtn.style.display = 'none';
                disableEditing();
            }
        }
        
        function enableEditing() {
            // Make all line item cells editable
            document.querySelectorAll('.line-items-table tbody td').forEach(cell => {
                if (!cell.classList.contains('no-edit')) {
                    cell.contentEditable = true;
                    cell.style.background = '#fff9c4';
                    cell.style.cursor = 'text';
                    
                    // Add event listener to recalculate on change
                    cell.addEventListener('blur', recalculateRow);
                }
            });
            
            // Make project info editable
            document.querySelectorAll('.project-info').forEach(el => {
                el.contentEditable = true;
                el.style.background = '#fff9c4';
            });
            
            document.querySelector('.header h1').contentEditable = true;
            document.querySelector('.header h1').style.background = '#fff9c4';
        }
        
        function disableEditing() {
            document.querySelectorAll('[contentEditable="true"]').forEach(el => {
                el.contentEditable = false;
                el.style.background = '';
                el.style.cursor = '';
            });
        }
        
        function recalculateRow(event) {
            const cell = event.target;
            const row = cell.closest('tr');
            if (!row) return;
            
            const cells = row.querySelectorAll('td');
            
            // Try to find quantity and price cells and recalculate
            // This is a basic implementation - adjust based on your table structure
            try {
                const qtyCell = cells[1]; // Adjust index as needed
                const priceCell = cells[3]; // Adjust index as needed
                
                if (qtyCell && priceCell) {
                    const qty = parseFloat(qtyCell.textContent.replace(/[^0-9.]/g, '')) || 0;
                    const price = parseFloat(priceCell.textContent.replace(/[^0-9.]/g, '')) || 0;
                    const subtotal = qty * price;
                    const tax = subtotal * 0.08;
                    const op = subtotal * 0.20;
                    const total = subtotal + tax + op;
                    
                    // Update cells if they exist
                    if (cells[4]) cells[4].textContent = '$' + tax.toFixed(2);
                    if (cells[5]) cells[5].textContent = '$' + op.toFixed(2);
                    if (cells[6]) cells[6].textContent = '$' + total.toFixed(2);
                    if (cells[7]) cells[7].textContent = '$0.00'; // Depreciation
                    if (cells[8]) cells[8].textContent = '$' + total.toFixed(2);
                }
            } catch (e) {
                console.error('Recalculation error:', e);
            }
            
            recalculateTotals();
        }
        
        function recalculateTotals() {
            let totalTax = 0, totalOp = 0, totalRcv = 0, totalAcv = 0;
            
            document.querySelectorAll('.line-items-table tbody tr').forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 9) {
                    totalTax += parseFloat(cells[4]?.textContent.replace(/[^0-9.]/g, '')) || 0;
                    totalOp += parseFloat(cells[5]?.textContent.replace(/[^0-9.]/g, '')) || 0;
                    totalRcv += parseFloat(cells[6]?.textContent.replace(/[^0-9.]/g, '')) || 0;
                    totalAcv += parseFloat(cells[8]?.textContent.replace(/[^0-9.]/g, '')) || 0;
                }
            });
            
            // Update totals table
            const totalsRows = document.querySelectorAll('.totals-table tbody tr');
            if (totalsRows.length > 0) {
                const totalsCells = totalsRows[0].querySelectorAll('td');
                if (totalsCells[0]) totalsCells[0].textContent = '$' + totalTax.toFixed(2);
                if (totalsCells[1]) totalsCells[1].textContent = '$' + totalOp.toFixed(2);
                if (totalsCells[2]) totalsCells[2].textContent = '$' + totalRcv.toFixed(2);
                if (totalsCells[3]) totalsCells[3].textContent = '($0.00)';
                if (totalsCells[4]) totalsCells[4].textContent = '$' + totalAcv.toFixed(2);
            }
        }
        
        function saveEditedReport() {
            alert('Changes saved in browser!\\n\\nTo keep changes permanently, click "üì• Download HTML" to save the file.');
            disableEditing();
            editMode = false;
            document.getElementById('editModeBtn').textContent = '‚úèÔ∏è Enable Edit Mode';
            document.getElementById('editModeBtn').style.background = '#667eea';
            document.getElementById('saveBtn').style.display = 'none';
            document.getElementById('downloadBtn').style.display = 'none';
        }
        
        function downloadHTML() {
            // Get the entire HTML document
            const htmlContent = document.documentElement.outerHTML;
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'Edited_Estimate_' + new Date().getTime() + '.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert('HTML file downloaded! You can open it anytime to view or edit further.');
        }
        
        // Print button functionality
        function printReport() {
            window.print();
        }
        
        // Add print button
        window.addEventListener('load', function() {
            const controls = document.getElementById('editControls');
            const printBtn = document.createElement('button');
            printBtn.textContent = 'üñ®Ô∏è Print';
            printBtn.style.cssText = 'padding: 10px 20px; background: #9c27b0; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; margin-top: 5px; display: block; width: 100%;';
            printBtn.onclick = printReport;
            controls.appendChild(printBtn);
        });
    <\/script>
</body>
</html>`;
    
    return html;
}

// =============================================================================
// VISUAL FLOOR PLAN GENERATOR
// =============================================================================
function generateFloorPlanSVG(room) {
    const length = room.dimensions.length;
    const width = room.dimensions.width;
    
    // Scale factor (pixels per foot)
    const scale = 15;
    const svgWidth = (length * scale) + 60;
    const svgHeight = (width * scale) + 60;
    
    // Room rectangle position
    const roomX = 30;
    const roomY = 30;
    const roomWidth = length * scale;
    const roomHeight = width * scale;
    
    console.log(`[FloorPlan] Room: ${room.name}, dimensions: ${length}' x ${width}'`);
    
    let svg = `<svg class="floor-plan-svg" width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" xmlns="http://www.w3.org/2000/svg">`;
    
    // Draw room outline
    svg += `<rect x="${roomX}" y="${roomY}" width="${roomWidth}" height="${roomHeight}" 
            fill="white" stroke="black" stroke-width="3"/>`;
    
    // Add room name in center
    svg += `<text x="${roomX + roomWidth/2}" y="${roomY + roomHeight/2}" 
            text-anchor="middle" font-size="12" font-weight="bold" fill="black">
            ${room.name}
        </text>`;
    
    // Add dimension labels (top, bottom, left, right)
    svg += `<text x="${roomX + roomWidth/2}" y="${roomY - 10}" text-anchor="middle" font-size="10" fill="black">${length.toFixed(1)}'</text>`;
    svg += `<line x1="${roomX}" y1="${roomY - 5}" x2="${roomX + roomWidth}" y2="${roomY - 5}" stroke="black" stroke-width="1"/>`;
    
    svg += `<text x="${roomX + roomWidth/2}" y="${roomY + roomHeight + 20}" text-anchor="middle" font-size="10" fill="black">${length.toFixed(1)}'</text>`;
    svg += `<line x1="${roomX}" y1="${roomY + roomHeight + 5}" x2="${roomX + roomWidth}" y2="${roomY + roomHeight + 5}" stroke="black" stroke-width="1"/>`;
    
    svg += `<text x="${roomX - 15}" y="${roomY + roomHeight/2}" text-anchor="middle" font-size="10" fill="black" transform="rotate(-90 ${roomX - 15} ${roomY + roomHeight/2})">${width.toFixed(1)}'</text>`;
    svg += `<line x1="${roomX - 5}" y1="${roomY}" x2="${roomX - 5}" y2="${roomY + roomHeight}" stroke="black" stroke-width="1"/>`;
    
    svg += `<text x="${roomX + roomWidth + 15}" y="${roomY + roomHeight/2}" text-anchor="middle" font-size="10" fill="black" transform="rotate(-90 ${roomX + roomWidth + 15} ${roomY + roomHeight/2})">${width.toFixed(1)}'</text>`;
    svg += `<line x1="${roomX + roomWidth + 5}" y1="${roomY}" x2="${roomX + roomWidth + 5}" y2="${roomY + roomHeight}" stroke="black" stroke-width="1"/>`;
    
    // Smart feature drawing - works with room.openings (from estimate) OR raw room data (from state)
    let featuresToDraw = [];
    
    if (room.openings && room.openings.length > 0) {
        // ESTIMATE MODE - use room.openings array
        console.log(`[FloorPlan] Using room.openings (${room.openings.length} items)`);
        featuresToDraw = room.openings.map(opening => ({
            type: opening.type,
            width: opening.width,
            height: opening.height,
            wallIndex: opening.wallIndex,
            label: opening.type === 'door' ? 'D' : opening.type === 'window' ? 'W' : 'O',
            color: opening.type === 'door' ? '#d32f2f' : opening.type === 'window' ? '#1976d2' : '#ff6f00'
        }));
    } else {
        // 2D VIEW MODE - convert from raw room data
        console.log(`[FloorPlan] Converting from raw room data`);
        let idx = 0;
        
        // Add doors
        if (room.doors && room.doors.length > 0) {
            room.doors.forEach(door => {
                featuresToDraw.push({
                    type: 'door',
                    width: door.width ? (door.width > 20 ? door.width / 12 : door.width) : 2.5,
                    height: door.height ? (door.height > 20 ? door.height / 12 : door.height) : 6.67,
                    wallIndex: door.wallIndex,
                    label: 'D',
                    color: '#d32f2f'
                });
            });
        }
        
        // Add windows
        if (room.windows && room.windows.length > 0) {
            room.windows.forEach(window => {
                featuresToDraw.push({
                    type: 'window',
                    width: window.width ? (window.width > 20 ? window.width / 12 : window.width) : 3,
                    height: window.height ? (window.height > 20 ? window.height / 12 : window.height) : 4,
                    wallIndex: window.wallIndex,
                    label: 'W',
                    color: '#1976d2'
                });
            });
        }
        
        // Add wall cuts
        if (room.walls && room.walls.length > 0) {
            room.walls.forEach((wall, wallIdx) => {
                if (wall.missingWalls && wall.missingWalls.length > 0) {
                    wall.missingWalls.forEach(cut => {
                        featuresToDraw.push({
                            type: 'opening',
                            width: cut.endDist - cut.startDist,
                            height: cut.height || 7,
                            wallIndex: wallIdx,
                            label: 'O',
                            color: '#ff6f00'
                        });
                    });
                }
            });
        }
    }
    
    console.log(`[FloorPlan] Drawing ${featuresToDraw.length} features`);
    
    // Group features by wall and draw them
    // FIX: Flip wall mapping 180¬∞ to match 2D view orientation
    // 2D wallIndex 0 (bottom) ‚Üí Estimate wall 2 (top)
    // 2D wallIndex 1 (left) ‚Üí Estimate wall 3 (right)
    // 2D wallIndex 2 (top) ‚Üí Estimate wall 0 (bottom)
    // 2D wallIndex 3 (right) ‚Üí Estimate wall 1 (left)
    const featuresByWall = [[], [], [], []]; // [bottom, left, top, right]
    
    featuresToDraw.forEach(feature => {
        let rawWallIdx = feature.wallIndex !== undefined && feature.wallIndex !== null ? feature.wallIndex : 
                        (feature.type === 'door' ? 0 : feature.type === 'window' ? 2 : 1);
        
        // FLIP 180¬∞ to match 2D view orientation
        const wallMapping = {
            0: 2,  // 2D bottom ‚Üí Estimate top
            1: 3,  // 2D left ‚Üí Estimate right
            2: 0,  // 2D top ‚Üí Estimate bottom
            3: 1   // 2D right ‚Üí Estimate left
        };
        
        const mappedWallIdx = wallMapping[rawWallIdx] !== undefined ? wallMapping[rawWallIdx] : rawWallIdx;
        
        if (mappedWallIdx >= 0 && mappedWallIdx <= 3) {
            featuresByWall[mappedWallIdx].push(feature);
        }
    });
    
    // Draw features on each wall
    // BOTTOM WALL (wallIndex 0)
    if (featuresByWall[0].length > 0) {
        featuresByWall[0].forEach((feature, i) => {
            const widthPx = feature.width * scale;
            const position = (i + 1) / (featuresByWall[0].length + 1);
            const x = roomX + (roomWidth * position) - (widthPx / 2);
            const y = roomY + roomHeight;
            
            if (feature.type === 'door') {
                svg += `<rect x="${x}" y="${y - 3}" width="${widthPx}" height="6" fill="white" stroke="none"/>`;
                svg += `<path d="M ${x} ${y} Q ${x + widthPx/2} ${y + widthPx/2} ${x + widthPx} ${y}" fill="none" stroke="${feature.color}" stroke-width="1.5"/>`;
                svg += `<text x="${x + widthPx/2}" y="${y + 15}" text-anchor="middle" font-size="8" fill="${feature.color}" font-weight="bold">${feature.label}${i + 1}</text>`;
            } else if (feature.type === 'window') {
                svg += `<line x1="${x}" y1="${y}" x2="${x + widthPx}" y2="${y}" stroke="${feature.color}" stroke-width="3"/>`;
                svg += `<line x1="${x}" y1="${y - 4}" x2="${x + widthPx}" y2="${y - 4}" stroke="${feature.color}" stroke-width="1"/>`;
                svg += `<text x="${x + widthPx/2}" y="${y + 15}" text-anchor="middle" font-size="8" fill="${feature.color}" font-weight="bold">${feature.label}${i + 1}</text>`;
            } else {
                svg += `<line x1="${x}" y1="${y}" x2="${x + widthPx}" y2="${y}" stroke="${feature.color}" stroke-width="3" stroke-dasharray="5,3"/>`;
                svg += `<text x="${x + widthPx/2}" y="${y + 15}" text-anchor="middle" font-size="8" fill="${feature.color}" font-weight="bold">${feature.label}${i + 1}</text>`;
            }
        });
    }
    
    // LEFT WALL (wallIndex 1)
    if (featuresByWall[1].length > 0) {
        featuresByWall[1].forEach((feature, i) => {
            const heightPx = feature.height * scale;
            const position = (i + 1) / (featuresByWall[1].length + 1);
            const x = roomX;
            const y = roomY + (roomHeight * position) - (heightPx / 2);
            
            svg += `<line x1="${x}" y1="${y}" x2="${x}" y2="${y + heightPx}" stroke="${feature.color}" stroke-width="3" stroke-dasharray="${feature.type === 'opening' ? '5,3' : 'none'}"/>`;
            svg += `<text x="${x - 15}" y="${y + heightPx/2}" text-anchor="middle" font-size="8" fill="${feature.color}" font-weight="bold">${feature.label}${i + 1}</text>`;
        });
    }
    
    // TOP WALL (wallIndex 2)
    if (featuresByWall[2].length > 0) {
        featuresByWall[2].forEach((feature, i) => {
            const widthPx = feature.width * scale;
            const position = (i + 1) / (featuresByWall[2].length + 1);
            const x = roomX + (roomWidth * position) - (widthPx / 2);
            const y = roomY;
            
            if (feature.type === 'door') {
                svg += `<rect x="${x}" y="${y - 3}" width="${widthPx}" height="6" fill="white" stroke="none"/>`;
                svg += `<path d="M ${x} ${y} Q ${x + widthPx/2} ${y - widthPx/2} ${x + widthPx} ${y}" fill="none" stroke="${feature.color}" stroke-width="1.5"/>`;
                svg += `<text x="${x + widthPx/2}" y="${y - 10}" text-anchor="middle" font-size="8" fill="${feature.color}" font-weight="bold">${feature.label}${i + 1}</text>`;
            } else if (feature.type === 'window') {
                svg += `<line x1="${x}" y1="${y}" x2="${x + widthPx}" y2="${y}" stroke="${feature.color}" stroke-width="3"/>`;
                svg += `<line x1="${x}" y1="${y - 4}" x2="${x + widthPx}" y2="${y - 4}" stroke="${feature.color}" stroke-width="1"/>`;
                svg += `<text x="${x + widthPx/2}" y="${y - 10}" text-anchor="middle" font-size="8" fill="${feature.color}" font-weight="bold">${feature.label}${i + 1}</text>`;
            } else {
                svg += `<line x1="${x}" y1="${y}" x2="${x + widthPx}" y2="${y}" stroke="${feature.color}" stroke-width="3" stroke-dasharray="5,3"/>`;
                svg += `<text x="${x + widthPx/2}" y="${y - 10}" text-anchor="middle" font-size="8" fill="${feature.color}" font-weight="bold">${feature.label}${i + 1}</text>`;
            }
        });
    }
    
    // RIGHT WALL (wallIndex 3)
    if (featuresByWall[3].length > 0) {
        featuresByWall[3].forEach((feature, i) => {
            const heightPx = feature.height * scale;
            const position = (i + 1) / (featuresByWall[3].length + 1);
            const x = roomX + roomWidth;
            const y = roomY + (roomHeight * position) - (heightPx / 2);
            
            svg += `<line x1="${x}" y1="${y}" x2="${x}" y2="${y + heightPx}" stroke="${feature.color}" stroke-width="3" stroke-dasharray="${feature.type === 'opening' ? '5,3' : 'none'}"/>`;
            svg += `<text x="${x + 15}" y="${y + heightPx/2}" text-anchor="middle" font-size="8" fill="${feature.color}" font-weight="bold">${feature.label}${i + 1}</text>`;
        });
    }
    
    svg += `</svg>`;
    console.log(`[FloorPlan] SVG generated successfully`);
    return svg;
}

// Helper function to parse door/window width from string like "2'6\"" or "3'0\""
function parseDoorWidth(widthStr) {
    if (typeof widthStr === 'number') return widthStr;
    
    const feetMatch = widthStr.match(/(\d+)'/);
    const inchMatch = widthStr.match(/(\d+)"/);
    
    let feet = feetMatch ? parseInt(feetMatch[1]) : 0;
    let inches = inchMatch ? parseInt(inchMatch[1]) : 0;
    
    return feet + (inches / 12);
}



// =====================================================================
// ESTIMATOR INTEGRATION FOR COCHRAN CLAIMS TOOL
// =====================================================================
class EstimatorIntegration {
    constructor() {
        this.estimator = new QuantityEstimator();
        this.taxRate = 0.08; // Default 8%
        this.opRate = 0.20; // Default 20%
        this.depreciationRate = 0.00; // Default 0% (no depreciation)
        this.deductible = 0.00; // Default $0 deductible
        this.estimator.setTaxRate(this.taxRate);
        this.estimator.setOverheadProfit(this.opRate);
        
        // Initialize selectedItems array
        this.selectedItems = [];
        
        // Check if there are pending selected items from claim data
        if (window.pendingSelectedItems && window.pendingSelectedItems.length > 0) {
            this.selectedItems = window.pendingSelectedItems;
            console.log('‚úÖ Restored', this.selectedItems.length, 'selected items from claim data');
            delete window.pendingSelectedItems; // Clear pending items
        }
        
        // Load favorites and recent items from localStorage
        this.favorites = JSON.parse(localStorage.getItem('estimatorFavorites') || '[]');
        this.recentItems = JSON.parse(localStorage.getItem('estimatorRecentItems') || '[]');
        this.itemNotes = JSON.parse(localStorage.getItem('estimatorItemNotes') || '{}');
        
        this.initUI();
    }
    
    initUI() {
        console.log('üé® Initializing UI...');
        const menu = document.getElementById('estimatorMenu');
        
        if (!menu) {
            console.warn('‚ö†Ô∏è estimatorMenu not found yet - will work when it appears');
            // Don't fail - menu might load later
            return;
        }
        
        console.log('‚úÖ Found menu:', menu);
        
        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.estimator-panel')) {
                if (menu.classList.contains('open')) {
                    console.log('üëÜ Clicked outside - closing menu');
                    menu.classList.remove('open');
                }
            }
        });
        
        console.log('‚úÖ UI initialization complete - button has inline onclick handler');
    }
    
    convertPropertyData() {
        if (!state.rooms || state.rooms.length === 0) {
            throw new Error('No rooms found. Please add some rooms first.');
        }
        
        console.log('=== CONVERTING PROPERTY DATA ===');
        
        return {
            name: state.projectName || "Untitled Property",
            address: "",
            claimNumber: "",
            insured: "",
            levels: [{
                name: "Main Level",
                rooms: state.rooms.map((room, roomIdx) => {
                    console.log(`\n--- Room ${roomIdx}: ${room.name} ---`);
                    
                    const roomLength = this.calculateRoomLength(room);
                    const roomWidth = this.calculateRoomWidth(room);
                    const roomHeight = room.ceilingHeight || 8;
                    
                    const convertedRoom = {
                        name: room.name || "Unnamed Room",
                        dimensions: {
                            length: roomLength,
                            width: roomWidth,
                            height: roomHeight
                        },
                        length: roomLength,  // Keep flat for backward compatibility
                        width: roomWidth,    // Keep flat for backward compatibility
                        height: roomHeight,  // Keep flat for backward compatibility
                        floorType: this.guessFloorType(room),
                        doors: [],
                        windows: [],
                        openings: []
                    };
                    
                    console.log('Room dimensions:', convertedRoom.dimensions.length, 'x', convertedRoom.dimensions.width, 'x', convertedRoom.dimensions.height);
                    
                    // DOORS
                    if (room.doors && room.doors.length > 0) {
                        console.log('Found', room.doors.length, 'doors');
                        convertedRoom.doors = room.doors.map((door, idx) => ({
                            width: door.width || (door.widthInches ? door.widthInches / 12 : 2.5),
                            height: door.height || (door.heightInches ? door.heightInches / 12 : 6.67),
                            widthInches: door.widthInches || 30,
                            heightInches: door.heightInches || 80,
                            position: door.position || null,
                            wallIndex: door.wallIndex !== undefined ? door.wallIndex : null,
                            opensTo: door.opensTo || door.label || ''
                        }));
                    }
                    
                    // WINDOWS
                    if (room.windows && room.windows.length > 0) {
                        console.log('Found', room.windows.length, 'windows');
                        convertedRoom.windows = room.windows.map((window, idx) => ({
                            width: window.width || (window.widthInches ? window.widthInches / 12 : 3),
                            height: window.height || (window.heightInches ? window.heightInches / 12 : 4),
                            widthInches: window.widthInches || 36,
                            heightInches: window.heightInches || 48,
                            position: window.position || null,
                            wallIndex: window.wallIndex !== undefined ? window.wallIndex : null,
                            heightFromFloor: window.heightFromFloor || window.floorHeight || 3
                        }));
                    }
                    
                    // WALL CUTS from missingWalls
                    if (room.walls && room.walls.length > 0) {
                        console.log('Checking', room.walls.length, 'walls for missing sections');
                        
                        room.walls.forEach((wall, wallIndex) => {
                            if (wall.missingWalls && wall.missingWalls.length > 0) {
                                console.log(`  Wall ${wallIndex} (${wall.name}) has ${wall.missingWalls.length} missing section(s)`);
                                
                                wall.missingWalls.forEach((missing, idx) => {
                                    const width = missing.endDist - missing.startDist;
                                    const height = missing.height || convertedRoom.height;
                                    
                                    convertedRoom.openings.push({
                                        start: missing.startDist || 0,
                                        end: missing.endDist || width,
                                        width: width,
                                        height: height,
                                        wallIndex: wallIndex,
                                        position: missing.startDist + (width / 2),
                                        opensTo: missing.opensTo || missing.label || 'Exterior'
                                    });
                                });
                            }
                        });
                    }
                    
                    console.log('TOTAL:', convertedRoom.doors.length, 'doors,', 
                               convertedRoom.windows.length, 'windows,',
                               convertedRoom.openings.length, 'openings');
                    
                    return convertedRoom;
                })
            }]
        };
    }
    
    calculateRoomLength(room) {
        if (room.walls && room.walls.length > 0) {
            const lengths = room.walls.map(w => parseFloat(w.length || 0));
            return Math.max(...lengths);
        }
        if (room.floorPoints && room.floorPoints.length >= 2) {
            const xs = room.floorPoints.map(p => p.x);
            return (Math.max(...xs) - Math.min(...xs)) / 30;
        }
        return 12;
    }
    
    calculateRoomWidth(room) {
        if (room.walls && room.walls.length >= 2) {
            const lengths = room.walls.map(w => parseFloat(w.length || 0)).sort((a, b) => b - a);
            return lengths[1] || lengths[0] || 10;
        }
        if (room.floorPoints && room.floorPoints.length >= 2) {
            const ys = room.floorPoints.map(p => p.y);
            return (Math.max(...ys) - Math.min(...ys)) / 30;
        }
        return 10;
    }
    guessFloorType(room) {
        return "carpet";
    }

    
    async generateEstimate() {
        try {
            const propertyData = this.convertPropertyData();
            return this.estimator.generateEstimate(propertyData);
        } catch (error) {
            console.error('Error:', error);
            this.showError(error.message);
            return null;
        }
    }
    
    async exportHTML() {
        const estimate = this.currentEstimate || await this.generateEstimate();
        if (!estimate) return;
        
        try {
            const html = generateHTMLReport(estimate);
            const newWindow = window.open();
            if (newWindow) {
                newWindow.document.write(html);
                newWindow.document.close();
                this.showSuccess('Report opened!');
            } else {
                this.showError('Please allow pop-ups');
            }
        } catch (error) {
            this.showError('Error: ' + error.message);
        }
    }
    
    async exportExcel() {
        const estimate = this.currentEstimate || await this.generateEstimate();
        if (!estimate) return;
        
        try {
            this.showLoading('Generating Professional Excel Invoice...');
            
            const wb = XLSX.utils.book_new();
            const data = [];
            
            // ===== INVOICE HEADER =====
            data.push(['‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó']);
            data.push(['‚ïë                                    ESTIMATE / INVOICE                                         ‚ïë']);
            data.push(['‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù']);
            data.push([]);
            data.push(['FROM:                                           PROJECT INFORMATION:']);
            data.push(['Your Company Name Here                          Project:', estimate.metadata.projectName]);
            data.push(['123 Main Street                                 Date:', estimate.metadata.date]);
            data.push(['City, State 12345                               Estimate #:', 'EST-' + Date.now().toString().slice(-6)]);
            data.push(['Phone: (555) 123-4567                           Tax Rate:', (estimate.metadata.taxRate || '8.00') + '%']);
            data.push(['Email: info@yourcompany.com                     O&P Rate:', (estimate.metadata.opRate || '20.00') + '%']);
            data.push([]);
            data.push(['‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê']);
            data.push([]);
            
            // ===== COLUMN HEADERS =====
            const taxRateText = estimate.metadata.taxRate || '8.00';
            const opRateText = estimate.metadata.opRate || '20.00';
            data.push(['ITEM DESCRIPTION', 'QTY', 'UNIT', 'UNIT PRICE', 'SUBTOTAL', `TAX (${taxRateText}%)`, `O&P (${opRateText}%)`, 'TOTAL']);
            data.push(['‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ']);
            
            // ===== PROCESS EACH LEVEL =====
            estimate.levels.forEach((level, levelIdx) => {
                data.push([]);
                data.push([]);
                data.push([`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó`]);
                data.push([`‚ïë  ${level.name.toUpperCase()}`]);
                data.push([`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`]);
                data.push([]);
                
                // Get property data to group by room
                const propertyData = this.convertPropertyData();
                const levelRooms = propertyData.levels[levelIdx]?.rooms || [];
                
                // Process each room
                levelRooms.forEach((room, roomIdx) => {
                    const roomItems = level.lineItems.filter(item => 
                        item.description.includes(room.name)
                    );
                    
                    if (roomItems.length > 0) {
                        // ROOM HEADER
                        const roomLength = room.dimensions?.length || 0;
                        const roomWidth = room.dimensions?.width || 0;
                        const roomArea = (roomLength * roomWidth).toFixed(0);
                        
                        data.push([]);
                        data.push([`‚ñ∂ ${room.name.toUpperCase()} - ${roomLength}' √ó ${roomWidth}' (${roomArea} SF)`]);
                        data.push(['   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê']);
                        
                        // ROOM ITEMS
                        let roomSubtotal = 0;
                        let roomTax = 0;
                        let roomOP = 0;
                        let roomTotal = 0;
                        
                        roomItems.forEach((item, idx) => {
                            const qty = parseFloat(item.quantity);
                            const unitPrice = parseFloat(item.unitPrice);
                            const subtotal = parseFloat(item.subtotal || (qty * unitPrice));
                            const tax = parseFloat(item.tax);
                            const op = parseFloat(item.op);
                            const total = parseFloat(item.rcv);
                            
                            roomSubtotal += subtotal;
                            roomTax += tax;
                            roomOP += op;
                            roomTotal += total;
                            
                            data.push([
                                `   ‚îÇ ${idx + 1}. ${item.description.replace(`${room.name} - `, '')}`,
                                qty.toFixed(2),
                                item.unit,
                                '$' + unitPrice.toFixed(2),
                                '$' + subtotal.toFixed(2),
                                '$' + tax.toFixed(2),
                                '$' + op.toFixed(2),
                                '$' + total.toFixed(2)
                            ]);
                        });
                        
                        data.push(['   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò']);
                        data.push([]);
                        
                        // ROOM SUBTOTAL
                        data.push([
                            `   ‚ñ∏ ${room.name} SUBTOTAL:`,
                            '', '', '',
                            '$' + roomSubtotal.toFixed(2),
                            '$' + roomTax.toFixed(2),
                            '$' + roomOP.toFixed(2),
                            '$' + roomTotal.toFixed(2)
                        ]);
                        
                        data.push([]);
                        data.push(['   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê']);
                        data.push([]);
                    }
                });
                
                // LEVEL TOTAL
                const levelTotal = level.lineItems.reduce((sum, item) => sum + parseFloat(item.rcv || 0), 0);
                data.push([]);
                data.push([
                    `   ‚ñ∂‚ñ∂ ${level.name.toUpperCase()} TOTAL:`,
                    '', '', '', '', '', '',
                    '$' + levelTotal.toFixed(2)
                ]);
                data.push([]);
                data.push(['‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó']);
                data.push([]);
            });
            
            // ===== GRAND TOTALS =====
            data.push([]);
            data.push([]);
            data.push(['', '', '', '', '', '‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó']);
            data.push(['', '', '', '', '', '‚ïë    ‚ñº  ESTIMATE SUMMARY  ‚ñº              ‚ïë']);
            data.push(['', '', '', '', '', '‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù']);
            data.push([]);
            data.push(['', '', '', '', '', 'Subtotal:', '', '$' + parseFloat(estimate.totals.subtotal || 0).toFixed(2)]);
            data.push(['', '', '', '', '', `Sales Tax (${taxRateText}%):`, '', '$' + parseFloat(estimate.totals.tax).toFixed(2)]);
            data.push(['', '', '', '', '', `Overhead & Profit (${opRateText}%):`, '', '$' + parseFloat(estimate.totals.op).toFixed(2)]);
            data.push(['', '', '', '', '', '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', '', '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ']);
            data.push(['', '', '', '', '', '*** TOTAL AMOUNT ***', '', '$' + parseFloat(estimate.totals.rcv).toFixed(2)]);
            data.push(['', '', '', '', '', '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', '', '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê']);
            data.push([]);
            data.push([]);
            data.push(['‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó']);
            data.push(['‚ïë TERMS & CONDITIONS:                                                                           ‚ïë']);
            data.push(['‚ïë ‚Ä¢ Payment due within 30 days of invoice date                                                  ‚ïë']);
            data.push(['‚ïë ‚Ä¢ This estimate is valid for 30 days from the date above                                      ‚ïë']);
            data.push(['‚ïë ‚Ä¢ Prices subject to change based on material availability                                     ‚ïë']);
            data.push(['‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù']);
            
            const ws = XLSX.utils.aoa_to_sheet(data);
            
            // Set column widths
            ws['!cols'] = [
                { wch: 60 },  // Description (wider for box drawing)
                { wch: 10 },  // Qty
                { wch: 8 },   // Unit
                { wch: 12 },  // Unit Price
                { wch: 12 },  // Subtotal
                { wch: 12 },  // Tax
                { wch: 12 },  // O&P
                { wch: 14 }   // Total
            ];
            
            XLSX.utils.book_append_sheet(wb, ws, "Invoice");
            
            // ===== PROFESSIONAL FORMATTING =====
            // Add cell styles for headers, totals, and currency
            const range = XLSX.utils.decode_range(ws['!ref']);
            
            // Format all cells
            for (let R = range.s.r; R <= range.e.r; ++R) {
                for (let C = range.s.c; C <= range.e.c; ++C) {
                    const cellAddress = XLSX.utils.encode_cell({r: R, c: C});
                    if (!ws[cellAddress]) continue;
                    
                    const cell = ws[cellAddress];
                    
                    // Initialize cell style
                    if (!cell.s) cell.s = {};
                    
                    // Format currency cells
                    if (typeof cell.v === 'string' && cell.v.startsWith('$')) {
                        // Remove $ and convert to number for proper formatting
                        const numValue = parseFloat(cell.v.replace('$', '').replace(',', ''));
                        if (!isNaN(numValue)) {
                            cell.t = 'n';
                            cell.v = numValue;
                            cell.z = '$#,##0.00';
                        }
                    }
                    
                    // Bold and color for header rows
                    if (R <= 2 || (cell.v && typeof cell.v === 'string' && 
                        (cell.v.includes('ESTIMATE / INVOICE') || 
                         cell.v.includes('PROJECT INFORMATION') ||
                         cell.v.includes('ITEM DESCRIPTION')))) {
                        cell.s = {
                            font: { bold: true, sz: 12 },
                            fill: { fgColor: { rgb: "4472C4" } },
                            alignment: { horizontal: "center", vertical: "center" }
                        };
                    }
                    
                    // Bold for column headers
                    if (R === 11 && cell.v && cell.v.includes('ITEM DESCRIPTION')) {
                        cell.s = {
                            font: { bold: true, sz: 11, color: { rgb: "FFFFFF" } },
                            fill: { fgColor: { rgb: "2F5496" } },
                            alignment: { horizontal: "center", vertical: "center" },
                            border: {
                                top: { style: "thick", color: { rgb: "000000" } },
                                bottom: { style: "thick", color: { rgb: "000000" } },
                                left: { style: "thin", color: { rgb: "000000" } },
                                right: { style: "thin", color: { rgb: "000000" } }
                            }
                        };
                    }
                    
                    // Bold for level headers
                    if (cell.v && typeof cell.v === 'string' && 
                        (cell.v.includes('LEVEL') || cell.v.includes('FLOOR'))) {
                        cell.s = {
                            font: { bold: true, sz: 11 },
                            fill: { fgColor: { rgb: "D9E1F2" } }
                        };
                    }
                    
                    // Bold and highlight for room headers
                    if (cell.v && typeof cell.v === 'string' && cell.v.startsWith('‚ñ∂ ')) {
                        cell.s = {
                            font: { bold: true, sz: 10 },
                            fill: { fgColor: { rgb: "E7E6E6" } }
                        };
                    }
                    
                    // Bold for subtotals
                    if (cell.v && typeof cell.v === 'string' && 
                        (cell.v.includes('SUBTOTAL') || cell.v.includes('TOTAL'))) {
                        cell.s = {
                            font: { bold: true, sz: 10 },
                            fill: { fgColor: { rgb: "FFF2CC" } }
                        };
                    }
                    
                    // Extra bold for GRAND TOTAL
                    if (cell.v && typeof cell.v === 'string' && cell.v.includes('*** TOTAL AMOUNT ***')) {
                        cell.s = {
                            font: { bold: true, sz: 14, color: { rgb: "C00000" } },
                            fill: { fgColor: { rgb: "FFFF00" } },
                            alignment: { horizontal: "right", vertical: "center" }
                        };
                    }
                    
                    // Center align numbers
                    if (C >= 1 && C <= 7 && cell.t === 'n') {
                        if (!cell.s) cell.s = {};
                        if (!cell.s.alignment) cell.s.alignment = {};
                        cell.s.alignment.horizontal = "center";
                    }
                }
            }
            
            // Freeze top rows (headers)
            ws['!freeze'] = { xSplit: 0, ySplit: 12, topLeft: 'A13', activePane: 'bottomLeft' };
            
            // Generate and download
            XLSX.writeFile(wb, `${estimate.metadata.projectName}_Invoice.xlsx`);
            
            this.hideLoading();
            this.showSuccess('Professional Excel invoice downloaded!');
        } catch (error) {
            console.error('Excel export error:', error);
            this.hideLoading();
            this.showError('Error generating Excel: ' + error.message);
        }
    }
    
    async exportPDF() {
        const estimate = this.currentEstimate || await this.generateEstimate();
        if (!estimate) return;
        
        try {
            this.showLoading('Generating PDF...');
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            let yPos = 16;
            
            // Header - MODEST SIZE
            doc.setFontSize(20);
            doc.setFont(undefined, 'bold');
            doc.text('QUANTITY ESTIMATE', 105, yPos, { align: 'center' });
            yPos += 9;
            
            doc.setFontSize(12);
            doc.setFont(undefined, 'normal');
            doc.text(`${estimate.metadata.projectName} | ${estimate.metadata.date}`, 105, yPos, { align: 'center' });
            yPos += 7;
            
            // Decorative line
            doc.setDrawColor(30, 60, 114);
            doc.setLineWidth(0.4);
            doc.line(15, yPos, 195, yPos);
            yPos += 10;
            
            // Get property data
            const propertyData = this.convertPropertyData();
            
            // Process each level
            for (let levelIdx = 0; levelIdx < estimate.levels.length; levelIdx++) {
                const level = estimate.levels[levelIdx];
                
                // Check if we need a new page
                if (yPos > 255) {
                    doc.addPage();
                    yPos = 16;
                }
                
                // Level header - MODEST SIZE
                doc.setFontSize(14);
                doc.setFont(undefined, 'bold');
                doc.setTextColor(30, 60, 114);
                doc.text(level.name, 15, yPos);
                doc.setTextColor(0, 0, 0);
                yPos += 7;
                
                // Get rooms for this level
                const levelRooms = propertyData.levels[levelIdx]?.rooms || [];
                
                console.log(`üìä Level ${level.name}: ${level.lineItems?.length || 0} total items, ${levelRooms.length} rooms`);
                
                // Track which items we've shown
                let shownItemIds = new Set();
                
                // Process each room
                for (let roomIdx = 0; roomIdx < levelRooms.length; roomIdx++) {
                    const room = levelRooms[roomIdx];
                    
                    // Get line items for this room FIRST
                    const roomItems = level.lineItems.filter(item => 
                        item.description.includes(room.name)
                    );
                    
                    console.log(`  Room ${room.name}: ${roomItems.length} items`);
                    
                    // SKIP room if it has no items
                    if (roomItems.length === 0) {
                        continue;
                    }
                    
                    // Track these items as shown
                    roomItems.forEach(item => shownItemIds.add(item.description));
                    
                    // Check if we need a new page
                    if (yPos > 245) {
                        doc.addPage();
                        yPos = 16;
                    }
                    
                    // Room header - MODEST SIZE
                    doc.setFontSize(12);
                    doc.setFont(undefined, 'bold');
                    const roomLength = room.dimensions?.length || 0;
                    const roomWidth = room.dimensions?.width || 0;
                    const roomArea = (roomLength * roomWidth).toFixed(0);
                    doc.text(`${room.name} - ${roomLength}' √ó ${roomWidth}' (${roomArea} SF)`, 20, yPos);
                    doc.setFont(undefined, 'normal');
                    yPos += 6;
                    
                    // Add floor plan for this room
                    try {
                        const svg = generateFloorPlanSVG(room);
                        const svgElement = document.createElement('div');
                        svgElement.innerHTML = svg;
                        const svgNode = svgElement.querySelector('svg');
                        
                        if (svgNode) {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            const svgWidth = parseInt(svgNode.getAttribute('width') || 300);
                            const svgHeight = parseInt(svgNode.getAttribute('height') || 200);
                            
                            canvas.width = svgWidth;
                            canvas.height = svgHeight;
                            
                            const svgData = new XMLSerializer().serializeToString(svgNode);
                            const img = new Image();
                            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                            const url = URL.createObjectURL(svgBlob);
                            
                            await new Promise((resolve) => {
                                img.onload = () => {
                                    ctx.drawImage(img, 0, 0);
                                    const imgData = canvas.toDataURL('image/png');
                                    
                                    // max 60mm wide, 30mm tall
                                    const maxWidth = 60;
                                    const maxHeight = 30;
                                    let imgWidth = svgWidth * 0.264583;
                                    let imgHeight = svgHeight * 0.264583;
                                    
                                    if (imgWidth > maxWidth) {
                                        imgHeight = (imgHeight * maxWidth) / imgWidth;
                                        imgWidth = maxWidth;
                                    }
                                    if (imgHeight > maxHeight) {
                                        imgWidth = (imgWidth * maxHeight) / imgHeight;
                                        imgHeight = maxHeight;
                                    }
                                    
                                    // Add image to PDF
                                    doc.addImage(imgData, 'PNG', 20, yPos, imgWidth, imgHeight);
                                    URL.revokeObjectURL(url);
                                    resolve();
                                };
                                img.onerror = () => resolve();
                                img.src = url;
                            });
                            
                            yPos += 35;
                        }
                    } catch (err) {
                        yPos += 2;
                    }
                    
                    // Render table (we know roomItems.length > 0)
                    if (roomItems.length > 0) {
                        const tableData = roomItems.map(item => [
                            item.description.replace(`${room.name} - `, ''),
                            item.quantity,
                            item.unit,
                            '$' + item.unitPrice,
                            '$' + item.subtotal,
                            '$' + item.tax,
                            '$' + item.op,
                            '$' + item.rcv
                        ]);
                        
                        doc.autoTable({
                            startY: yPos,
                            head: [['ITEM', 'QTY', 'UNIT', 'PRICE', 'SUBTOTAL', 'TAX', 'O&P', 'TOTAL']],
                            body: tableData,
                            theme: 'striped',
                            styles: { 
                                fontSize: 9, 
                                cellPadding: 2.5,
                                overflow: 'linebreak',
                                cellWidth: 'auto'
                            },
                            headStyles: { 
                                fillColor: [30, 60, 114], 
                                fontStyle: 'bold', 
                                fontSize: 10,
                                minCellHeight: 8,
                                valign: 'middle'
                            },
                            alternateRowStyles: { fillColor: [245, 245, 245] },
                            margin: { left: 15, right: 10 },
                            columnStyles: {
                                0: { cellWidth: 56 },
                                1: { cellWidth: 15, halign: 'center' },
                                2: { cellWidth: 13, halign: 'center' },
                                3: { cellWidth: 20, halign: 'right' },
                                4: { cellWidth: 26, halign: 'right' },
                                5: { cellWidth: 16, halign: 'right' },
                                6: { cellWidth: 20, halign: 'right' },
                                7: { cellWidth: 24, halign: 'right' }
                            }
                        });
                        
                        yPos = doc.lastAutoTable.finalY + 7;
                    }
                }
                
                // FALLBACK: Show any items that weren't matched to a room
                const unmatchedItems = level.lineItems.filter(item => 
                    !shownItemIds.has(item.description)
                );
                
                if (unmatchedItems.length > 0) {
                    console.log(`  ‚ö†Ô∏è ${unmatchedItems.length} unmatched items - showing under "Other Items"`);
                    
                    // Check if we need a new page
                    if (yPos > 240) {
                        doc.addPage();
                        yPos = 16;
                    }
                    
                    // "Other Items" header
                    doc.setFontSize(12);
                    doc.setFont(undefined, 'bold');
                    doc.text(`Other Items`, 20, yPos);
                    doc.setFont(undefined, 'normal');
                    yPos += 8;
                    
                    // Show table with unmatched items
                    const tableData = unmatchedItems.map(item => [
                        item.description,
                        item.quantity,
                        item.unit,
                        '$' + item.unitPrice,
                        '$' + item.subtotal,
                        '$' + item.tax,
                        '$' + item.op,
                        '$' + item.rcv
                    ]);
                    
                    doc.autoTable({
                        startY: yPos,
                        head: [['ITEM', 'QTY', 'UNIT', 'PRICE', 'SUBTOTAL', 'TAX', 'O&P', 'TOTAL']],
                        body: tableData,
                        theme: 'striped',
                        styles: { 
                            fontSize: 9, 
                            cellPadding: 2.5,
                            overflow: 'linebreak',
                            cellWidth: 'auto'
                        },
                        headStyles: { 
                            fillColor: [30, 60, 114], 
                            fontStyle: 'bold', 
                            fontSize: 10,
                            minCellHeight: 8,
                            valign: 'middle'
                        },
                        alternateRowStyles: { fillColor: [245, 245, 245] },
                        margin: { left: 15, right: 10 },
                        columnStyles: {
                            0: { cellWidth: 56 },
                            1: { cellWidth: 15, halign: 'center' },
                            2: { cellWidth: 13, halign: 'center' },
                            3: { cellWidth: 20, halign: 'right' },
                            4: { cellWidth: 26, halign: 'right' },
                            5: { cellWidth: 16, halign: 'right' },
                            6: { cellWidth: 20, halign: 'right' },
                            7: { cellWidth: 24, halign: 'right' }
                        }
                    });
                    
                    yPos = doc.lastAutoTable.finalY + 7;
                }
                
                // Add level total - MODEST SIZE
                if (yPos > 260) {
                    doc.addPage();
                    yPos = 16;
                }
                
                doc.setFontSize(11);
                doc.setFont(undefined, 'bold');
                doc.text(`${level.name} Subtotal: $${level.lineItems.reduce((sum, item) => sum + parseFloat(item.rcv || 0), 0).toFixed(2)}`, 20, yPos);
                yPos += 11;
            }
            
            // Grand Total - FIXED OVERLAP
            if (yPos > 220) {
                doc.addPage();
                yPos = 16;
            }
            
            doc.setDrawColor(30, 60, 114);
            doc.setLineWidth(0.5);
            doc.line(15, yPos, 195, yPos);
            yPos += 9;
            
            doc.setFontSize(16);
            doc.setFont(undefined, 'bold');
            doc.text('PROJECT TOTALS', 105, yPos, { align: 'center' });
            yPos += 12;
            
            doc.setFontSize(12);
            doc.text('Subtotal:', 100, yPos);
            doc.text(`$${estimate.totals.subtotal}`, 180, yPos, { align: 'right' });
            yPos += 9;
            
            const taxRateText = estimate.metadata.taxRate || '8.00';
            doc.text(`Tax (${taxRateText}%):`, 100, yPos);
            doc.text(`$${estimate.totals.tax}`, 180, yPos, { align: 'right' });
            yPos += 9;
            
            const opRateText = estimate.metadata.opRate || '20.00';
            doc.text(`O&P (${opRateText}%):`, 100, yPos);
            doc.text(`$${estimate.totals.op}`, 180, yPos, { align: 'right' });
            yPos += 10;
            
            doc.setDrawColor(0, 0, 0);
            doc.setLineWidth(0.5);
            doc.line(100, yPos, 180, yPos);
            yPos += 10;
            
            doc.setFontSize(15);
            doc.text('GRAND TOTAL:', 100, yPos);
            doc.text(`$${estimate.totals.rcv}`, 180, yPos, { align: 'right' });
            
            doc.save(`${estimate.metadata.projectName}_Estimate.pdf`);
            
            this.hideLoading();
            this.showSuccess('PDF downloaded!');
        } catch (error) {
            this.hideLoading();
            this.showError('Error: ' + error.message);
            console.error('PDF Error:', error);
        }
    }
    
    async exportInsuranceClaim() {
        const estimate = this.currentEstimate || await this.generateEstimate();
        if (!estimate) return;
        
        try {
            this.showLoading('Generating Insurance Claim Summary...');
            
            // Calculate claim values - handle different estimate structures
            let lineItemTotal = 0;
            
            // Try to get line item total from different possible structures
            if (estimate.categories && Array.isArray(estimate.categories)) {
                lineItemTotal = estimate.categories.reduce((sum, cat) => sum + (cat.total || 0), 0);
            } else if (estimate.items && Array.isArray(estimate.items)) {
                lineItemTotal = estimate.items.reduce((sum, item) => sum + ((item.quantity || 0) * (item.unitPrice || 0)), 0);
            } else if (this.selectedItems && Array.isArray(this.selectedItems)) {
                lineItemTotal = this.selectedItems.reduce((sum, item) => sum + ((item.quantity || 0) * (item.unitPrice || 0)), 0);
            }
            
            const overhead = lineItemTotal * this.opRate;
            const profit = lineItemTotal * this.opRate; // O&P includes both
            const tax = (lineItemTotal + overhead + profit) * this.taxRate;
            const rcv = lineItemTotal + overhead + profit + tax; // Replacement Cost Value
            const depreciationAmount = rcv * this.depreciationRate;
            const acv = rcv - depreciationAmount; // Actual Cash Value
            const netClaim = Math.max(0, acv - this.deductible);
            const netIfRecovered = Math.max(0, rcv - this.deductible);
            
            // Get project name
            const projectName = estimate.metadata?.projectName || 'Dwelling';
            
            // Generate HTML
            const html = `
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>Insurance Claim Summary - ${projectName}</title>
                    <style>
                        body {
                            font-family: 'Times New Roman', serif;
                            max-width: 800px;
                            margin: 40px auto;
                            padding: 20px;
                            line-height: 1.6;
                        }
                        h1 {
                            text-align: center;
                            font-size: 28px;
                            margin-bottom: 40px;
                            border-bottom: 3px double #000;
                            padding-bottom: 15px;
                        }
                        .claim-line {
                            display: flex;
                            justify-content: space-between;
                            padding: 8px 0;
                            font-size: 16px;
                        }
                        .claim-line.total {
                            font-weight: bold;
                            font-size: 18px;
                            border-top: 2px solid #000;
                            margin-top: 10px;
                            padding-top: 15px;
                        }
                        .claim-line.final {
                            font-weight: bold;
                            font-size: 20px;
                            border-top: 3px double #000;
                            border-bottom: 3px double #000;
                            margin: 15px 0;
                            padding: 15px 0;
                        }
                        .amount {
                            text-align: right;
                            min-width: 150px;
                        }
                        .negative {
                            color: #000;
                        }
                        .section-header {
                            margin-top: 30px;
                            padding: 5px 0;
                            border-bottom: 1px solid #000;
                        }
                        @media print {
                            body { margin: 0; padding: 20px; }
                        }
                    </style>
                </head>
                <body>
                    <h1>Summary for ${projectName}</h1>
                    
                    <div class="claim-line">
                        <span>Line Item Total</span>
                        <span class="amount">${lineItemTotal.toFixed(2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')}</span>
                    </div>
                    <div class="claim-line">
                        <span>Overhead</span>
                        <span class="amount">${overhead.toFixed(2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')}</span>
                    </div>
                    <div class="claim-line">
                        <span>Profit</span>
                        <span class="amount">${profit.toFixed(2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')}</span>
                    </div>
                    <div class="claim-line">
                        <span>Total Tax(Rep-Maint)</span>
                        <span class="amount">${tax.toFixed(2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')}</span>
                    </div>
                    
                    <div class="claim-line total">
                        <span>Replacement Cost Value</span>
                        <span class="amount">$${rcv.toFixed(2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')}</span>
                    </div>
                    <div class="claim-line negative">
                        <span>Less Depreciation</span>
                        <span class="amount">(${depreciationAmount.toFixed(2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')})</span>
                    </div>
                    
                    <div class="claim-line total">
                        <span>Actual Cash Value</span>
                        <span class="amount">$${acv.toFixed(2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')}</span>
                    </div>
                    <div class="claim-line negative">
                        <span>Less Deductible</span>
                        <span class="amount">(${this.deductible.toFixed(2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')})</span>
                    </div>
                    
                    <div class="claim-line final">
                        <span>Net Claim</span>
                        <span class="amount">$${netClaim.toFixed(2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')}</span>
                    </div>
                    
                    <div class="section-header"></div>
                    
                    <div class="claim-line" style="margin-top: 20px;">
                        <span>Total Recoverable Depreciation</span>
                        <span class="amount">${depreciationAmount.toFixed(2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')}</span>
                    </div>
                    
                    <div class="claim-line total">
                        <span>Net Claim if Depreciation is Recovered</span>
                        <span class="amount">$${netIfRecovered.toFixed(2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')}</span>
                    </div>
                    
                </body>
                </html>
            `;
            
            const newWindow = window.open();
            if (newWindow) {
                newWindow.document.write(html);
                newWindow.document.close();
                this.hideLoading();
                this.showSuccess('Insurance Claim Summary opened! You can print or save as PDF.');
            } else {
                this.hideLoading();
                this.showError('Please allow pop-ups to view the claim summary');
            }
        } catch (error) {
            this.hideLoading();
            this.showError('Error: ' + error.message);
            console.error('Insurance Claim Export Error:', error);
        }
    }
    
    async exportCSV() {
        if (!this.selectedItems || this.selectedItems.length === 0) {
            this.showError('No items to export');
            return;
        }
        
        try {
            this.showLoading('Generating CSV...');
            
            // Calculate totals
            const subtotal = this.selectedItems.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0);
            const tax = subtotal * this.taxRate;
            const op = subtotal * this.opRate;
            const total = subtotal + tax + op;
            
            // Build CSV
            let csv = 'Item Name,Category,Quantity,Unit,Unit Price,Total\n';
            
            this.selectedItems.forEach(item => {
                const itemTotal = item.quantity * item.unitPrice;
                csv += `"${item.name}","${item.category}",${item.quantity},"${item.unit}",${item.unitPrice.toFixed(2)},${itemTotal.toFixed(2)}\n`;
            });
            
            csv += '\n';
            csv += `Subtotal,,,,,${subtotal.toFixed(2)}\n`;
            csv += `Tax (${(this.taxRate * 100).toFixed(2)}%),,,,,${tax.toFixed(2)}\n`;
            csv += `O&P (${(this.opRate * 100).toFixed(2)}%),,,,,${op.toFixed(2)}\n`;
            csv += `TOTAL,,,,,${total.toFixed(2)}\n`;
            
            // Download CSV
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `Estimate_${Date.now()}.csv`;
            a.click();
            
            this.hideLoading();
            this.showSuccess('CSV downloaded!');
        } catch (error) {
            this.hideLoading();
            this.showError('Error: ' + error.message);
        }
    }
    
    async exportPlainText() {
        if (!this.selectedItems || this.selectedItems.length === 0) {
            this.showError('No items to export');
            return;
        }
        
        try {
            this.showLoading('Generating text...');
            
            // Calculate totals
            const subtotal = this.selectedItems.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0);
            const tax = subtotal * this.taxRate;
            const op = subtotal * this.opRate;
            const total = subtotal + tax + op;
            
            // Build plain text
            let text = '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
            text += '                  ESTIMATE                         \n';
            text += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';
            
            text += `Date: ${new Date().toLocaleDateString()}\n\n`;
            
            text += 'ITEMS:\n';
            text += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
            
            this.selectedItems.forEach((item, idx) => {
                const itemTotal = item.quantity * item.unitPrice;
                text += `${idx + 1}. ${item.name}\n`;
                text += `   ${item.quantity} ${item.unit} @ $${item.unitPrice.toFixed(2)}/${item.unit} = $${itemTotal.toFixed(2)}\n\n`;
            });
            
            text += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
            text += `Subtotal:          $${subtotal.toFixed(2)}\n`;
            text += `Tax (${(this.taxRate * 100).toFixed(2)}%):           $${tax.toFixed(2)}\n`;
            text += `O&P (${(this.opRate * 100).toFixed(2)}%):          $${op.toFixed(2)}\n`;
            text += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
            text += `TOTAL:             $${total.toFixed(2)}\n`;
            text += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
            
            // Copy to clipboard
            navigator.clipboard.writeText(text).then(() => {
                this.hideLoading();
                this.showSuccess('Text copied to clipboard! Paste anywhere.');
            }).catch(() => {
                // Fallback: download as text file
                const blob = new Blob([text], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `Estimate_${Date.now()}.txt`;
                a.click();
                this.hideLoading();
                this.showSuccess('Text file downloaded!');
            });
        } catch (error) {
            this.hideLoading();
            this.showError('Error: ' + error.message);
        }
    }
    
    async exportEmail() {
        if (!this.selectedItems || this.selectedItems.length === 0) {
            this.showError('No items to export');
            return;
        }
        
        try {
            this.showLoading('Opening Gmail...');
            
            // Calculate totals
            const subtotal = this.selectedItems.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0);
            const tax = subtotal * this.taxRate;
            const op = subtotal * this.opRate;
            const total = subtotal + tax + op;
            
            // Build email body for Gmail
            let body = `ESTIMATE%0D%0A`;
            body += `Date: ${new Date().toLocaleDateString()}%0D%0A%0D%0A`;
            
            body += `ITEMS:%0D%0A`;
            body += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ%0D%0A`;
            
            this.selectedItems.forEach((item, idx) => {
                const itemTotal = item.quantity * item.unitPrice;
                body += `${idx + 1}. ${encodeURIComponent(item.name)}%0D%0A`;
                body += `   ${item.quantity} ${item.unit} @ $${item.unitPrice.toFixed(2)} = $${itemTotal.toFixed(2)}%0D%0A%0D%0A`;
            });
            
            body += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ%0D%0A`;
            body += `Subtotal: $${subtotal.toFixed(2)}%0D%0A`;
            body += `Tax: $${tax.toFixed(2)}%0D%0A`;
            body += `O&P: $${op.toFixed(2)}%0D%0A`;
            body += `TOTAL: $${total.toFixed(2)}%0D%0A`;
            
            const subject = encodeURIComponent(`Estimate - ${new Date().toLocaleDateString()}`);
            
            // Open Gmail compose window
            const gmailUrl = `https://mail.google.com/mail/?view=cm&fs=1&to=&su=${subject}&body=${body}`;
            
            window.open(gmailUrl, '_blank');
            
            this.hideLoading();
            this.showSuccess('Gmail opened in new tab!');
        } catch (error) {
            this.hideLoading();
            this.showError('Error: ' + error.message);
        }
    }
    
    showLoading(msg = 'Processing...') {
        const overlay = document.createElement('div');
        overlay.className = 'estimator-loading';
        overlay.id = 'estimatorLoading';
        overlay.innerHTML = `<div class="estimator-loading-content">
            <div class="estimator-loading-spinner"></div>
            <div>${msg}</div>
        </div>`;
        document.body.appendChild(overlay);
    }
    
    hideLoading() {
        const el = document.getElementById('estimatorLoading');
        if (el) el.remove();
    }
    
    showSuccess(msg) {
        this.showToast(msg, '');
    }
    
    openLoadEstimateFromMain() {
        // Close the estimator menu
        const menu = document.getElementById('estimatorMenu');
        if (menu) menu.classList.remove('open');
        
        // Open load dialog
        this.openLoadEstimate();
    }
    
    saveEstimateJSON() {
        if (!this.currentEstimate) {
            this.showError('No estimate to save. Generate one first!');
            return;
        }
        
        try {
            const json = JSON.stringify(this.currentEstimate, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${this.currentEstimate.metadata.projectName}_Estimate.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            this.showSuccess('Estimate saved! You can load it later to edit.');
        } catch (error) {
            this.showError('Error saving: ' + error.message);
        }
    }
    
    openLoadEstimate() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const estimate = JSON.parse(event.target.result);
                        this.currentEstimate = estimate;
                        this.showSuccess('Estimate loaded! Opening editor...');
                        this.openEstimateEditor(estimate);
                    } catch (error) {
                        this.showError('Error loading file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
        };
        input.click();
    }
    
    openEstimateEditor(estimate) {
        // Create editor modal
        const modal = document.createElement('div');
        modal.id = 'estimateEditorModal';
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 10002;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        `;
        
        modal.innerHTML = `
            <div style="background: white; border-radius: 12px; width: 95%; max-width: 1200px; height: 90vh; display: flex; flex-direction: column; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
                <div style="padding: 20px; border-bottom: 2px solid #e0e0e0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 12px 12px 0 0;">
                    <h2 style="margin: 0;">‚úèÔ∏è Edit Estimate: ${estimate.metadata.projectName}</h2>
                    <p style="margin: 5px 0 0 0; opacity: 0.9; font-size: 14px;">Edit line items, quantities, and prices below. Changes auto-calculate.</p>
                </div>
                
                <div style="flex: 1; overflow-y: auto; padding: 20px;" id="editorContent">
                    <!-- Will be populated by renderEstimateEditor() -->
                </div>
                
                <div style="padding: 20px; border-top: 2px solid #e0e0e0; background: #f8f9fa; display: flex; justify-content: space-between; align-items: center;">
                    <div style="font-weight: 600; font-size: 18px;">
                        Total: <span id="editorGrandTotal" style="color: #667eea;">$${estimate.totals.total}</span>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="estimatorIntegration.closeEstimateEditor()" style="padding: 12px 24px; background: white; border: 2px solid #ddd; border-radius: 8px; cursor: pointer; font-size: 14px;">
                            Close Preview
                        </button>
                        <button onclick="estimatorIntegration.saveEditedEstimate()" style="padding: 12px 24px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600;">
                            ‚úÖ Continue to Export
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        this.renderEstimateEditor(estimate);
    }
    
    renderEstimateEditor(estimate) {
        const container = document.getElementById('editorContent');
        if (!container) return;
        
        let html = `
            <div style="margin-bottom: 20px; padding: 15px; background: #f0f4ff; border-radius: 8px; border-left: 4px solid #667eea;">
                <h3 style="margin: 0 0 10px 0;">Project Information</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div>
                        <label style="font-size: 12px; font-weight: 600; color: #666;">Project Name:</label>
                        <input type="text" id="editProjectName" value="${estimate.metadata.projectName}" 
                               style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 4px;">
                    </div>
                    <div>
                        <label style="font-size: 12px; font-weight: 600; color: #666;">Date:</label>
                        <input type="text" id="editDate" value="${estimate.metadata.date}" 
                               style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 4px;">
                    </div>
                </div>
            </div>
        `;
        
        estimate.levels.forEach((level, levelIdx) => {
            html += `
                <div style="margin-bottom: 30px;">
                    <h3 style="background: #667eea; color: white; padding: 10px 15px; border-radius: 8px; margin-bottom: 15px;">
                        ${level.name}
                    </h3>
                    
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="background: #f5f5f5; border-bottom: 2px solid #ddd;">
                                <th style="padding: 10px; text-align: left; width: 40%;">Description</th>
                                <th style="padding: 10px; text-align: center; width: 12%;">Quantity</th>
                                <th style="padding: 10px; text-align: center; width: 8%;">Unit</th>
                                <th style="padding: 10px; text-align: right; width: 12%;">Unit Price</th>
                                <th style="padding: 10px; text-align: right; width: 12%;">Subtotal</th>
                                <th style="padding: 10px; text-align: right; width: 12%;">Total</th>
                                <th style="padding: 10px; width: 4%;"></th>
                            </tr>
                        </thead>
                        <tbody>`;
            
            level.lineItems.forEach((item, itemIdx) => {
                const itemId = `item-${levelIdx}-${itemIdx}`;
                const qty = parseFloat(item.quantity) || 0;
                const price = parseFloat(item.unitPrice) || 0;
                const subtotal = qty * price;
                const total = parseFloat(item.acv) || subtotal;
                
                html += `
                    <tr style="border-bottom: 1px solid #eee;" data-item-id="${itemId}">
                        <td style="padding: 10px;">
                            <input type="text" class="edit-desc" value="${item.description}" 
                                   style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                        </td>
                        <td style="padding: 10px; text-align: center;">
                            <input type="number" step="0.01" class="edit-qty" value="${qty.toFixed(2)}" 
                                   onchange="estimatorIntegration.recalculateRow('${itemId}')"
                                   style="width: 80px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                        </td>
                        <td style="padding: 10px; text-align: center;">
                            <input type="text" class="edit-unit" value="${item.unit}" 
                                   style="width: 60px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                        </td>
                        <td style="padding: 10px; text-align: right;">
                            <input type="number" step="0.01" class="edit-price" value="${price.toFixed(2)}" 
                                   onchange="estimatorIntegration.recalculateRow('${itemId}')"
                                   style="width: 100px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; text-align: right;">
                        </td>
                        <td style="padding: 10px; text-align: right;">
                            <span class="item-subtotal">$${subtotal.toFixed(2)}</span>
                        </td>
                        <td style="padding: 10px; text-align: right;">
                            <span class="item-total" style="font-weight: 600;">$${total.toFixed(2)}</span>
                        </td>
                        <td style="padding: 10px; text-align: center;">
                            <button onclick="estimatorIntegration.deleteRow('${itemId}')" 
                                    style="background: #f44336; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                ‚úï
                            </button>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                    <button onclick="estimatorIntegration.addLineItem(${levelIdx})" 
                            style="margin-top: 10px; padding: 8px 16px; background: #4caf50; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px;">
                        ‚ûï Add Line Item
                    </button>
                </div>
            `;
        });
        
        container.innerHTML = html;
    }
    
    recalculateRow(itemId) {
        const row = document.querySelector(`[data-item-id="${itemId}"]`);
        if (!row) return;
        
        const qty = parseFloat(row.querySelector('.edit-qty').value) || 0;
        const price = parseFloat(row.querySelector('.edit-price').value) || 0;
        const subtotal = qty * price;
        const tax = subtotal * 0.08;
        const op = subtotal * 0.20;
        const total = subtotal + tax + op;
        
        row.querySelector('.item-subtotal').textContent = '$' + subtotal.toFixed(2);
        row.querySelector('.item-total').textContent = '$' + total.toFixed(2);
        
        this.recalculateTotal();
    }
    
    recalculateTotal() {
        let grandTotal = 0;
        document.querySelectorAll('.item-total').forEach(el => {
            const value = parseFloat(el.textContent.replace('$', '')) || 0;
            grandTotal += value;
        });
        
        const totalEl = document.getElementById('editorGrandTotal');
        if (totalEl) {
            totalEl.textContent = '$' + grandTotal.toFixed(2);
        }
    }
    
    deleteRow(itemId) {
        if (!confirm('Delete this line item?')) return;
        
        const row = document.querySelector(`[data-item-id="${itemId}"]`);
        if (row) {
            row.remove();
            this.recalculateTotal();
        }
    }
    
    addLineItem(levelIdx) {
        // Create modal for item selection
        const modal = document.createElement('div');
        modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10005;';
        
        const dialog = document.createElement('div');
        dialog.style.cssText = 'background: white; border-radius: 12px; padding: 30px; width: 600px; max-height: 80vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3);';
        
        // Get all available items
        const allItems = this.availableItems || [];
        
        // Group items by category
        const categories = {};
        allItems.forEach(item => {
            if (!categories[item.category]) {
                categories[item.category] = [];
            }
            categories[item.category].push(item);
        });
        
        dialog.innerHTML = `
            <h2 style="margin: 0 0 20px 0; color: #333; font-size: 24px;">Add Line Item</h2>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">Select Item:</label>
                <select id="itemSelector" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 15px; background: white;">
                    <option value="">-- Select an item or enter custom --</option>
                    ${Object.keys(categories).map(cat => `
                        <optgroup label="${cat.toUpperCase()}">
                            ${categories[cat].map(item => `
                                <option value="${item.id}">${item.name}</option>
                            `).join('')}
                        </optgroup>
                    `).join('')}
                </select>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">Description:</label>
                <input type="text" id="itemDescription" placeholder="Item description" 
                       style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 15px;">
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                <div>
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">Quantity:</label>
                    <input type="number" step="0.01" id="itemQuantity" value="1" 
                           style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 15px; text-align: center;">
                </div>
                <div>
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">Unit:</label>
                    <select id="itemUnit" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 15px;">
                        <option value="SF">SF (Square Feet)</option>
                        <option value="LF">LF (Linear Feet)</option>
                        <option value="EA">EA (Each)</option>
                        <option value="LS">LS (Lump Sum)</option>
                        <option value="CY">CY (Cubic Yards)</option>
                        <option value="SY">SY (Square Yards)</option>
                        <option value="TON">TON (Tons)</option>
                        <option value="HR">HR (Hours)</option>
                    </select>
                </div>
                <div>
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">Unit Price:</label>
                    <input type="number" step="0.01" id="itemPrice" value="0" 
                           style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 15px; text-align: right;">
                </div>
            </div>
            
            <div style="display: flex; gap: 15px; justify-content: flex-end;">
                <button id="cancelBtn" style="padding: 12px 24px; background: #e0e0e0; color: #333; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 15px;">
                    Cancel
                </button>
                <button id="addBtn" style="padding: 12px 24px; background: #4caf50; color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 15px;">
                    ‚ûï Add Item
                </button>
            </div>
        `;
        
        modal.appendChild(dialog);
        document.body.appendChild(modal);
        
        // Get elements
        const selector = dialog.querySelector('#itemSelector');
        const descInput = dialog.querySelector('#itemDescription');
        const qtyInput = dialog.querySelector('#itemQuantity');
        const unitInput = dialog.querySelector('#itemUnit');
        const priceInput = dialog.querySelector('#itemPrice');
        const cancelBtn = dialog.querySelector('#cancelBtn');
        const addBtn = dialog.querySelector('#addBtn');
        
        // When item selected from dropdown, pre-fill fields
        selector.addEventListener('change', () => {
            const selectedId = selector.value;
            if (selectedId) {
                const item = allItems.find(i => i.id === selectedId);
                if (item) {
                    descInput.value = item.description || item.name;
                    qtyInput.value = item.quantity.toFixed(2);
                    unitInput.value = item.unit;
                    priceInput.value = item.unitPrice.toFixed(2);
                }
            }
        });
        
        // Cancel button
        cancelBtn.onclick = () => {
            document.body.removeChild(modal);
        };
        
        // Add button
        addBtn.onclick = () => {
            const desc = descInput.value.trim();
            if (!desc) {
                alert('Please enter a description');
                return;
            }
            
            const qty = parseFloat(qtyInput.value) || 1;
            const unit = unitInput.value || 'EA';
            const price = parseFloat(priceInput.value) || 0;
            
            // Find the table and add row
            const tables = document.querySelectorAll('table');
            if (tables[levelIdx]) {
                const tbody = tables[levelIdx].querySelector('tbody');
                const itemId = `item-${levelIdx}-${Date.now()}`;
                const subtotal = qty * price;
                const tax = subtotal * 0.08;
                const op = subtotal * 0.20;
                const total = subtotal + tax + op;
                
                const row = document.createElement('tr');
                row.setAttribute('data-item-id', itemId);
                row.style.borderBottom = '1px solid #eee';
                row.innerHTML = `
                    <td style="padding: 10px;">
                        <input type="text" class="edit-desc" value="${desc}" 
                               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                    </td>
                    <td style="padding: 10px; text-align: center;">
                        <input type="number" step="0.01" class="edit-qty" value="${qty.toFixed(2)}" 
                               onchange="estimatorIntegration.recalculateRow('${itemId}')"
                               style="width: 80px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                    </td>
                    <td style="padding: 10px; text-align: center;">
                        <input type="text" class="edit-unit" value="${unit}" 
                               style="width: 60px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                    </td>
                    <td style="padding: 10px; text-align: right;">
                        <input type="number" step="0.01" class="edit-price" value="${price.toFixed(2)}" 
                               onchange="estimatorIntegration.recalculateRow('${itemId}')"
                               style="width: 100px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; text-align: right;">
                    </td>
                    <td style="padding: 10px; text-align: right;">${subtotal.toFixed(2)}</td>
                    <td style="padding: 10px; text-align: right;">${tax.toFixed(2)}</td>
                    <td style="padding: 10px; text-align: right;">${op.toFixed(2)}</td>
                    <td style="padding: 10px; text-align: right; font-weight: bold;">${total.toFixed(2)}</td>
                    <td style="padding: 10px; text-align: center;">
                        <button onclick="estimatorIntegration.deleteRow('${itemId}')" 
                                style="background: #f44336; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-weight: bold;">
                            ‚úï
                        </button>
                    </td>
                `;
                
                tbody.appendChild(row);
                this.recalculateTotal();
            }
            
            // Close modal
            document.body.removeChild(modal);
        };
        
        // Close on background click
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        });
        
        // Focus description field
        descInput.focus();
    }
    
    closeEstimateEditor() {
        const modal = document.getElementById('estimateEditorModal');
        if (modal) modal.remove();
    }
    
    saveEditedEstimate() {
        // Collect edited data
        const projectName = document.getElementById('editProjectName')?.value || 'Estimate';
        const date = document.getElementById('editDate')?.value || new Date().toLocaleDateString();
        
        // Get tax and O&P rates from estimate metadata
        const taxRate = parseFloat(this.currentEstimate.metadata?.taxRate || 8.00) / 100;
        const opRate = parseFloat(this.currentEstimate.metadata?.opRate || 20.00) / 100;
        
        const levels = [];
        let totalSubtotal = 0;
        
        document.querySelectorAll('table').forEach((table, levelIdx) => {
            const levelName = this.currentEstimate.levels[levelIdx]?.name || `Level ${levelIdx + 1}`;
            const lineItems = [];
            
            table.querySelectorAll('tbody tr').forEach(row => {
                const desc = row.querySelector('.edit-desc')?.value || '';
                const qty = parseFloat(row.querySelector('.edit-qty')?.value) || 0;
                const unit = row.querySelector('.edit-unit')?.value || 'EA';
                const price = parseFloat(row.querySelector('.edit-price')?.value) || 0;
                
                const subtotal = qty * price;
                const tax = subtotal * taxRate;
                const op = subtotal * opRate;
                const rcv = subtotal + tax + op;
                
                totalSubtotal += subtotal;
                
                lineItems.push({
                    description: desc,
                    quantity: qty.toFixed(2),
                    unit: unit,
                    unitPrice: price.toFixed(2),
                    subtotal: subtotal.toFixed(2),
                    tax: tax.toFixed(2),
                    op: op.toFixed(2),
                    rcv: rcv.toFixed(2),
                    depreciation: '0.00',
                    acv: rcv.toFixed(2)
                });
            });
            
            levels.push({
                name: levelName,
                lineItems: lineItems,
                rooms: this.currentEstimate.levels[levelIdx]?.rooms || []
            });
        });
        
        // Calculate new totals
        let totalTax = 0, totalOp = 0, totalRcv = 0, totalAcv = 0;
        levels.forEach(level => {
            level.lineItems.forEach(item => {
                totalTax += parseFloat(item.tax);
                totalOp += parseFloat(item.op);
                totalRcv += parseFloat(item.rcv);
                totalAcv += parseFloat(item.acv);
            });
        });
        
        const updatedEstimate = {
            metadata: {
                projectName: projectName,
                date: date,
                address: this.currentEstimate.metadata.address || '',
                claimNumber: this.currentEstimate.metadata.claimNumber || '',
                insured: this.currentEstimate.metadata.insured || '',
                taxRate: this.currentEstimate.metadata.taxRate || '8.00',
                opRate: this.currentEstimate.metadata.opRate || '20.00'
            },
            levels: levels,
            totals: {
                subtotal: totalSubtotal.toFixed(2),
                tax: totalTax.toFixed(2),
                op: totalOp.toFixed(2),
                rcv: totalRcv.toFixed(2),
                total: totalRcv.toFixed(2),
                depreciation: '0.00',
                acv: totalAcv.toFixed(2)
            }
        };
        
        this.currentEstimate = updatedEstimate;
        this.closeEstimateEditor();
        this.showSuccess('Estimate updated! Opening export menu...');
        
        setTimeout(() => {
            this.showExportMenu();
        }, 500);
    }
    
    showError(msg) {
        this.showToast(msg, 'error');
    }
    
    showToast(msg, type = '') {
        const toast = document.createElement('div');
        toast.className = `estimator-toast ${type}`;
        toast.textContent = (type === 'error' ? '‚ùå ' : '‚úÖ ') + msg;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 3000);
    }
    
    // ================================================================
    // ITEM BUILDER METHODS
    // ================================================================
    
    openItemBuilder() {
        const modal = document.getElementById('itemBuilderModal');
        modal.style.display = 'flex';
        this.initializeItemBuilder();
    }
    
    closeItemBuilder() {
        const modal = document.getElementById('itemBuilderModal');
        modal.style.display = 'none';
    }
    
    updateTaxRate(rate) {
        this.taxRate = parseFloat(rate) / 100;
        this.estimator.setTaxRate(this.taxRate);
        document.getElementById('taxRateDisplay').textContent = parseFloat(rate).toFixed(2);
        console.log(`üí∞ Tax rate updated to ${rate}%`);
        this.calculateSelectedTotal();
    }
    
    updateOPRate(rate) {
        this.opRate = parseFloat(rate) / 100;
        this.estimator.setOverheadProfit(this.opRate);
        document.getElementById('opRateDisplay').textContent = parseFloat(rate).toFixed(2);
        console.log(`üí∞ O&P rate updated to ${rate}%`);
        this.calculateSelectedTotal();
    }
    
    updateDepreciation(rate) {
        this.depreciationRate = parseFloat(rate) / 100;
        console.log(`üìâ Depreciation rate updated to ${rate}%`);
        this.calculateSelectedTotal();
    }
    
    updateDeductible(amount) {
        this.deductible = parseFloat(amount) || 0;
        console.log(`üíµ Deductible updated to $${amount}`);
        this.calculateSelectedTotal();
    }
    
    initializeItemBuilder() {
        // Initialize with property data
        // Don't reset selectedItems if they already exist (preserve work when toggling views)
        if (!this.selectedItems) {
            this.selectedItems = [];
        }
        this.availableItems = this.generateAvailableItems();
        this.currentCategory = 'all';
        this.renderAvailableItems();
        this.updateSelectedItemsDisplay();
    }
    
    generateAvailableItems() {
        const propertyData = this.convertPropertyData();
        const items = [];
        let itemId = 0;
        
        propertyData.levels.forEach(level => {
            level.rooms.forEach(room => {
                const quantities = this.estimator.calculateRoomQuantities(room);
                const wallArea = quantities.areas.wallsAndCeiling;
                const wallsOnly = quantities.areas.wallsNet;
                const ceilingOnly = quantities.areas.ceiling;
                const floorArea = quantities.areas.floor;
                const perimeter = quantities.perimeters.floor;
                const height = room.height || 8;
                
                // ==================================================================
                // DRYWALL CATEGORY
                // ==================================================================
                
                // 1/2" Drywall options
                items.push({
                    id: `drywall-half-${itemId++}`,
                    category: 'drywall',
                    name: `${room.name} - 1/2" Drywall (Walls & Ceiling)`,
                    description: `${room.name} - Install 1/2" standard drywall`,
                    quantity: wallArea,
                    unit: 'SF',
                    unitPrice: 2.27,
                    room: room.name
                });
                
                items.push({
                    id: `drywall-half-walls-${itemId++}`,
                    category: 'drywall',
                    name: `${room.name} - 1/2" Drywall (Walls Only)`,
                    description: `${room.name} - Install 1/2" drywall on walls only`,
                    quantity: wallsOnly,
                    unit: 'SF',
                    unitPrice: 2.27,
                    room: room.name
                });
                
                // 5/8" Drywall options
                items.push({
                    id: `drywall-fiveeighth-${itemId++}`,
                    category: 'drywall',
                    name: `${room.name} - 5/8" Drywall (Walls & Ceiling)`,
                    description: `${room.name} - Install 5/8" fire-rated drywall`,
                    quantity: wallArea,
                    unit: 'SF',
                    unitPrice: 2.65,
                    room: room.name
                });
                
                items.push({
                    id: `drywall-ceiling-${itemId++}`,
                    category: 'drywall',
                    name: `${room.name} - 5/8" Drywall (Ceiling Only)`,
                    description: `${room.name} - Install 5/8" drywall on ceiling`,
                    quantity: ceilingOnly,
                    unit: 'SF',
                    unitPrice: 2.65,
                    room: room.name
                });
                
                // Water-resistant drywall
                items.push({
                    id: `drywall-wr-${itemId++}`,
                    category: 'drywall',
                    name: `${room.name} - Water-Resistant Drywall`,
                    description: `${room.name} - Install moisture-resistant drywall (greenboard)`,
                    quantity: wallArea,
                    unit: 'SF',
                    unitPrice: 2.85,
                    room: room.name
                });
                
                // Tape & Finish
                items.push({
                    id: `tape-${itemId++}`,
                    category: 'drywall',
                    name: `${room.name} - Tape & Finish`,
                    description: `${room.name} - Tape, mud, and finish drywall`,
                    quantity: wallArea,
                    unit: 'SF',
                    unitPrice: 0.75,
                    room: room.name
                });
                
                items.push({
                    id: `texture-${itemId++}`,
                    category: 'drywall',
                    name: `${room.name} - Texture (Knockdown/Orange Peel)`,
                    description: `${room.name} - Apply ceiling texture`,
                    quantity: ceilingOnly,
                    unit: 'SF',
                    unitPrice: 0.45,
                    room: room.name
                });
                
                // Flood Cut Drywall - 2 feet up
                const floodCut2ft = perimeter * 2;
                items.push({
                    id: `drywall-flood-2ft-${itemId++}`,
                    category: 'drywall',
                    name: `${room.name} - Flood Cut Drywall 2' High`,
                    description: `${room.name} - Remove and replace drywall 2 feet up from floor (water damage)`,
                    quantity: floodCut2ft,
                    unit: 'SF',
                    unitPrice: 2.85,
                    room: room.name
                });
                
                // Flood Cut Drywall - 4 feet up
                const floodCut4ft = perimeter * 4;
                items.push({
                    id: `drywall-flood-4ft-${itemId++}`,
                    category: 'drywall',
                    name: `${room.name} - Flood Cut Drywall 4' High`,
                    description: `${room.name} - Remove and replace drywall 4 feet up from floor (water damage)`,
                    quantity: floodCut4ft,
                    unit: 'SF',
                    unitPrice: 2.85,
                    room: room.name
                });
                
                // Tape & Finish for Flood Cuts
                items.push({
                    id: `tape-flood-2ft-${itemId++}`,
                    category: 'drywall',
                    name: `${room.name} - Tape & Finish (Flood Cut 2')`,
                    description: `${room.name} - Tape, mud, and finish flood cut area`,
                    quantity: floodCut2ft,
                    unit: 'SF',
                    unitPrice: 0.75,
                    room: room.name
                });
                
                items.push({
                    id: `tape-flood-4ft-${itemId++}`,
                    category: 'drywall',
                    name: `${room.name} - Tape & Finish (Flood Cut 4')`,
                    description: `${room.name} - Tape, mud, and finish flood cut area`,
                    quantity: floodCut4ft,
                    unit: 'SF',
                    unitPrice: 0.75,
                    room: room.name
                });
                
                // ==================================================================
                // FRAMING CATEGORY
                // ==================================================================
                
                // Calculate linear feet of studs (16" OC)
                const studSpacing = 16 / 12; // 1.33 feet
                const wallLength = perimeter;
                const studsNeeded = Math.ceil(wallLength / studSpacing);
                const studLF = studsNeeded * height;
                
                items.push({
                    id: `stud-2x4-${itemId++}`,
                    category: 'framing',
                    name: `${room.name} - 2x4 Studs (16" OC)`,
                    description: `${room.name} - 2x4 wall studs at 16" on center`,
                    quantity: studLF,
                    unit: 'LF',
                    unitPrice: 0.75,
                    room: room.name
                });
                
                items.push({
                    id: `stud-2x6-${itemId++}`,
                    category: 'framing',
                    name: `${room.name} - 2x6 Studs (16" OC)`,
                    description: `${room.name} - 2x6 wall studs at 16" on center`,
                    quantity: studLF,
                    unit: 'LF',
                    unitPrice: 1.25,
                    room: room.name
                });
                
                items.push({
                    id: `plates-2x4-${itemId++}`,
                    category: 'framing',
                    name: `${room.name} - 2x4 Plates (Top/Bottom)`,
                    description: `${room.name} - 2x4 top and bottom plates`,
                    quantity: perimeter * 2, // Double for top and bottom
                    unit: 'LF',
                    unitPrice: 0.75,
                    room: room.name
                });
                
                items.push({
                    id: `headers-2x6-${itemId++}`,
                    category: 'framing',
                    name: `${room.name} - 2x6 Headers`,
                    description: `${room.name} - Door/window headers`,
                    quantity: ((room.doors?.length || 0) + (room.windows?.length || 0)) * 4,
                    unit: 'LF',
                    unitPrice: 1.25,
                    room: room.name
                });
                
                // ==================================================================
                // INSULATION CATEGORY
                // ==================================================================
                
                items.push({
                    id: `insul-r13-${itemId++}`,
                    category: 'insulation',
                    name: `${room.name} - R-13 Insulation (2x4 walls)`,
                    description: `${room.name} - Fiberglass batt insulation R-13`,
                    quantity: wallsOnly,
                    unit: 'SF',
                    unitPrice: 0.65,
                    room: room.name
                });
                
                items.push({
                    id: `insul-r19-${itemId++}`,
                    category: 'insulation',
                    name: `${room.name} - R-19 Insulation (2x6 walls)`,
                    description: `${room.name} - Fiberglass batt insulation R-19`,
                    quantity: wallsOnly,
                    unit: 'SF',
                    unitPrice: 0.85,
                    room: room.name
                });
                
                items.push({
                    id: `insul-r30-${itemId++}`,
                    category: 'insulation',
                    name: `${room.name} - R-30 Insulation (Ceiling)`,
                    description: `${room.name} - Blown-in ceiling insulation R-30`,
                    quantity: ceilingOnly,
                    unit: 'SF',
                    unitPrice: 1.15,
                    room: room.name
                });
                
                items.push({
                    id: `vapor-barrier-${itemId++}`,
                    category: 'insulation',
                    name: `${room.name} - Vapor Barrier`,
                    description: `${room.name} - 6-mil poly vapor barrier`,
                    quantity: wallArea,
                    unit: 'SF',
                    unitPrice: 0.15,
                    room: room.name
                });
                
                // ==================================================================
                // PAINT CATEGORY
                // ==================================================================
                
                items.push({
                    id: `paint-walls-${itemId++}`,
                    category: 'paint',
                    name: `${room.name} - Paint Walls (2 coats)`,
                    description: `${room.name} - Prime and paint walls`,
                    quantity: wallsOnly,
                    unit: 'SF',
                    unitPrice: 1.50,
                    room: room.name
                });
                
                items.push({
                    id: `paint-ceiling-${itemId++}`,
                    category: 'paint',
                    name: `${room.name} - Paint Ceiling (2 coats)`,
                    description: `${room.name} - Prime and paint ceiling`,
                    quantity: ceilingOnly,
                    unit: 'SF',
                    unitPrice: 1.35,
                    room: room.name
                });
                
                items.push({
                    id: `paint-primer-${itemId++}`,
                    category: 'paint',
                    name: `${room.name} - Primer Only`,
                    description: `${room.name} - Prime all surfaces`,
                    quantity: wallArea,
                    unit: 'SF',
                    unitPrice: 0.55,
                    room: room.name
                });
                
                items.push({
                    id: `paint-semigloss-${itemId++}`,
                    category: 'paint',
                    name: `${room.name} - Semi-Gloss Trim Paint`,
                    description: `${room.name} - Paint trim and doors in semi-gloss`,
                    quantity: perimeter * 1.5,
                    unit: 'LF',
                    unitPrice: 1.25,
                    room: room.name
                });
                
                // ==================================================================
                // FLOORING CATEGORY
                // ==================================================================
                
                items.push({
                    id: `carpet-${itemId++}`,
                    category: 'flooring',
                    name: `${room.name} - Carpet (Standard)`,
                    description: `${room.name} - Install carpet with 6lb pad`,
                    quantity: floorArea,
                    unit: 'SF',
                    unitPrice: 3.50,
                    room: room.name
                });
                
                items.push({
                    id: `carpet-premium-${itemId++}`,
                    category: 'flooring',
                    name: `${room.name} - Carpet (Premium)`,
                    description: `${room.name} - Install premium carpet with 8lb pad`,
                    quantity: floorArea,
                    unit: 'SF',
                    unitPrice: 5.25,
                    room: room.name
                });
                
                items.push({
                    id: `vinyl-${itemId++}`,
                    category: 'flooring',
                    name: `${room.name} - Luxury Vinyl Plank`,
                    description: `${room.name} - Install LVP flooring`,
                    quantity: floorArea,
                    unit: 'SF',
                    unitPrice: 4.25,
                    room: room.name
                });
                
                items.push({
                    id: `hardwood-${itemId++}`,
                    category: 'flooring',
                    name: `${room.name} - Hardwood Flooring`,
                    description: `${room.name} - Install 3/4" hardwood flooring`,
                    quantity: floorArea,
                    unit: 'SF',
                    unitPrice: 8.50,
                    room: room.name
                });
                
                items.push({
                    id: `tile-${itemId++}`,
                    category: 'flooring',
                    name: `${room.name} - Ceramic Tile`,
                    description: `${room.name} - Install ceramic floor tile`,
                    quantity: floorArea,
                    unit: 'SF',
                    unitPrice: 6.75,
                    room: room.name
                });
                
                items.push({
                    id: `laminate-${itemId++}`,
                    category: 'flooring',
                    name: `${room.name} - Laminate Flooring`,
                    description: `${room.name} - Install laminate plank flooring`,
                    quantity: floorArea,
                    unit: 'SF',
                    unitPrice: 3.25,
                    room: room.name
                });
                
                items.push({
                    id: `underlayment-${itemId++}`,
                    category: 'flooring',
                    name: `${room.name} - Floor Underlayment`,
                    description: `${room.name} - Install 1/4" underlayment`,
                    quantity: floorArea,
                    unit: 'SF',
                    unitPrice: 0.75,
                    room: room.name
                });
                
                // Baseboard options
                items.push({
                    id: `baseboard-std-${itemId++}`,
                    category: 'flooring',
                    name: `${room.name} - Baseboard (Standard 3 1/4")`,
                    description: `${room.name} - Install standard baseboard`,
                    quantity: perimeter,
                    unit: 'LF',
                    unitPrice: 2.75,
                    room: room.name
                });
                
                items.push({
                    id: `baseboard-tall-${itemId++}`,
                    category: 'flooring',
                    name: `${room.name} - Baseboard (Tall 5 1/4")`,
                    description: `${room.name} - Install tall baseboard`,
                    quantity: perimeter,
                    unit: 'LF',
                    unitPrice: 3.50,
                    room: room.name
                });
                
                items.push({
                    id: `shoe-molding-${itemId++}`,
                    category: 'flooring',
                    name: `${room.name} - Shoe Molding`,
                    description: `${room.name} - Install quarter-round shoe molding`,
                    quantity: perimeter,
                    unit: 'LF',
                    unitPrice: 1.25,
                    room: room.name
                });
                
                // ==================================================================
                // DOORS/WINDOWS CATEGORY
                // ==================================================================
                
                // Doors
                if (room.doors && room.doors.length > 0) {
                    room.doors.forEach((door, idx) => {
                        items.push({
                            id: `door-standard-${itemId++}`,
                            category: 'doors',
                            name: `${room.name} - Interior Door ${idx + 1} (Standard)`,
                            description: `${room.name} - Hollow-core pre-hung door`,
                            quantity: 1,
                            unit: 'EA',
                            unitPrice: 350.00,
                            room: room.name
                        });
                        
                        items.push({
                            id: `door-solid-${itemId++}`,
                            category: 'doors',
                            name: `${room.name} - Interior Door ${idx + 1} (Solid Core)`,
                            description: `${room.name} - Solid-core pre-hung door`,
                            quantity: 1,
                            unit: 'EA',
                            unitPrice: 475.00,
                            room: room.name
                        });
                        
                        items.push({
                            id: `door-trim-${itemId++}`,
                            category: 'doors',
                            name: `${room.name} - Door Trim ${idx + 1}`,
                            description: `${room.name} - Door casing and trim`,
                            quantity: 1,
                            unit: 'EA',
                            unitPrice: 85.00,
                            room: room.name
                        });
                    });
                }
                
                // Windows
                if (room.windows && room.windows.length > 0) {
                    room.windows.forEach((window, idx) => {
                        items.push({
                            id: `window-vinyl-${itemId++}`,
                            category: 'doors',
                            name: `${room.name} - Window ${idx + 1} (Vinyl)`,
                            description: `${room.name} - Replace with vinyl window`,
                            quantity: 1,
                            unit: 'EA',
                            unitPrice: 450.00,
                            room: room.name
                        });
                        
                        items.push({
                            id: `window-wood-${itemId++}`,
                            category: 'doors',
                            name: `${room.name} - Window ${idx + 1} (Wood)`,
                            description: `${room.name} - Replace with wood window`,
                            quantity: 1,
                            unit: 'EA',
                            unitPrice: 625.00,
                            room: room.name
                        });
                        
                        items.push({
                            id: `window-trim-${itemId++}`,
                            category: 'doors',
                            name: `${room.name} - Window Trim ${idx + 1}`,
                            description: `${room.name} - Window casing and sill`,
                            quantity: 1,
                            unit: 'EA',
                            unitPrice: 95.00,
                            room: room.name
                        });
                    });
                }
                
                // ==================================================================
                // ELECTRICAL CATEGORY
                // ==================================================================
                
                items.push({
                    id: `outlets-${itemId++}`,
                    category: 'electrical',
                    name: `${room.name} - Electrical Outlets`,
                    description: `${room.name} - Install/replace outlets (4 per room avg)`,
                    quantity: 4,
                    unit: 'EA',
                    unitPrice: 35.00,
                    room: room.name
                });
                
                items.push({
                    id: `switches-${itemId++}`,
                    category: 'electrical',
                    name: `${room.name} - Light Switches`,
                    description: `${room.name} - Install/replace switches`,
                    quantity: 2,
                    unit: 'EA',
                    unitPrice: 32.00,
                    room: room.name
                });
                
                items.push({
                    id: `lighting-ceiling-${itemId++}`,
                    category: 'electrical',
                    name: `${room.name} - Ceiling Light Fixture`,
                    description: `${room.name} - Install ceiling light fixture`,
                    quantity: 1,
                    unit: 'EA',
                    unitPrice: 125.00,
                    room: room.name
                });
                
                items.push({
                    id: `lighting-recessed-${itemId++}`,
                    category: 'electrical',
                    name: `${room.name} - Recessed Lights (6 per room)`,
                    description: `${room.name} - Install LED recessed can lights`,
                    quantity: 6,
                    unit: 'EA',
                    unitPrice: 85.00,
                    room: room.name
                });
                
                items.push({
                    id: `ceiling-fan-${itemId++}`,
                    category: 'electrical',
                    name: `${room.name} - Ceiling Fan`,
                    description: `${room.name} - Install ceiling fan with light`,
                    quantity: 1,
                    unit: 'EA',
                    unitPrice: 275.00,
                    room: room.name
                });
                
                items.push({
                    id: `wiring-${itemId++}`,
                    category: 'electrical',
                    name: `${room.name} - Romex Wiring (12/2)`,
                    description: `${room.name} - 12/2 Romex electrical wiring`,
                    quantity: perimeter * 2,
                    unit: 'LF',
                    unitPrice: 0.85,
                    room: room.name
                });
                
                // ==================================================================
                // PLUMBING CATEGORY
                // ==================================================================
                
                items.push({
                    id: `plumbing-fixture-${itemId++}`,
                    category: 'plumbing',
                    name: `${room.name} - Plumbing Fixture`,
                    description: `${room.name} - Install plumbing fixture (toilet/sink)`,
                    quantity: 1,
                    unit: 'EA',
                    unitPrice: 425.00,
                    room: room.name
                });
                
                items.push({
                    id: `water-line-${itemId++}`,
                    category: 'plumbing',
                    name: `${room.name} - PEX Water Line`,
                    description: `${room.name} - 1/2" PEX water supply line`,
                    quantity: 25,
                    unit: 'LF',
                    unitPrice: 1.50,
                    room: room.name
                });
                
                items.push({
                    id: `drain-line-${itemId++}`,
                    category: 'plumbing',
                    name: `${room.name} - PVC Drain Line`,
                    description: `${room.name} - 2" PVC drain line`,
                    quantity: 15,
                    unit: 'LF',
                    unitPrice: 2.25,
                    room: room.name
                });
                
                items.push({
                    id: `shutoff-valve-${itemId++}`,
                    category: 'plumbing',
                    name: `${room.name} - Shut-off Valves`,
                    description: `${room.name} - Install angle stop valves`,
                    quantity: 2,
                    unit: 'EA',
                    unitPrice: 35.00,
                    room: room.name
                });
            });
        });
        
        // ==================================================================
        // GENERAL/OTHER ITEMS
        // ==================================================================
        
        items.push({
            id: `debris-${itemId++}`,
            category: 'other',
            name: 'Debris Removal',
            description: 'Haul away construction debris',
            quantity: 1,
            unit: 'LS',
            unitPrice: 500.00,
            room: 'General'
        });
        
        items.push({
            id: `temp-${itemId++}`,
            category: 'other',
            name: 'Temporary Protection',
            description: 'Floor protection and dust barriers',
            quantity: 1,
            unit: 'LS',
            unitPrice: 250.00,
            room: 'General'
        });
        
        items.push({
            id: `dumpster-${itemId++}`,
            category: 'other',
            name: 'Dumpster Rental (30-yard)',
            description: '30-yard dumpster for 7 days',
            quantity: 1,
            unit: 'EA',
            unitPrice: 450.00,
            room: 'General'
        });
        
        items.push({
            id: `permit-${itemId++}`,
            category: 'other',
            name: 'Building Permit',
            description: 'Building department permit fees',
            quantity: 1,
            unit: 'LS',
            unitPrice: 350.00,
            room: 'General'
        });
        
        items.push({
            id: `cleanup-${itemId++}`,
            category: 'other',
            name: 'Final Cleanup',
            description: 'Construction clean and detail',
            quantity: 1,
            unit: 'LS',
            unitPrice: 300.00,
            room: 'General'
        });
        
        // ==================================================================
        // GENERIC ITEMS (Not room-specific)
        // ==================================================================
        
        // ------------------------------------------------------------------
        // ROOFING CATEGORY
        // ------------------------------------------------------------------
        items.push({
            id: `roof-shingle-3tab-${itemId++}`,
            category: 'roofing',
            name: '3-Tab Asphalt Shingles',
            description: 'Standard 3-tab asphalt shingles, 20-year warranty',
            quantity: 100,
            unit: 'SQ',
            unitPrice: 95.00,
            room: 'Roof'
        });
        
        items.push({
            id: `roof-shingle-architectural-${itemId++}`,
            category: 'roofing',
            name: 'Architectural Shingles',
            description: 'Dimensional architectural shingles, 30-year warranty',
            quantity: 100,
            unit: 'SQ',
            unitPrice: 120.00,
            room: 'Roof'
        });
        
        items.push({
            id: `roof-underlayment-${itemId++}`,
            category: 'roofing',
            name: 'Roofing Underlayment (Felt)',
            description: '#30 felt underlayment',
            quantity: 100,
            unit: 'SQ',
            unitPrice: 15.00,
            room: 'Roof'
        });
        
        items.push({
            id: `roof-ice-shield-${itemId++}`,
            category: 'roofing',
            name: 'Ice & Water Shield',
            description: 'Self-adhering waterproof membrane',
            quantity: 10,
            unit: 'SQ',
            unitPrice: 85.00,
            room: 'Roof'
        });
        
        items.push({
            id: `roof-drip-edge-${itemId++}`,
            category: 'roofing',
            name: 'Drip Edge',
            description: 'Aluminum drip edge flashing',
            quantity: 50,
            unit: 'LF',
            unitPrice: 3.50,
            room: 'Roof'
        });
        
        items.push({
            id: `roof-valley-${itemId++}`,
            category: 'roofing',
            name: 'Valley Flashing',
            description: 'Pre-formed valley flashing',
            quantity: 20,
            unit: 'LF',
            unitPrice: 8.50,
            room: 'Roof'
        });
        
        items.push({
            id: `roof-ridge-vent-${itemId++}`,
            category: 'roofing',
            name: 'Ridge Vent',
            description: 'Continuous ridge vent system',
            quantity: 30,
            unit: 'LF',
            unitPrice: 6.00,
            room: 'Roof'
        });
        
        items.push({
            id: `roof-pipe-boot-${itemId++}`,
            category: 'roofing',
            name: 'Pipe Boot Flashing',
            description: 'Rubber pipe boot flashing',
            quantity: 4,
            unit: 'EA',
            unitPrice: 18.00,
            room: 'Roof'
        });
        
        items.push({
            id: `gutter-aluminum-${itemId++}`,
            category: 'roofing',
            name: '5" Aluminum Gutters',
            description: 'Seamless aluminum gutters with hangers',
            quantity: 50,
            unit: 'LF',
            unitPrice: 8.50,
            room: 'Exterior'
        });
        
        items.push({
            id: `downspout-${itemId++}`,
            category: 'roofing',
            name: 'Downspouts',
            description: '3"x4" aluminum downspouts',
            quantity: 20,
            unit: 'LF',
            unitPrice: 7.00,
            room: 'Exterior'
        });
        
        // ------------------------------------------------------------------
        // HVAC CATEGORY
        // ------------------------------------------------------------------
        items.push({
            id: `hvac-ac-2ton-${itemId++}`,
            category: 'hvac',
            name: 'AC Unit 2-Ton',
            description: '2-ton air conditioning unit, 14 SEER',
            quantity: 1,
            unit: 'EA',
            unitPrice: 2800.00,
            room: 'HVAC'
        });
        
        items.push({
            id: `hvac-ac-3ton-${itemId++}`,
            category: 'hvac',
            name: 'AC Unit 3-Ton',
            description: '3-ton air conditioning unit, 14 SEER',
            quantity: 1,
            unit: 'EA',
            unitPrice: 3500.00,
            room: 'HVAC'
        });
        
        items.push({
            id: `hvac-furnace-80k-${itemId++}`,
            category: 'hvac',
            name: 'Gas Furnace 80K BTU',
            description: '80,000 BTU gas furnace, 90% efficiency',
            quantity: 1,
            unit: 'EA',
            unitPrice: 2200.00,
            room: 'HVAC'
        });
        
        items.push({
            id: `hvac-furnace-100k-${itemId++}`,
            category: 'hvac',
            name: 'Gas Furnace 100K BTU',
            description: '100,000 BTU gas furnace, 95% efficiency',
            quantity: 1,
            unit: 'EA',
            unitPrice: 2800.00,
            room: 'HVAC'
        });
        
        items.push({
            id: `hvac-duct-flex-${itemId++}`,
            category: 'hvac',
            name: 'Flexible Ductwork',
            description: 'Insulated flexible duct, 6" diameter',
            quantity: 50,
            unit: 'LF',
            unitPrice: 5.50,
            room: 'HVAC'
        });
        
        items.push({
            id: `hvac-duct-rigid-${itemId++}`,
            category: 'hvac',
            name: 'Rigid Metal Ductwork',
            description: 'Galvanized sheet metal duct',
            quantity: 20,
            unit: 'LF',
            unitPrice: 12.00,
            room: 'HVAC'
        });
        
        items.push({
            id: `hvac-register-${itemId++}`,
            category: 'hvac',
            name: 'Floor/Wall Register',
            description: 'Metal register with damper',
            quantity: 8,
            unit: 'EA',
            unitPrice: 18.00,
            room: 'HVAC'
        });
        
        items.push({
            id: `hvac-return-grill-${itemId++}`,
            category: 'hvac',
            name: 'Return Air Grill',
            description: 'Return air grill with filter',
            quantity: 2,
            unit: 'EA',
            unitPrice: 35.00,
            room: 'HVAC'
        });
        
        items.push({
            id: `hvac-thermostat-${itemId++}`,
            category: 'hvac',
            name: 'Programmable Thermostat',
            description: 'Digital programmable thermostat',
            quantity: 1,
            unit: 'EA',
            unitPrice: 150.00,
            room: 'HVAC'
        });
        
        // ------------------------------------------------------------------
        // EXTERIOR CATEGORY
        // ------------------------------------------------------------------
        items.push({
            id: `siding-vinyl-${itemId++}`,
            category: 'exterior',
            name: 'Vinyl Siding',
            description: 'Standard vinyl siding with accessories',
            quantity: 100,
            unit: 'SQ',
            unitPrice: 450.00,
            room: 'Exterior'
        });
        
        items.push({
            id: `siding-hardie-${itemId++}`,
            category: 'exterior',
            name: 'Hardie Plank Siding',
            description: 'James Hardie fiber cement siding',
            quantity: 100,
            unit: 'SQ',
            unitPrice: 850.00,
            room: 'Exterior'
        });
        
        items.push({
            id: `trim-pvc-${itemId++}`,
            category: 'exterior',
            name: 'PVC Trim Board',
            description: 'Cellular PVC trim, 1x6',
            quantity: 50,
            unit: 'LF',
            unitPrice: 4.50,
            room: 'Exterior'
        });
        
        items.push({
            id: `soffit-vinyl-${itemId++}`,
            category: 'exterior',
            name: 'Vinyl Soffit',
            description: 'Vented vinyl soffit panels',
            quantity: 50,
            unit: 'LF',
            unitPrice: 5.00,
            room: 'Exterior'
        });
        
        items.push({
            id: `fascia-aluminum-${itemId++}`,
            category: 'exterior',
            name: 'Aluminum Fascia',
            description: 'Wrapped aluminum fascia, 1x8',
            quantity: 50,
            unit: 'LF',
            unitPrice: 6.50,
            room: 'Exterior'
        });
        
        items.push({
            id: `paint-exterior-${itemId++}`,
            category: 'exterior',
            name: 'Exterior Paint',
            description: 'Exterior house paint, quality grade',
            quantity: 200,
            unit: 'SF',
            unitPrice: 2.50,
            room: 'Exterior'
        });
        
        // ------------------------------------------------------------------
        // CABINETS & COUNTERTOPS CATEGORY
        // ------------------------------------------------------------------
        items.push({
            id: `cabinet-base-${itemId++}`,
            category: 'cabinets',
            name: 'Base Cabinet',
            description: 'Standard base cabinet, 24" deep',
            quantity: 10,
            unit: 'LF',
            unitPrice: 250.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `cabinet-wall-${itemId++}`,
            category: 'cabinets',
            name: 'Wall Cabinet',
            description: 'Standard wall cabinet, 12" deep',
            quantity: 10,
            unit: 'LF',
            unitPrice: 180.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `cabinet-pantry-${itemId++}`,
            category: 'cabinets',
            name: 'Pantry Cabinet',
            description: 'Full-height pantry cabinet',
            quantity: 1,
            unit: 'EA',
            unitPrice: 800.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `cabinet-vanity-24-${itemId++}`,
            category: 'cabinets',
            name: 'Vanity Cabinet 24"',
            description: '24" bathroom vanity cabinet',
            quantity: 1,
            unit: 'EA',
            unitPrice: 350.00,
            room: 'Bathroom'
        });
        
        items.push({
            id: `cabinet-vanity-36-${itemId++}`,
            category: 'cabinets',
            name: 'Vanity Cabinet 36"',
            description: '36" bathroom vanity cabinet',
            quantity: 1,
            unit: 'EA',
            unitPrice: 450.00,
            room: 'Bathroom'
        });
        
        items.push({
            id: `countertop-laminate-${itemId++}`,
            category: 'cabinets',
            name: 'Laminate Countertop',
            description: 'Post-form laminate countertop',
            quantity: 10,
            unit: 'LF',
            unitPrice: 35.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `countertop-granite-${itemId++}`,
            category: 'cabinets',
            name: 'Granite Countertop',
            description: 'Mid-grade granite countertop installed',
            quantity: 25,
            unit: 'SF',
            unitPrice: 65.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `countertop-quartz-${itemId++}`,
            category: 'cabinets',
            name: 'Quartz Countertop',
            description: 'Engineered quartz countertop',
            quantity: 25,
            unit: 'SF',
            unitPrice: 75.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `backsplash-tile-${itemId++}`,
            category: 'cabinets',
            name: 'Tile Backsplash',
            description: 'Ceramic tile backsplash installed',
            quantity: 20,
            unit: 'SF',
            unitPrice: 18.00,
            room: 'Kitchen'
        });
        
        // ------------------------------------------------------------------
        // APPLIANCES CATEGORY
        // ------------------------------------------------------------------
        items.push({
            id: `appliance-range-${itemId++}`,
            category: 'appliances',
            name: 'Electric Range',
            description: 'Standard electric range/oven',
            quantity: 1,
            unit: 'EA',
            unitPrice: 650.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `appliance-cooktop-${itemId++}`,
            category: 'appliances',
            name: 'Cooktop',
            description: 'Electric or gas cooktop',
            quantity: 1,
            unit: 'EA',
            unitPrice: 550.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `appliance-oven-${itemId++}`,
            category: 'appliances',
            name: 'Wall Oven',
            description: 'Built-in wall oven',
            quantity: 1,
            unit: 'EA',
            unitPrice: 850.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `appliance-microwave-${itemId++}`,
            category: 'appliances',
            name: 'Microwave Over-Range',
            description: 'Over-the-range microwave with vent',
            quantity: 1,
            unit: 'EA',
            unitPrice: 280.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `appliance-dishwasher-${itemId++}`,
            category: 'appliances',
            name: 'Dishwasher',
            description: 'Built-in dishwasher',
            quantity: 1,
            unit: 'EA',
            unitPrice: 450.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `appliance-fridge-${itemId++}`,
            category: 'appliances',
            name: 'Refrigerator',
            description: 'Standard refrigerator',
            quantity: 1,
            unit: 'EA',
            unitPrice: 950.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `appliance-disposal-${itemId++}`,
            category: 'appliances',
            name: 'Garbage Disposal',
            description: '1/2 HP garbage disposal',
            quantity: 1,
            unit: 'EA',
            unitPrice: 180.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `appliance-hood-${itemId++}`,
            category: 'appliances',
            name: 'Range Hood',
            description: 'Ventilation range hood',
            quantity: 1,
            unit: 'EA',
            unitPrice: 320.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `appliance-washer-${itemId++}`,
            category: 'appliances',
            name: 'Washing Machine',
            description: 'Front-load washing machine',
            quantity: 1,
            unit: 'EA',
            unitPrice: 700.00,
            room: 'Laundry'
        });
        
        items.push({
            id: `appliance-dryer-${itemId++}`,
            category: 'appliances',
            name: 'Dryer',
            description: 'Electric or gas dryer',
            quantity: 1,
            unit: 'EA',
            unitPrice: 650.00,
            room: 'Laundry'
        });
        
        items.push({
            id: `appliance-waterheater-40-${itemId++}`,
            category: 'appliances',
            name: 'Water Heater 40-Gal',
            description: 'Electric water heater, 40 gallon',
            quantity: 1,
            unit: 'EA',
            unitPrice: 550.00,
            room: 'Utility'
        });
        
        items.push({
            id: `appliance-waterheater-50-${itemId++}`,
            category: 'appliances',
            name: 'Water Heater 50-Gal',
            description: 'Electric water heater, 50 gallon',
            quantity: 1,
            unit: 'EA',
            unitPrice: 650.00,
            room: 'Utility'
        });
        
        // ------------------------------------------------------------------
        // CONCRETE & MASONRY CATEGORY
        // ------------------------------------------------------------------
        items.push({
            id: `concrete-slab-${itemId++}`,
            category: 'concrete',
            name: 'Concrete Slab 4"',
            description: '4" concrete slab with gravel base',
            quantity: 100,
            unit: 'SF',
            unitPrice: 8.50,
            room: 'Foundation'
        });
        
        items.push({
            id: `concrete-driveway-${itemId++}`,
            category: 'concrete',
            name: 'Concrete Driveway',
            description: '4" concrete driveway with rebar',
            quantity: 200,
            unit: 'SF',
            unitPrice: 9.50,
            room: 'Exterior'
        });
        
        items.push({
            id: `concrete-sidewalk-${itemId++}`,
            category: 'concrete',
            name: 'Concrete Sidewalk',
            description: '4" concrete walkway',
            quantity: 50,
            unit: 'SF',
            unitPrice: 8.00,
            room: 'Exterior'
        });
        
        items.push({
            id: `concrete-patio-${itemId++}`,
            category: 'concrete',
            name: 'Concrete Patio',
            description: '4" stamped/colored concrete patio',
            quantity: 150,
            unit: 'SF',
            unitPrice: 12.00,
            room: 'Exterior'
        });
        
        items.push({
            id: `block-foundation-${itemId++}`,
            category: 'concrete',
            name: 'Block Foundation Wall',
            description: '8" concrete block wall',
            quantity: 50,
            unit: 'SF',
            unitPrice: 12.50,
            room: 'Foundation'
        });
        
        items.push({
            id: `brick-veneer-${itemId++}`,
            category: 'concrete',
            name: 'Brick Veneer',
            description: 'Standard brick veneer installation',
            quantity: 100,
            unit: 'SF',
            unitPrice: 18.00,
            room: 'Exterior'
        });
        
        // ------------------------------------------------------------------
        // ADDITIONAL ELECTRICAL
        // ------------------------------------------------------------------
        items.push({
            id: `elec-panel-100a-${itemId++}`,
            category: 'electrical',
            name: 'Electrical Panel 100A',
            description: '100-amp main electrical panel',
            quantity: 1,
            unit: 'EA',
            unitPrice: 850.00,
            room: 'Electrical'
        });
        
        items.push({
            id: `elec-panel-200a-${itemId++}`,
            category: 'electrical',
            name: 'Electrical Panel 200A',
            description: '200-amp main electrical panel',
            quantity: 1,
            unit: 'EA',
            unitPrice: 1250.00,
            room: 'Electrical'
        });
        
        items.push({
            id: `elec-ceiling-fan-${itemId++}`,
            category: 'electrical',
            name: 'Ceiling Fan with Light',
            description: 'Ceiling fan with light kit',
            quantity: 3,
            unit: 'EA',
            unitPrice: 180.00,
            room: 'Electrical'
        });
        
        items.push({
            id: `elec-chandelier-${itemId++}`,
            category: 'electrical',
            name: 'Chandelier',
            description: 'Dining room chandelier',
            quantity: 1,
            unit: 'EA',
            unitPrice: 320.00,
            room: 'Electrical'
        });
        
        items.push({
            id: `elec-smoke-detector-${itemId++}`,
            category: 'electrical',
            name: 'Smoke Detector',
            description: 'Hardwired smoke detector',
            quantity: 4,
            unit: 'EA',
            unitPrice: 65.00,
            room: 'Electrical'
        });
        
        items.push({
            id: `elec-gfci-outlet-${itemId++}`,
            category: 'electrical',
            name: 'GFCI Outlet',
            description: 'Ground fault circuit interrupter outlet',
            quantity: 3,
            unit: 'EA',
            unitPrice: 55.00,
            room: 'Electrical'
        });
        
        // ------------------------------------------------------------------
        // ADDITIONAL PLUMBING
        // ------------------------------------------------------------------
        items.push({
            id: `plumb-toilet-standard-${itemId++}`,
            category: 'plumbing',
            name: 'Toilet - Standard',
            description: 'Standard two-piece toilet',
            quantity: 2,
            unit: 'EA',
            unitPrice: 280.00,
            room: 'Bathroom'
        });
        
        items.push({
            id: `plumb-toilet-lowflow-${itemId++}`,
            category: 'plumbing',
            name: 'Toilet - Low-Flow',
            description: 'High-efficiency low-flow toilet',
            quantity: 2,
            unit: 'EA',
            unitPrice: 380.00,
            room: 'Bathroom'
        });
        
        items.push({
            id: `plumb-vanity-sink-${itemId++}`,
            category: 'plumbing',
            name: 'Vanity Sink',
            description: 'Drop-in vanity sink with faucet',
            quantity: 2,
            unit: 'EA',
            unitPrice: 220.00,
            room: 'Bathroom'
        });
        
        items.push({
            id: `plumb-kitchen-sink-${itemId++}`,
            category: 'plumbing',
            name: 'Kitchen Sink',
            description: 'Double-bowl stainless steel sink',
            quantity: 1,
            unit: 'EA',
            unitPrice: 280.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `plumb-tub-${itemId++}`,
            category: 'plumbing',
            name: 'Bathtub',
            description: 'Standard 60" bathtub',
            quantity: 1,
            unit: 'EA',
            unitPrice: 450.00,
            room: 'Bathroom'
        });
        
        items.push({
            id: `plumb-shower-pan-${itemId++}`,
            category: 'plumbing',
            name: 'Shower Pan',
            description: 'Fiberglass shower pan, 36"x36"',
            quantity: 1,
            unit: 'EA',
            unitPrice: 350.00,
            room: 'Bathroom'
        });
        
        items.push({
            id: `plumb-tub-surround-${itemId++}`,
            category: 'plumbing',
            name: 'Tub/Shower Surround',
            description: 'Three-piece tub surround',
            quantity: 1,
            unit: 'EA',
            unitPrice: 280.00,
            room: 'Bathroom'
        });
        
        items.push({
            id: `plumb-faucet-sink-${itemId++}`,
            category: 'plumbing',
            name: 'Bathroom Faucet',
            description: 'Standard bathroom sink faucet',
            quantity: 2,
            unit: 'EA',
            unitPrice: 120.00,
            room: 'Bathroom'
        });
        
        items.push({
            id: `plumb-faucet-kitchen-${itemId++}`,
            category: 'plumbing',
            name: 'Kitchen Faucet',
            description: 'Pull-down kitchen faucet',
            quantity: 1,
            unit: 'EA',
            unitPrice: 220.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `plumb-shower-valve-${itemId++}`,
            category: 'plumbing',
            name: 'Shower Valve & Trim',
            description: 'Pressure-balance shower valve with trim',
            quantity: 1,
            unit: 'EA',
            unitPrice: 280.00,
            room: 'Bathroom'
        });
        
        // ------------------------------------------------------------------
        // LANDSCAPING
        // ------------------------------------------------------------------
        items.push({
            id: `landscape-sod-${itemId++}`,
            category: 'landscaping',
            name: 'Sod Installation',
            description: 'Premium grass sod with installation',
            quantity: 500,
            unit: 'SF',
            unitPrice: 1.80,
            room: 'Yard'
        });
        
        items.push({
            id: `landscape-seed-${itemId++}`,
            category: 'landscaping',
            name: 'Grass Seed',
            description: 'Grass seed with topsoil',
            quantity: 500,
            unit: 'SF',
            unitPrice: 0.45,
            room: 'Yard'
        });
        
        items.push({
            id: `landscape-mulch-${itemId++}`,
            category: 'landscaping',
            name: 'Mulch',
            description: 'Hardwood mulch, 3" depth',
            quantity: 100,
            unit: 'SF',
            unitPrice: 1.20,
            room: 'Yard'
        });
        
        items.push({
            id: `landscape-shrub-${itemId++}`,
            category: 'landscaping',
            name: 'Shrubs',
            description: 'Decorative shrubs, 3-gallon',
            quantity: 10,
            unit: 'EA',
            unitPrice: 45.00,
            room: 'Yard'
        });
        
        items.push({
            id: `landscape-tree-${itemId++}`,
            category: 'landscaping',
            name: 'Tree',
            description: 'Shade tree, 6-8 ft height',
            quantity: 2,
            unit: 'EA',
            unitPrice: 250.00,
            room: 'Yard'
        });
        
        items.push({
            id: `landscape-fence-wood-${itemId++}`,
            category: 'landscaping',
            name: 'Wood Privacy Fence',
            description: '6ft cedar privacy fence',
            quantity: 50,
            unit: 'LF',
            unitPrice: 28.00,
            room: 'Yard'
        });
        
        items.push({
            id: `landscape-fence-vinyl-${itemId++}`,
            category: 'landscaping',
            name: 'Vinyl Fence',
            description: '6ft vinyl privacy fence',
            quantity: 50,
            unit: 'LF',
            unitPrice: 38.00,
            room: 'Yard'
        });
        
        items.push({
            id: `landscape-deck-${itemId++}`,
            category: 'landscaping',
            name: 'Wood Deck',
            description: 'Pressure-treated wood deck',
            quantity: 200,
            unit: 'SF',
            unitPrice: 22.00,
            room: 'Exterior'
        });
        
        items.push({
            id: `landscape-paver-${itemId++}`,
            category: 'landscaping',
            name: 'Paver Patio',
            description: 'Interlocking paver patio',
            quantity: 150,
            unit: 'SF',
            unitPrice: 15.00,
            room: 'Exterior'
        });
        
        // ------------------------------------------------------------------
        // SPECIALTY ROOFING
        // ------------------------------------------------------------------
        items.push({
            id: `roof-metal-standing-${itemId++}`,
            category: 'roofing',
            name: 'Standing Seam Metal Roof',
            description: 'Premium standing seam metal roofing',
            quantity: 100,
            unit: 'SQ',
            unitPrice: 850.00,
            room: 'Roof'
        });
        
        items.push({
            id: `roof-metal-corrugated-${itemId++}`,
            category: 'roofing',
            name: 'Corrugated Metal Roofing',
            description: 'Standard corrugated metal panels',
            quantity: 100,
            unit: 'SQ',
            unitPrice: 450.00,
            room: 'Roof'
        });
        
        items.push({
            id: `roof-tpo-${itemId++}`,
            category: 'roofing',
            name: 'TPO Flat Roofing',
            description: 'White TPO membrane roofing system',
            quantity: 100,
            unit: 'SQ',
            unitPrice: 650.00,
            room: 'Roof'
        });
        
        items.push({
            id: `roof-epdm-${itemId++}`,
            category: 'roofing',
            name: 'EPDM Rubber Roofing',
            description: 'Black EPDM rubber membrane',
            quantity: 100,
            unit: 'SQ',
            unitPrice: 550.00,
            room: 'Roof'
        });
        
        items.push({
            id: `roof-slate-${itemId++}`,
            category: 'roofing',
            name: 'Slate Roofing',
            description: 'Natural slate tiles, premium grade',
            quantity: 100,
            unit: 'SQ',
            unitPrice: 1800.00,
            room: 'Roof'
        });
        
        items.push({
            id: `roof-tile-clay-${itemId++}`,
            category: 'roofing',
            name: 'Clay Tile Roofing',
            description: 'Spanish/Mission style clay tiles',
            quantity: 100,
            unit: 'SQ',
            unitPrice: 1200.00,
            room: 'Roof'
        });
        
        items.push({
            id: `roof-skylight-${itemId++}`,
            category: 'roofing',
            name: 'Skylight',
            description: 'Fixed or vented skylight with flashing',
            quantity: 1,
            unit: 'EA',
            unitPrice: 650.00,
            room: 'Roof'
        });
        
        // ------------------------------------------------------------------
        // ADVANCED HVAC
        // ------------------------------------------------------------------
        items.push({
            id: `hvac-minisplit-${itemId++}`,
            category: 'hvac',
            name: 'Mini-Split System',
            description: 'Ductless mini-split heat pump',
            quantity: 1,
            unit: 'EA',
            unitPrice: 3200.00,
            room: 'HVAC'
        });
        
        items.push({
            id: `hvac-zone-damper-${itemId++}`,
            category: 'hvac',
            name: 'Zone Damper',
            description: 'Motorized zone control damper',
            quantity: 3,
            unit: 'EA',
            unitPrice: 280.00,
            room: 'HVAC'
        });
        
        items.push({
            id: `hvac-erv-${itemId++}`,
            category: 'hvac',
            name: 'Energy Recovery Ventilator',
            description: 'ERV whole-house ventilation system',
            quantity: 1,
            unit: 'EA',
            unitPrice: 1800.00,
            room: 'HVAC'
        });
        
        items.push({
            id: `hvac-humidifier-${itemId++}`,
            category: 'hvac',
            name: 'Whole-House Humidifier',
            description: 'Built-in humidifier system',
            quantity: 1,
            unit: 'EA',
            unitPrice: 450.00,
            room: 'HVAC'
        });
        
        items.push({
            id: `hvac-air-purifier-${itemId++}`,
            category: 'hvac',
            name: 'Air Purification System',
            description: 'UV/HEPA whole-house air cleaner',
            quantity: 1,
            unit: 'EA',
            unitPrice: 850.00,
            room: 'HVAC'
        });
        
        // ------------------------------------------------------------------
        // FLOORING VARIETIES
        // ------------------------------------------------------------------
        items.push({
            id: `floor-lvp-${itemId++}`,
            category: 'flooring',
            name: 'Luxury Vinyl Plank (LVP)',
            description: 'Premium waterproof LVP flooring',
            quantity: 200,
            unit: 'SF',
            unitPrice: 6.50,
            room: 'General'
        });
        
        items.push({
            id: `floor-engineered-hardwood-${itemId++}`,
            category: 'flooring',
            name: 'Engineered Hardwood',
            description: 'Engineered wood flooring, oak or maple',
            quantity: 200,
            unit: 'SF',
            unitPrice: 8.50,
            room: 'General'
        });
        
        items.push({
            id: `floor-solid-hardwood-${itemId++}`,
            category: 'flooring',
            name: 'Solid Hardwood Flooring',
            description: '3/4" solid oak hardwood',
            quantity: 200,
            unit: 'SF',
            unitPrice: 12.00,
            room: 'General'
        });
        
        items.push({
            id: `floor-tile-porcelain-${itemId++}`,
            category: 'flooring',
            name: 'Porcelain Tile',
            description: 'Large format porcelain floor tile',
            quantity: 200,
            unit: 'SF',
            unitPrice: 7.50,
            room: 'General'
        });
        
        items.push({
            id: `floor-tile-ceramic-${itemId++}`,
            category: 'flooring',
            name: 'Ceramic Tile',
            description: 'Standard ceramic floor tile',
            quantity: 200,
            unit: 'SF',
            unitPrice: 5.50,
            room: 'General'
        });
        
        items.push({
            id: `floor-laminate-${itemId++}`,
            category: 'flooring',
            name: 'Laminate Flooring',
            description: 'AC3-AC4 rated laminate',
            quantity: 200,
            unit: 'SF',
            unitPrice: 4.50,
            room: 'General'
        });
        
        items.push({
            id: `floor-bamboo-${itemId++}`,
            category: 'flooring',
            name: 'Bamboo Flooring',
            description: 'Strand-woven bamboo flooring',
            quantity: 200,
            unit: 'SF',
            unitPrice: 7.00,
            room: 'General'
        });
        
        items.push({
            id: `floor-cork-${itemId++}`,
            category: 'flooring',
            name: 'Cork Flooring',
            description: 'Natural cork tile flooring',
            quantity: 200,
            unit: 'SF',
            unitPrice: 8.00,
            room: 'General'
        });
        
        // ------------------------------------------------------------------
        // SPECIALTY PAINT & PRIMERS
        // ------------------------------------------------------------------
        items.push({
            id: `paint-primer-${itemId++}`,
            category: 'paint',
            name: 'Interior Primer',
            description: 'High-quality interior primer',
            quantity: 200,
            unit: 'SF',
            unitPrice: 0.45,
            room: 'General'
        });
        
        items.push({
            id: `paint-stain-blocking-${itemId++}`,
            category: 'paint',
            name: 'Stain-Blocking Primer',
            description: 'Oil-based stain blocker',
            quantity: 100,
            unit: 'SF',
            unitPrice: 0.75,
            room: 'General'
        });
        
        items.push({
            id: `paint-epoxy-${itemId++}`,
            category: 'paint',
            name: 'Epoxy Floor Paint',
            description: 'Two-part epoxy garage floor coating',
            quantity: 400,
            unit: 'SF',
            unitPrice: 2.50,
            room: 'Garage'
        });
        
        items.push({
            id: `paint-cabinet-${itemId++}`,
            category: 'paint',
            name: 'Cabinet Refinishing',
            description: 'Professional cabinet painting/refinishing',
            quantity: 20,
            unit: 'LF',
            unitPrice: 25.00,
            room: 'Kitchen'
        });
        
        // ------------------------------------------------------------------
        // WINDOWS & DOORS VARIETIES
        // ------------------------------------------------------------------
        items.push({
            id: `window-double-hung-vinyl-${itemId++}`,
            category: 'doors',
            name: 'Vinyl Double-Hung Window',
            description: 'Standard vinyl double-hung replacement',
            quantity: 5,
            unit: 'EA',
            unitPrice: 450.00,
            room: 'General'
        });
        
        items.push({
            id: `window-casement-${itemId++}`,
            category: 'doors',
            name: 'Casement Window',
            description: 'Vinyl or wood casement window',
            quantity: 3,
            unit: 'EA',
            unitPrice: 550.00,
            room: 'General'
        });
        
        items.push({
            id: `window-bay-${itemId++}`,
            category: 'doors',
            name: 'Bay Window',
            description: 'Multi-panel bay window system',
            quantity: 1,
            unit: 'EA',
            unitPrice: 2200.00,
            room: 'Living Room'
        });
        
        items.push({
            id: `window-slider-${itemId++}`,
            category: 'doors',
            name: 'Sliding Window',
            description: 'Horizontal slider window',
            quantity: 3,
            unit: 'EA',
            unitPrice: 420.00,
            room: 'General'
        });
        
        items.push({
            id: `door-sliding-glass-${itemId++}`,
            category: 'doors',
            name: 'Sliding Glass Door',
            description: '6ft sliding patio door',
            quantity: 1,
            unit: 'EA',
            unitPrice: 1200.00,
            room: 'Patio'
        });
        
        items.push({
            id: `door-french-${itemId++}`,
            category: 'doors',
            name: 'French Doors (Pair)',
            description: 'Interior or exterior French door set',
            quantity: 1,
            unit: 'EA',
            unitPrice: 1400.00,
            room: 'General'
        });
        
        items.push({
            id: `door-storm-${itemId++}`,
            category: 'doors',
            name: 'Storm Door',
            description: 'Aluminum storm/screen door',
            quantity: 2,
            unit: 'EA',
            unitPrice: 320.00,
            room: 'Exterior'
        });
        
        items.push({
            id: `door-garage-single-${itemId++}`,
            category: 'doors',
            name: 'Garage Door - Single',
            description: 'Single car garage door with opener',
            quantity: 1,
            unit: 'EA',
            unitPrice: 950.00,
            room: 'Garage'
        });
        
        items.push({
            id: `door-garage-double-${itemId++}`,
            category: 'doors',
            name: 'Garage Door - Double',
            description: 'Double car garage door with opener',
            quantity: 1,
            unit: 'EA',
            unitPrice: 1400.00,
            room: 'Garage'
        });
        
        // ------------------------------------------------------------------
        // SMART HOME / ADVANCED ELECTRICAL
        // ------------------------------------------------------------------
        items.push({
            id: `elec-smart-switch-${itemId++}`,
            category: 'electrical',
            name: 'Smart Light Switch',
            description: 'WiFi connected dimmer switch',
            quantity: 5,
            unit: 'EA',
            unitPrice: 45.00,
            room: 'Electrical'
        });
        
        items.push({
            id: `elec-smart-thermostat-${itemId++}`,
            category: 'electrical',
            name: 'Smart Thermostat',
            description: 'WiFi programmable thermostat (Nest/Ecobee)',
            quantity: 1,
            unit: 'EA',
            unitPrice: 280.00,
            room: 'HVAC'
        });
        
        items.push({
            id: `elec-usb-outlet-${itemId++}`,
            category: 'electrical',
            name: 'USB Outlet',
            description: 'Outlet with built-in USB charging',
            quantity: 4,
            unit: 'EA',
            unitPrice: 35.00,
            room: 'Electrical'
        });
        
        items.push({
            id: `elec-recessed-light-${itemId++}`,
            category: 'electrical',
            name: 'Recessed LED Light',
            description: 'LED can light with trim',
            quantity: 8,
            unit: 'EA',
            unitPrice: 65.00,
            room: 'Electrical'
        });
        
        items.push({
            id: `elec-undercabinet-light-${itemId++}`,
            category: 'electrical',
            name: 'Under-Cabinet Lighting',
            description: 'LED strip or puck lights',
            quantity: 10,
            unit: 'LF',
            unitPrice: 18.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `elec-generator-transfer-${itemId++}`,
            category: 'electrical',
            name: 'Generator Transfer Switch',
            description: 'Automatic transfer switch installation',
            quantity: 1,
            unit: 'EA',
            unitPrice: 1200.00,
            room: 'Electrical'
        });
        
        // ------------------------------------------------------------------
        // ADVANCED PLUMBING
        // ------------------------------------------------------------------
        items.push({
            id: `plumb-tankless-gas-${itemId++}`,
            category: 'plumbing',
            name: 'Tankless Water Heater (Gas)',
            description: 'Gas tankless on-demand water heater',
            quantity: 1,
            unit: 'EA',
            unitPrice: 2200.00,
            room: 'Utility'
        });
        
        items.push({
            id: `plumb-tankless-electric-${itemId++}`,
            category: 'plumbing',
            name: 'Tankless Water Heater (Electric)',
            description: 'Electric tankless water heater',
            quantity: 1,
            unit: 'EA',
            unitPrice: 1800.00,
            room: 'Utility'
        });
        
        items.push({
            id: `plumb-water-softener-${itemId++}`,
            category: 'plumbing',
            name: 'Water Softener System',
            description: 'Whole-house water softening system',
            quantity: 1,
            unit: 'EA',
            unitPrice: 1500.00,
            room: 'Utility'
        });
        
        items.push({
            id: `plumb-sump-pump-${itemId++}`,
            category: 'plumbing',
            name: 'Sump Pump',
            description: 'Pedestal or submersible sump pump',
            quantity: 1,
            unit: 'EA',
            unitPrice: 450.00,
            room: 'Basement'
        });
        
        items.push({
            id: `plumb-water-filtration-${itemId++}`,
            category: 'plumbing',
            name: 'Whole-House Water Filter',
            description: 'Whole-house filtration system',
            quantity: 1,
            unit: 'EA',
            unitPrice: 850.00,
            room: 'Utility'
        });
        
        items.push({
            id: `plumb-instant-hot-${itemId++}`,
            category: 'plumbing',
            name: 'Instant Hot Water Dispenser',
            description: 'Under-sink instant hot water',
            quantity: 1,
            unit: 'EA',
            unitPrice: 380.00,
            room: 'Kitchen'
        });
        
        items.push({
            id: `plumb-jetted-tub-${itemId++}`,
            category: 'plumbing',
            name: 'Jetted Bathtub',
            description: 'Whirlpool/air jet tub system',
            quantity: 1,
            unit: 'EA',
            unitPrice: 1800.00,
            room: 'Bathroom'
        });
        
        items.push({
            id: `plumb-bidet-${itemId++}`,
            category: 'plumbing',
            name: 'Bidet Attachment/Seat',
            description: 'Electronic bidet toilet seat',
            quantity: 1,
            unit: 'EA',
            unitPrice: 450.00,
            room: 'Bathroom'
        });
        
        return items;
    }
    
    renderAvailableItems() {
        const container = document.getElementById('availableItemsList');
        if (!container) return;
        
        // Update counts
        document.getElementById('favCount').textContent = this.favorites.length;
        document.getElementById('recentCount').textContent = this.recentItems.length;
        
        let itemsToShow = [];
        
        // Handle special categories
        if (this.currentCategory === 'favorites') {
            itemsToShow = this.availableItems.filter(item => this.favorites.includes(item.id));
        } else if (this.currentCategory === 'recent') {
            // Show recent items in order (most recent first)
            this.recentItems.forEach(recentId => {
                const item = this.availableItems.find(i => i.id === recentId);
                if (item) itemsToShow.push(item);
            });
        } else {
            // Normal category filtering
            itemsToShow = this.availableItems.filter(item => {
                // Filter by category
                if (this.currentCategory !== 'all' && item.category !== this.currentCategory) {
                    return false;
                }
                
                // Filter by search
                const search = document.getElementById('itemSearch');
                if (search && search.value) {
                    const searchTerm = search.value.toLowerCase();
                    return item.name.toLowerCase().includes(searchTerm) || 
                           item.description.toLowerCase().includes(searchTerm) ||
                           item.room.toLowerCase().includes(searchTerm) ||
                           item.category.toLowerCase().includes(searchTerm);
                }
                
                return true;
            });
        }
        
        container.innerHTML = itemsToShow.map(item => {
            const isSelected = this.selectedItems.some(s => s.id === item.id);
            const isFavorite = this.favorites.includes(item.id);
            const qty = item.quantity || 0;
            const price = item.unitPrice || 0;
            const total = qty * price;
            
            return `
                <div class="available-item ${isSelected ? 'selected' : ''}" style="position: relative;">
                    <div style="position: absolute; top: 8px; right: 8px; z-index: 10;">
                        <button onclick="event.stopPropagation(); estimatorIntegration.toggleFavorite('${item.id}')" 
                                style="background: none; border: none; font-size: 18px; cursor: pointer; padding: 4px; line-height: 1;"
                                title="${isFavorite ? 'Remove from favorites' : 'Add to favorites'}">
                            ${isFavorite ? '‚≠ê' : '‚òÜ'}
                        </button>
                    </div>
                    <div onclick="estimatorIntegration.toggleItem('${item.id}')" style="cursor: pointer;">
                        <div class="item-name">
                            ${item.name}
                            <span class="item-category-badge category-${item.category}">${item.category.toUpperCase()}</span>
                        </div>
                        <div class="item-details">
                            <span>${qty.toFixed(2)} ${item.unit} @ $${price.toFixed(2)}/${item.unit}</span>
                            <span style="font-weight: 600;">$${total.toFixed(2)}</span>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
    }
    
    toggleFavorite(itemId) {
        const index = this.favorites.indexOf(itemId);
        if (index >= 0) {
            this.favorites.splice(index, 1);
        } else {
            this.favorites.push(itemId);
        }
        localStorage.setItem('estimatorFavorites', JSON.stringify(this.favorites));
        this.renderAvailableItems();
    }
    
    addToRecent(itemId) {
        // Remove if already in list
        this.recentItems = this.recentItems.filter(id => id !== itemId);
        // Add to front
        this.recentItems.unshift(itemId);
        // Keep only last 20
        this.recentItems = this.recentItems.slice(0, 20);
        localStorage.setItem('estimatorRecentItems', JSON.stringify(this.recentItems));
    }
    
    toggleItem(itemId) {
        const item = this.availableItems.find(i => i.id === itemId);
        if (!item) return;
        
        const existingIndex = this.selectedItems.findIndex(s => s.id === itemId);
        if (existingIndex >= 0) {
            // Remove
            this.selectedItems.splice(existingIndex, 1);
        } else {
            // Add and track as recent
            this.selectedItems.push({...item});
            this.addToRecent(itemId);
        }
        
        this.renderAvailableItems();
        this.updateSelectedItemsDisplay();
    }
    
    updateSelectedItemsDisplay() {
        const container = document.getElementById('selectedItemsList');
        const countEl = document.getElementById('selectedCount');
        
        if (!container || !countEl) return;
        
        countEl.textContent = `${this.selectedItems.length} item${this.selectedItems.length !== 1 ? 's' : ''} selected`;
        
        if (this.selectedItems.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <p>üëà Click items from the left to add them to your estimate</p>
                    <p style="font-size: 12px; color: #666;">You can edit quantities and prices after adding</p>
                </div>
            `;
        } else {
            container.innerHTML = this.selectedItems.map((item, idx) => `
                <div class="selected-item" data-item-id="${item.id}">
                    <div class="selected-item-header">
                        <div class="selected-item-name">${item.name}</div>
                        <button class="remove-item-btn" onclick="estimatorIntegration.removeItem('${item.id}')">Remove</button>
                    </div>
                    <div class="selected-item-controls">
                        <div class="control-group">
                            <label>Quantity</label>
                            <input type="number" step="0.01" value="${item.quantity}" 
                                   onchange="estimatorIntegration.updateItemQuantity('${item.id}', this.value)">
                        </div>
                        <div class="control-group">
                            <label>Unit Price</label>
                            <input type="number" step="0.01" value="${item.unitPrice}" 
                                   onchange="estimatorIntegration.updateItemPrice('${item.id}', this.value)">
                        </div>
                        <div class="control-group">
                            <label>Total</label>
                            <input type="text" value="$${(item.quantity * item.unitPrice).toFixed(2)}" readonly style="background: #f5f5f5;">
                        </div>
                    </div>
                </div>
            `).join('');
        }
        
        this.updateTotals();
    }
    
    removeItem(itemId) {
        this.selectedItems = this.selectedItems.filter(i => i.id !== itemId);
        this.renderAvailableItems();
        this.updateSelectedItemsDisplay();
    }
    
    clearAllItems() {
        this.selectedItems = [];
        this.renderAvailableItems();
        this.updateSelectedItemsDisplay();
        this.showSuccess('All items cleared');
    }
    
    updateItemQuantity(itemId, value) {
        const item = this.selectedItems.find(i => i.id === itemId);
        if (item) {
            item.quantity = parseFloat(value) || 0;
            this.updateSelectedItemsDisplay();
        }
    }
    
    updateItemPrice(itemId, value) {
        const item = this.selectedItems.find(i => i.id === itemId);
        if (item) {
            item.unitPrice = parseFloat(value) || 0;
            this.updateSelectedItemsDisplay();
        }
    }
    
    updateTotals() {
        const subtotal = this.selectedItems.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0);
        const tax = subtotal * this.taxRate;
        const op = subtotal * this.opRate;
        const rcv = subtotal + tax + op; // Replacement Cost Value
        
        // Insurance claim calculations
        const depreciationAmount = rcv * this.depreciationRate;
        const acv = rcv - depreciationAmount; // Actual Cash Value
        const netClaim = Math.max(0, acv - this.deductible);
        const netIfRecovered = Math.max(0, rcv - this.deductible);
        
        // Update standard totals
        document.getElementById('subtotalAmount').textContent = '$' + subtotal.toFixed(2);
        document.getElementById('taxAmount').textContent = '$' + tax.toFixed(2);
        document.getElementById('opAmount').textContent = '$' + op.toFixed(2);
        document.getElementById('grandTotal').textContent = '$' + rcv.toFixed(2);
        
        // Update insurance claim section
        const insuranceSection = document.getElementById('insuranceClaimSection');
        if (this.depreciationRate > 0 || this.deductible > 0) {
            insuranceSection.style.display = 'block';
            document.getElementById('depreciationAmount').textContent = '($' + depreciationAmount.toFixed(2) + ')';
            document.getElementById('acvAmount').textContent = '$' + acv.toFixed(2);
            document.getElementById('deductibleAmount').textContent = '($' + this.deductible.toFixed(2) + ')';
            document.getElementById('netClaimAmount').textContent = '$' + netClaim.toFixed(2);
            document.getElementById('recoverableDepreciation').textContent = '$' + depreciationAmount.toFixed(2);
            document.getElementById('netIfRecovered').textContent = '$' + netIfRecovered.toFixed(2);
        } else {
            insuranceSection.style.display = 'none';
        }
    }
    
    calculateSelectedTotal() {
        // Alias for updateTotals
        this.updateTotals();
    }
    
    showCategory(category) {
        // Update active tab
        document.querySelectorAll('.category-tab').forEach(tab => {
            tab.classList.remove('active');
        });
        if (event && event.target) {
            event.target.classList.add('active');
        }
        
        this.currentCategory = category;
        this.renderAvailableItems();
    }
    
    showTemplates() {
        const templates = {
            'Full Bathroom Remodel': [
                { search: 'drywall', category: 'drywall' },
                { search: 'tape', category: 'drywall' },
                { search: 'paint', category: 'paint' },
                { search: 'tile floor', category: 'flooring' },
                { search: 'vanity', category: 'cabinets' },
                { search: 'toilet', category: 'plumbing' },
                { search: 'vanity sink', category: 'plumbing' },
                { search: 'tub', category: 'plumbing' },
                { search: 'shower', category: 'plumbing' },
                { search: 'bathroom faucet', category: 'plumbing' },
                { search: 'exhaust fan', category: 'electrical' }
            ],
            'Kitchen Remodel': [
                { search: 'base cabinet', category: 'cabinets' },
                { search: 'wall cabinet', category: 'cabinets' },
                { search: 'granite countertop', category: 'cabinets' },
                { search: 'backsplash', category: 'cabinets' },
                { search: 'kitchen sink', category: 'plumbing' },
                { search: 'kitchen faucet', category: 'plumbing' },
                { search: 'disposal', category: 'appliances' },
                { search: 'dishwasher', category: 'appliances' },
                { search: 'range', category: 'appliances' },
                { search: 'microwave', category: 'appliances' },
                { search: 'hood', category: 'appliances' }
            ],
            'Water Damage Restoration': [
                { search: 'Flood Cut 2\' High', category: 'drywall' },
                { search: 'Flood Cut 4\' High', category: 'drywall' },
                { search: 'Tape & Finish (Flood Cut 2\')', category: 'drywall' },
                { search: 'Tape & Finish (Flood Cut 4\')', category: 'drywall' },
                { search: 'paint', category: 'paint' },
                { search: 'carpet', category: 'flooring' },
                { search: 'baseboard', category: 'other' }
            ],
            'Flood Damage - 2 Foot Cut': [
                { search: 'Flood Cut 2\' High', category: 'drywall' },
                { search: 'Tape & Finish (Flood Cut 2\')', category: 'drywall' },
                { search: 'paint', category: 'paint' },
                { search: 'baseboard', category: 'other' },
                { search: 'carpet', category: 'flooring' }
            ],
            'Flood Damage - 4 Foot Cut': [
                { search: 'Flood Cut 4\' High', category: 'drywall' },
                { search: 'Tape & Finish (Flood Cut 4\')', category: 'drywall' },
                { search: 'paint', category: 'paint' },
                { search: 'baseboard', category: 'other' },
                { search: 'carpet', category: 'flooring' }
            ],
            'Fire Damage Restoration': [
                { search: 'drywall', category: 'drywall' },
                { search: 'tape', category: 'drywall' },
                { search: 'paint', category: 'paint' },
                { search: 'carpet', category: 'flooring' },
                { search: 'door', category: 'doors' },
                { search: 'baseboard', category: 'other' },
                { search: 'cleanup', category: 'other' }
            ],
            'New Roof': [
                { search: 'shingles', category: 'roofing' },
                { search: 'underlayment', category: 'roofing' },
                { search: 'ice shield', category: 'roofing' },
                { search: 'drip edge', category: 'roofing' },
                { search: 'ridge vent', category: 'roofing' },
                { search: 'pipe boot', category: 'roofing' },
                { search: 'gutter', category: 'roofing' },
                { search: 'downspout', category: 'roofing' }
            ],
            'HVAC System': [
                { search: 'AC Unit', category: 'hvac' },
                { search: 'Furnace', category: 'hvac' },
                { search: 'ductwork', category: 'hvac' },
                { search: 'register', category: 'hvac' },
                { search: 'return', category: 'hvac' },
                { search: 'thermostat', category: 'hvac' }
            ],
            'Exterior Paint': [
                { search: 'exterior paint', category: 'exterior' }
            ],
            'Basic Landscaping': [
                { search: 'sod', category: 'landscaping' },
                { search: 'mulch', category: 'landscaping' },
                { search: 'shrubs', category: 'landscaping' },
                { search: 'tree', category: 'landscaping' }
            ],
            'Basement Finish': [
                { search: 'drywall', category: 'drywall' },
                { search: 'framing', category: 'framing' },
                { search: 'insulation', category: 'insulation' },
                { search: 'LVP', category: 'flooring' },
                { search: 'paint', category: 'paint' },
                { search: 'recessed', category: 'electrical' },
                { search: 'outlet', category: 'electrical' },
                { search: 'baseboard', category: 'other' }
            ],
            'Garage Conversion': [
                { search: 'drywall', category: 'drywall' },
                { search: 'insulation', category: 'insulation' },
                { search: 'flooring', category: 'flooring' },
                { search: 'door', category: 'doors' },
                { search: 'window', category: 'doors' },
                { search: 'outlet', category: 'electrical' },
                { search: 'light', category: 'electrical' },
                { search: 'paint', category: 'paint' }
            ],
            'Master Suite Addition': [
                { search: 'framing', category: 'framing' },
                { search: 'drywall', category: 'drywall' },
                { search: 'insulation', category: 'insulation' },
                { search: 'flooring', category: 'flooring' },
                { search: 'door', category: 'doors' },
                { search: 'window', category: 'doors' },
                { search: 'toilet', category: 'plumbing' },
                { search: 'shower', category: 'plumbing' },
                { search: 'vanity', category: 'cabinets' },
                { search: 'paint', category: 'paint' }
            ],
            'Window Replacement (Whole House)': [
                { search: 'double-hung', category: 'doors' },
                { search: 'casement', category: 'doors' },
                { search: 'slider', category: 'doors' }
            ],
            'Flooring (Whole House)': [
                { search: 'LVP', category: 'flooring' },
                { search: 'carpet', category: 'flooring' },
                { search: 'tile', category: 'flooring' },
                { search: 'baseboard', category: 'other' }
            ],
            'Interior Paint (Whole House)': [
                { search: 'primer', category: 'paint' },
                { search: 'paint walls', category: 'paint' },
                { search: 'paint ceiling', category: 'paint' },
                { search: 'paint trim', category: 'paint' }
            ],
            'Exterior Paint (Whole House)': [
                { search: 'exterior paint', category: 'exterior' },
                { search: 'trim', category: 'exterior' },
                { search: 'soffit', category: 'exterior' }
            ],
            'Storm Damage Restoration': [
                { search: 'roofing', category: 'roofing' },
                { search: 'siding', category: 'exterior' },
                { search: 'window', category: 'doors' },
                { search: 'door', category: 'doors' },
                { search: 'gutter', category: 'roofing' },
                { search: 'drywall', category: 'drywall' },
                { search: 'insulation', category: 'insulation' },
                { search: 'cleanup', category: 'other' }
            ],
            'Deck Build Complete': [
                { search: 'deck', category: 'landscaping' },
                { search: 'railing', category: 'other' },
                { search: 'concrete', category: 'concrete' }
            ],
            'Fence Installation Complete': [
                { search: 'fence', category: 'landscaping' },
                { search: 'concrete', category: 'concrete' }
            ]
        };
        
        const modal = document.createElement('div');
        modal.id = 'templateModal';
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7); z-index: 10002;
            display: flex; align-items: center; justify-content: center; padding: 20px;
        `;
        
        modal.innerHTML = `
            <div style="background: white; border-radius: 12px; padding: 30px; max-width: 600px; width: 100%; max-height: 80vh; overflow-y: auto;">
                <h2 style="margin: 0 0 20px 0; color: #333;">üìã Item Templates</h2>
                <p style="color: #666; margin-bottom: 20px;">Select a template to quickly add common item bundles:</p>
                <div style="display: grid; gap: 10px;">
                    ${Object.keys(templates).map(templateName => `
                        <button onclick="estimatorIntegration.applyTemplate('${templateName}'); estimatorIntegration.closeTemplateModal();"
                                style="padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; text-align: left; transition: transform 0.2s;"
                                onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                            ${templateName}
                        </button>
                    `).join('')}
                </div>
                <button onclick="estimatorIntegration.closeTemplateModal()"
                        style="margin-top: 20px; width: 100%; padding: 12px; background: white; color: #666; border: 2px solid #ddd; border-radius: 8px; cursor: pointer; font-size: 14px;">
                    Cancel
                </button>
            </div>
        `;
        
        // Close modal when clicking outside (on the dark overlay)
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                this.closeTemplateModal();
            }
        });
        
        // Close modal with ESC key
        const escHandler = (e) => {
            if (e.key === 'Escape') {
                this.closeTemplateModal();
                document.removeEventListener('keydown', escHandler);
            }
        };
        document.addEventListener('keydown', escHandler);
        
        document.body.appendChild(modal);
        
        // Store templates for applyTemplate to access
        this.templateData = templates;
    }
    
    applyTemplate(templateName) {
        if (!this.templateData || !this.templateData[templateName]) return;
        
        const template = this.templateData[templateName];
        let addedCount = 0;
        
        // Try to find and add items matching template
        template.forEach(spec => {
            const matchingItems = this.availableItems.filter(item => {
                return item.category === spec.category && 
                       item.name.toLowerCase().includes(spec.search.toLowerCase());
            });
            
            // Add first match if not already selected
            if (matchingItems.length > 0) {
                const item = matchingItems[0];
                const existingIndex = this.selectedItems.findIndex(s => s.id === item.id);
                if (existingIndex < 0) {
                    this.selectedItems.push({...item});
                    this.addToRecent(item.id);
                    addedCount++;
                }
            }
        });
        
        this.renderAvailableItems();
        this.updateSelectedItemsDisplay();
        
        if (addedCount > 0) {
            this.showSuccess(`Added ${addedCount} items from template: ${templateName}`);
        }
    }
    
    closeTemplateModal() {
        const modal = document.getElementById('templateModal');
        if (modal) {
            modal.remove();
        }
    }
    
    filterItems(searchTerm) {
        this.renderAvailableItems();
    }
    
    addCustomItem() {
        const name = prompt('Item name:');
        if (!name) return;
        
        const quantity = parseFloat(prompt('Quantity:', '1'));
        const unit = prompt('Unit (SF/LF/EA/LS):', 'EA');
        const unitPrice = parseFloat(prompt('Unit price:', '0'));
        
        const customItem = {
            id: `custom-${Date.now()}`,
            category: 'other',
            name: name,
            description: name,
            quantity: quantity || 1,
            unit: unit || 'EA',
            unitPrice: unitPrice || 0,
            room: 'Custom'
        };
        
        this.selectedItems.push(customItem);
        this.updateSelectedItemsDisplay();
        this.showSuccess('Custom item added!');
    }
    
    async generateFromSelected() {
        if (this.selectedItems.length === 0) {
            this.showError('Please select at least one item');
            return;
        }
        
        // Create custom estimate with selected items only
        const propertyData = this.convertPropertyData();
        const customEstimate = this.estimator.generateCustomEstimate(propertyData, this.selectedItems);
        
        // Store estimate for export
        this.currentEstimate = customEstimate;
        
        this.closeItemBuilder();
        
        // Show export menu
        this.showExportMenu();
    }
    
    applyMarkup() {
        const markupInput = document.getElementById('markupInput');
        if (!markupInput) return;
        
        const markupPercent = parseFloat(markupInput.value) || 0;
        if (markupPercent === 0) {
            this.showError('Please enter a markup/discount percentage');
            return;
        }
        
        if (this.selectedItems.length === 0) {
            this.showError('No items selected to apply markup/discount');
            return;
        }
        
        const multiplier = 1 + (markupPercent / 100);
        
        this.selectedItems.forEach(item => {
            item.unitPrice = item.unitPrice * multiplier;
        });
        
        this.updateSelectedItemsDisplay();
        
        if (markupPercent > 0) {
            this.showSuccess(`Applied ${markupPercent}% markup to all items`);
        } else {
            this.showSuccess(`Applied ${Math.abs(markupPercent)}% discount to all items`);
        }
        
        // Reset input
        markupInput.value = 0;
    }
    
    duplicateEstimate() {
        if (this.selectedItems.length === 0) {
            this.showError('No items to duplicate');
            return;
        }
        
        // Create deep copies of all selected items
        const duplicatedItems = this.selectedItems.map(item => ({...item}));
        
        // Add to selected items
        this.selectedItems.push(...duplicatedItems);
        
        this.updateSelectedItemsDisplay();
        this.showSuccess(`Duplicated ${duplicatedItems.length} items`);
    }
    
    viewEstimate() {
        if (!this.currentEstimate) {
            this.showError('No estimate to view');
            return;
        }
        console.log('üëÅÔ∏è Opening estimate viewer/editor');
        this.openEstimateEditor(this.currentEstimate);
    }
    
    showExportMenu() {
        // Create export menu overlay
        const overlay = document.createElement('div');
        overlay.id = 'exportMenuOverlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 10001;
            display: flex;
            align-items: center;
            justify-content: center;
        `;
        
        overlay.innerHTML = `
            <div style="background: white; border-radius: 12px; padding: 30px; max-width: 550px; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
                <h2 style="margin: 0 0 10px 0; color: #333;">‚úÖ Estimate Generated!</h2>
                <p style="color: #666; margin-bottom: 25px;">Choose how you'd like to view, export, or save your estimate:</p>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <button onclick="estimatorIntegration.viewEstimate(); document.getElementById('exportMenuOverlay').remove();" 
                            style="padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: transform 0.2s; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);">
                        üëÅÔ∏è View/Edit Estimate
                    </button>
                    
                    <hr style="margin: 5px 0; border: none; border-top: 1px solid #eee;">
                    
                    <button onclick="estimatorIntegration.exportHTML(); document.getElementById('exportMenuOverlay').remove();" 
                            style="padding: 15px; background: #9c27b0; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: transform 0.2s;">
                        üåê View HTML Report (Print/PDF)
                    </button>
                    
                    <button onclick="estimatorIntegration.exportExcel(); document.getElementById('exportMenuOverlay').remove();" 
                            style="padding: 15px; background: #4caf50; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: transform 0.2s;">
                        üìä Download Excel Workbook
                    </button>
                    
                    <button onclick="estimatorIntegration.exportInsuranceClaim(); document.getElementById('exportMenuOverlay').remove();" 
                            style="padding: 15px; background: #2196f3; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: transform 0.2s;">
                        üíº Insurance Claim Summary
                    </button>
                    
                    <button onclick="estimatorIntegration.exportPDF(); document.getElementById('exportMenuOverlay').remove();" 
                            style="padding: 15px; background: #f44336; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: transform 0.2s;">
                        üìÑ Download PDF Document
                    </button>
                    
                    <button onclick="estimatorIntegration.exportCSV(); document.getElementById('exportMenuOverlay').remove();" 
                            style="padding: 15px; background: #00bcd4; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: transform 0.2s;">
                        üìë Download CSV Spreadsheet
                    </button>
                    
                    <button onclick="estimatorIntegration.exportPlainText(); document.getElementById('exportMenuOverlay').remove();" 
                            style="padding: 15px; background: #607d8b; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: transform 0.2s;">
                        üìù Copy as Plain Text
                    </button>
                    
                    <button onclick="estimatorIntegration.exportEmail(); document.getElementById('exportMenuOverlay').remove();" 
                            style="padding: 15px; background: #3f51b5; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: transform 0.2s;">
                        üìß Email Format
                    </button>
                    
                    <hr style="margin: 10px 0; border: none; border-top: 2px solid #eee;">
                    
                    <button onclick="estimatorIntegration.saveEstimateJSON(); document.getElementById('exportMenuOverlay').remove();" 
                            style="padding: 12px; background: #ff9800; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: transform 0.2s;">
                        üíæ Save Estimate Data (for later editing)
                    </button>
                    
                    <button onclick="estimatorIntegration.openLoadEstimate(); document.getElementById('exportMenuOverlay').remove();" 
                            style="padding: 12px; background: #2196f3; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: transform 0.2s;">
                        üìÇ Load Saved Estimate
                    </button>
                    
                    <button onclick="document.getElementById('exportMenuOverlay').remove();" 
                            style="padding: 12px; background: white; color: #666; border: 2px solid #ddd; border-radius: 8px; font-size: 14px; cursor: pointer; margin-top: 10px;">
                        Cancel
                    </button>
                </div>
            </div>
        `;
        
        // Add hover effects
        const buttons = overlay.querySelectorAll('button');
        buttons.forEach(btn => {
            btn.addEventListener('mouseenter', () => {
                if (btn.textContent !== 'Cancel') {
                    btn.style.transform = 'translateY(-2px)';
                    btn.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
                }
            });
            btn.addEventListener('mouseleave', () => {
                btn.style.transform = 'translateY(0)';
                btn.style.boxShadow = 'none';
            });
        });
        
        document.body.appendChild(overlay);
    }
}

console.log('‚úÖ QuantityEstimator class defined!');
console.log('‚úÖ EstimatorIntegration class defined!');
console.log('‚úÖ Classes are ready - initialization will begin shortly...');


// =====================================================================
// INITIALIZE ESTIMATOR - SIMPLE VERSION
// =====================================================================

// Wait 500ms then initialize
console.log('üöÄ Initializing estimator...');

// LISTEN FOR CLAIM DATA FROM CLAIMS MANAGER (SETUP EARLY!)
window.addEventListener('message', (event) => {
    if (event.data.type === 'LOAD_CLAIM_DATA') {
        const claimData = event.data.data;
        console.log('üì• Received claim data from Claims Manager:', claimData.claimName);
        
        // Populate property data with client info
        const clientInfo = claimData.clientInfo || {};
        const claimInfo = claimData.claimInfo || {};
        const insuranceInfo = claimData.insuranceInfo || {};
        
        // Build project name from client
        const firstName = clientInfo.firstName || '';
        const lastName = clientInfo.lastName || '';
        const claimNumber = claimInfo.claimNumber || '';
        const projectName = `${lastName}${firstName ? ', ' + firstName : ''}${claimNumber ? ' - ' + claimNumber : ''}`;
        
        // Build address
        const address = clientInfo.address || '';
        const city = clientInfo.city || '';
        const state = clientInfo.state || '';
        const zip = clientInfo.zip || '';
        const fullAddress = `${address}${city ? ', ' + city : ''}${state ? ', ' + state : ''}${zip ? ' ' + zip : ''}`;
        
        // Build insured name
        const insured = `${firstName} ${lastName}`.trim();
        
        // Store claim data GLOBALLY (will be used when form opens)
        window.claimDataFromManager = {
            projectName: projectName,
            address: fullAddress,
            claimNumber: claimNumber,
            insured: insured,
            client: clientInfo,
            claim: claimInfo,
            insurance: insuranceInfo,
            // Store individual fields for easy access
            clientName: insured,
            clientCompany: insuranceInfo.company || '',
            clientEmail: clientInfo.email || '',
            clientPhone: clientInfo.phone || '',
            clientAddress: address,
            clientCity: city,
            clientState: state,
            clientZip: zip,
            clientNotes: `Claim #: ${claimNumber}\nLoss Type: ${claimInfo.lossType || 'N/A'}\nDate of Loss: ${claimInfo.dateOfLoss || 'N/A'}\nAdjuster: ${insuranceInfo.adjuster || 'N/A'}\nPolicy: ${insuranceInfo.policyNumber || 'N/A'}`
        };
        
        console.log('‚úÖ Stored claim data globally');
        console.log('   Project:', projectName);
        console.log('   Client:', insured);
        console.log('   Address:', fullAddress);
        console.log('   Claim #:', claimNumber);
        console.log('   Insurance:', insuranceInfo.company || 'N/A');
        
        // Update state after a delay to ensure it's ready
        setTimeout(() => {
            if (window.state) {
                window.state.projectName = projectName || 'Untitled Project';
                window.state.claimData = window.claimDataFromManager;
                
                // Update project name display
                const display = document.getElementById('projectNameDisplay');
                if (display) {
                    display.textContent = window.state.projectName;
                }
            }
            
            // Load existing property data if available
            if (claimData.propertyData && claimData.propertyData.rooms && claimData.propertyData.rooms.length > 0) {
                console.log('üè† ==== LOADING EXISTING PROPERTY DATA ====');
                console.log('   Full property data:', claimData.propertyData);
                console.log('   Rooms to load:', claimData.propertyData.rooms.length);
                console.log('   Items to load:', claimData.propertyData.selectedItems ? claimData.propertyData.selectedItems.length : 0);
                
                const roomCount = claimData.propertyData.rooms.length;
                const itemCount = claimData.propertyData.selectedItems ? claimData.propertyData.selectedItems.length : 0;
                
                try {
                    // Restore rooms to state
                    if (window.state) {
                        window.state.rooms = claimData.propertyData.rooms;
                        window.state.currentRoomIndex = 0;
                        console.log('‚úÖ Rooms restored to window.state.rooms:', window.state.rooms.length);
                        console.log('   First room:', window.state.rooms[0]);
                    } else {
                        console.error('‚ùå window.state not available!');
                        alert('‚ùå ERROR: Application state not initialized!\n\nPlease refresh and try again.');
                        return;
                    }
                    
                    // Restore selected items to estimatorIntegration
                    if (claimData.propertyData.selectedItems && claimData.propertyData.selectedItems.length > 0) {
                        window.pendingSelectedItems = claimData.propertyData.selectedItems;
                        console.log('‚úÖ Selected items stored for restoration');
                        
                        if (window.estimatorIntegration) {
                            window.estimatorIntegration.selectedItems = claimData.propertyData.selectedItems;
                            console.log('‚úÖ Selected items restored immediately');
                        }
                    }
                    
                    // Try to update UI
                    console.log('üîÑ Attempting to update UI...');
                    console.log('   updateRoomList available:', typeof updateRoomList);
                    console.log('   selectRoom available:', typeof selectRoom);
                    console.log('   window.updateRoomList available:', typeof window.updateRoomList);
                    
                    // Try multiple ways to call updateRoomList
                    let uiUpdated = false;
                    
                    if (typeof updateRoomList === 'function') {
                        console.log('   Calling updateRoomList() directly...');
                        updateRoomList();
                        uiUpdated = true;
                    } else if (typeof window.updateRoomList === 'function') {
                        console.log('   Calling window.updateRoomList()...');
                        window.updateRoomList();
                        uiUpdated = true;
                    } else {
                        console.warn('‚ö†Ô∏è updateRoomList function not found - UI may not update automatically');
                    }
                    
                    // Select first room
                    if (window.state.rooms.length > 0) {
                        if (typeof selectRoom === 'function') {
                            console.log('   Selecting first room...');
                            selectRoom(0);
                        } else if (typeof window.selectRoom === 'function') {
                            console.log('   Calling window.selectRoom()...');
                            window.selectRoom(0);
                        } else {
                            console.warn('‚ö†Ô∏è selectRoom function not found');
                        }
                    }
                    
                    const roomCount = claimData.propertyData.rooms.length;
                    const itemCount = claimData.propertyData.selectedItems ? claimData.propertyData.selectedItems.length : 0;
                    
                    console.log('‚úÖ ==== PROPERTY DATA LOADED SUCCESSFULLY ====');
                    console.log('   Rooms:', roomCount);
                    console.log('   Items:', itemCount);
                    console.log('   UI Updated:', uiUpdated);
                    
                    if (typeof showToast === 'function') {
                        showToast(`‚úì Restored: ${roomCount} room(s), ${itemCount} item(s)`);
                    }
                    
                    // Force a render/redraw after a delay
                    setTimeout(() => {
                        console.log('üîÑ Forcing UI update after delay...');
                        if (typeof render2D === 'function') {
                            console.log('   Calling render2D()...');
                            render2D();
                        }
                        if (typeof render3D === 'function') {
                            console.log('   Calling render3D()...');
                            render3D();
                        }
                    }, 500);
                    
                } catch (e) {
                    console.error('‚ùå ==== ERROR LOADING PROPERTY DATA ====');
                    console.error('   Error:', e);
                    console.error('   Stack:', e.stack);
                    showToast(`‚úì Loaded claim: ${projectName} (error loading rooms)`);
                    alert('Error loading property data:\n\n' + e.message + '\n\nStarting with empty property.');
                }
            } else {
                console.log('üìù No existing property data - starting fresh');
                console.log('   claimData.propertyData exists:', !!claimData.propertyData);
                if (claimData.propertyData) {
                    console.log('   claimData.propertyData.rooms exists:', !!claimData.propertyData.rooms);
                    console.log('   claimData.propertyData.rooms.length:', claimData.propertyData.rooms ? claimData.propertyData.rooms.length : 'N/A');
                }
                
                showToast(`‚úì Loaded claim: ${projectName}`);
            }
        }, 100);
    }
});

console.log('üëÇ Listening for claim data from Claims Manager...');

setTimeout(() => {
    
    try {
        window.estimatorIntegration = new EstimatorIntegration();
        console.log('‚úÖ DONE! Estimator is ready.');
        
        // Hide loading badge
        const badge = document.getElementById('estimatorLoadingBadge');
        if (badge) badge.style.display = 'none';
        
        console.log('‚úÖ Click "Build Estimate" - it should work now!');
    } catch (e) {
        console.error('‚ùå Error:', e);
        alert('Error initializing estimator. Check console (F12).');
    }
}, 500);

// ============================================================================
// INTEGRATION WITH CLAIMS MANAGER - SAVE & RETURN
// ============================================================================

function saveAndReturnToClaims() {
    console.log('üîò Save & Return button clicked!');
    console.log('üíæ Saving property data and returning to Claims Manager...');
    
    try {
        // Check if we have state
        if (!window.state) {
            console.error('‚ùå window.state is not available!');
            if (typeof showToast === 'function') {
                showToast('‚ùå Error: Application state not available');
            }
            return;
        }
        
        // Access state.rooms correctly
        const roomsData = window.state.rooms || [];
        
        // Access selectedItems from estimatorIntegration
        const itemsData = (window.estimatorIntegration && window.estimatorIntegration.selectedItems) || [];
        
        console.log('üì¶ Gathering property data...');
        console.log('   State:', window.state ? '‚úÖ Available' : '‚ùå Not available');
        console.log('   Rooms found:', roomsData.length);
        console.log('   Items found:', itemsData.length);
        
        if (roomsData.length === 0) {
            console.log('‚ö†Ô∏è No rooms to save');
            if (typeof showToast === 'function') {
                showToast('‚ö†Ô∏è No rooms created yet - saving empty property data');
            }
        }
        
        // Gather all property data
        const propertyData = {
            rooms: roomsData, // Save complete room objects as-is!
            selectedItems: itemsData || [],
            lastModified: new Date().toISOString(),
            version: '3.64'
        };
        
        console.log('üì¶ Property data prepared successfully!');
        console.log('   Rooms:', propertyData.rooms.length);
        console.log('   Items:', propertyData.selectedItems.length);
        if (propertyData.rooms.length > 0) {
            console.log('   First room name:', propertyData.rooms[0].name);
            console.log('   First room walls:', propertyData.rooms[0].walls ? propertyData.rooms[0].walls.length : 0);
            console.log('   First room floorPoints:', propertyData.rooms[0].floorPoints ? propertyData.rooms[0].floorPoints.length : 0);
        }
        
        // Check if running in iframe
        const isInIframe = window.parent && window.parent !== window;
        console.log('üñºÔ∏è Running in iframe:', isInIframe ? 'YES' : 'NO');
        
        // Send data to Claims Manager (parent window)
        if (isInIframe) {
            console.log('üì§ Sending property data to Claims Manager...');
            
            window.parent.postMessage({
                type: 'SAVE_PROPERTY_DATA',
                propertyData: propertyData
            }, '*');
            
            console.log('‚úÖ Message sent to parent window!');
            
            // Show success message
            if (typeof showToast === 'function') {
                showToast('‚úÖ Property data saved successfully!');
            } else {
                console.log('‚úÖ Property data saved successfully!');
            }
            
            // Stay on the drawing - don't navigate away
            console.log('üìê Staying on drawing view');
        } else {
            console.log('‚ö†Ô∏è Not running in iframe - showing data instead');
            
            const message = 'Property data prepared:\n\n' + 
                  '‚Ä¢ ' + propertyData.rooms.length + ' room(s)\n' +
                  '‚Ä¢ ' + propertyData.selectedItems.length + ' item(s)\n\n' +
                  'Note: Not running inside Claims Manager iframe.\n' +
                  'To save data, open this through Claims Manager.';
            
            if (typeof showToast === 'function') {
                showToast('‚úÖ Data saved locally (' + propertyData.rooms.length + ' rooms)');
            }
            
            console.log(message);
        }
    } catch (error) {
        console.error('‚ùå ERROR in saveAndReturnToClaims:');
        console.error('   Error:', error);
        console.error('   Stack:', error.stack);
        
        const errorMessage = 'Error saving property data:\n\n' + 
                           error.message + '\n\n' +
                           'Check browser console (F12) for details.';
        
        if (typeof showToast === 'function') {
            showToast('‚ùå Error saving data');
        }
        
        alert(errorMessage);
    }
}

console.log('‚úÖ Claims Manager integration ready - Save & Return button active');

// ========================================
// XACTIMATE-STYLE MENU FUNCTIONS
// ========================================

function showMenuTab(tabName) {
    // Remove active class from all tabs
    document.querySelectorAll('.menu-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // Add active class to clicked tab
    event.target.classList.add('active');
    
    console.log(`Menu tab switched to: ${tabName}`);
    
    // Handle different menu tabs
    switch(tabName) {
        case 'sketch':
            // Already in sketch mode
            break;
        case 'project':
            alert('Project settings - coming soon!');
            break;
        case 'estimate':
            alert('Estimate items - coming soon!');
            break;
        case 'tools':
            alert('Additional tools - coming soon!');
            break;
        case 'options':
            alert('Options - coming soon!');
            break;
    }
}

function setDrawingMode(mode, event) {
    // Clear other active modes
    document.querySelectorAll('.toolbar-btn').forEach(btn => {
        btn.classList.remove('toolbar-btn-active');
    });
    
    // Set active mode - handle both inline onclick (global event) and passed event
    const clickEvent = event || window.event;
    if (clickEvent && clickEvent.target) {
        clickEvent.target.closest('.toolbar-btn').classList.add('toolbar-btn-active');
    }
    
    console.log(`üé® Drawing mode set to: ${mode}`);
    
    if (mode === 'wall') {
        // Clear any feature mode
        state.currentFeature = null;
        
        // Clear feature button active states
        document.querySelectorAll('.feature-btn').forEach(b => b.classList.remove('active'));
        
        // CRITICAL: Clear any in-progress wall corners when starting wall mode
        state.wallDrawingCorners = [];
        state.wallDrawingFirstCorner = null;
        
        // Prompt for wall thickness
        const currentRoom = getCurrentRoom();
        const defaultThickness = currentRoom ? (currentRoom.wallThickness || 4) : 4;
        const thickness = prompt(`Enter wall thickness (inches):`, defaultThickness);
        
        if (thickness === null) {
            // User cancelled
            return;
        }
        
        const thicknessValue = parseFloat(thickness);
        if (isNaN(thicknessValue) || thicknessValue < 2 || thicknessValue > 24) {
            showToast('‚ùå Invalid thickness - must be 2-24 inches', 3000);
            return;
        }
        
        // Store wall thickness in state for this drawing session
        state.currentWallThickness = thicknessValue;
        if (currentRoom) {
            currentRoom.wallThickness = thicknessValue;
        }
        
        // Enable wall drawing mode
        state.wallSelectionMode = true;
        
        // Show live instruction
        showToast(`üèóÔ∏è WALL MODE (${thicknessValue}" thick) - Click corners to draw`, 5000);
        
        // Update cursor
        const canvas = document.getElementById('canvas2D');
        canvas.style.cursor = 'crosshair';
        
        // Show instruction banner
        const banner = document.getElementById('instructionBanner');
        if (banner) {
            banner.textContent = `üìè WALL MODE (${thicknessValue}") - Click first corner`;
            banner.style.display = 'block';
            banner.style.background = '#2196F3';
            banner.style.color = 'white';
        }
        
        console.log(`‚úÖ Wall drawing mode enabled - ${thicknessValue}" thickness`);
        
        // Redraw to clear any previous preview
        redraw2D();
        
    } else if (mode === 'break') {
        state.wallSelectionMode = false;
        state.currentFeature = null;
        state.wallDrawingFirstCorner = null; // Clear wall drawing state
        state.wallDrawingCorners = [];
        showToast('‚úÇÔ∏è Break wall mode - Click a wall to cut it', 5000);
        
        const banner = document.getElementById('instructionBanner');
        if (banner) {
            banner.textContent = '‚úÇÔ∏è BREAK MODE - Click a wall to cut it';
            banner.style.display = 'block';
            banner.style.background = '#FF5722';
            banner.style.color = 'white';
        }
    }
    
    // Redraw to show any visual changes
    redraw2D();
}

function setFeatureMode(feature, event) {
    // Clear other active modes
    document.querySelectorAll('.toolbar-btn').forEach(btn => {
        btn.classList.remove('toolbar-btn-active');
    });
    
    // Set active mode - handle both inline onclick (global event) and passed event
    const clickEvent = event || window.event;
    if (clickEvent && clickEvent.target) {
        clickEvent.target.closest('.toolbar-btn').classList.add('toolbar-btn-active');
    }
    
    console.log(`üö™ Feature mode set to: ${feature}`);
    
    // Clear wall drawing state
    state.wallDrawingFirstCorner = null;
    state.wallDrawingCorners = [];
    
    // Set feature placement mode
    state.currentFeature = feature;
    state.wallSelectionMode = true;
    
    // Update cursor
    const canvas = document.getElementById('canvas2D');
    canvas.style.cursor = 'pointer';
    
    // Show live instruction
    let emoji = feature === 'door' ? 'üö™' : feature === 'window' ? 'ü™ü' : '‚¨ú';
    showToast(`${emoji} ${feature.toUpperCase()} MODE - Click a wall to place`, 5000);
    
    // Update instruction banner
    const banner = document.getElementById('instructionBanner');
    if (banner) {
        banner.textContent = `${emoji} ${feature.toUpperCase()} MODE - Click on a wall to place`;
        banner.style.display = 'block';
        banner.style.background = feature === 'door' ? '#4CAF50' : feature === 'window' ? '#2196F3' : '#FF9800';
        banner.style.color = 'white';
    }
    
    console.log(`‚úÖ ${feature} placement mode active`);
    
    // Redraw to show wall hover effects
    redraw2D();
}

function clearActiveToolMode() {
    console.log('‚ùå Clearing all tool modes');
    
    // Clear all active states
    state.wallSelectionMode = false;
    state.currentFeature = null;
    state.wallDrawingFirstCorner = null; // Clear wall drawing state
    state.wallDrawingCorners = []; // Clear polygon corners
    state.zoomWindowMode = false;
    state.zoomWindowStart = null;
    state.zoomWindowEnd = null;
    state.roomEditMode = false; // Exit room edit mode
    state.draggingHandle = null; // Clear any handle dragging
    state.hoveredHandle = null; // Clear handle hover
    
    // Remove active class from all toolbar buttons
    document.querySelectorAll('.toolbar-btn').forEach(btn => {
        btn.classList.remove('toolbar-btn-active');
    });
    
    // Reset cursor
    const canvas = document.getElementById('canvas2D');
    canvas.style.cursor = 'default';
    
    // Hide instruction banner
    const banner = document.getElementById('instructionBanner');
    if (banner) {
        banner.style.display = 'none';
    }
    
    // Show feedback
    showToast('‚úì Tool mode cleared', 2000);
    
    // Redraw canvas
    redraw2D();
}

function toggleOrthoMode() {
    state.orthoMode = !state.orthoMode;
    
    const orthoBtn = document.getElementById('orthoBtn');
    if (state.orthoMode) {
        orthoBtn.classList.add('toolbar-btn-active');
        showToast('‚äû ORTHO MODE ON - Lines snap to H/V', 3000);
    } else {
        orthoBtn.classList.remove('toolbar-btn-active');
        showToast('‚äû ORTHO MODE OFF - Free drawing', 2000);
    }
    
    console.log('Ortho mode:', state.orthoMode ? 'ON' : 'OFF');
    
    // Redraw to update preview if in wall mode
    if (state.wallSelectionMode && !state.currentFeature) {
        redraw2D();
    }
}

function zoomAll() {
    console.log('üîç Zoom All - Fitting all rooms to view');
    
    // Calculate bounding box of all rooms
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    let hasContent = false;
    
    state.rooms.forEach(room => {
        if (room.floorPoints && room.floorPoints.length > 0) {
            room.floorPoints.forEach(p => {
                const offsetX = (room.positionX || 0) * 30;
                const offsetY = (room.positionZ || 0) * 30;
                
                minX = Math.min(minX, p.x + offsetX);
                maxX = Math.max(maxX, p.x + offsetX);
                minY = Math.min(minY, p.y + offsetY);
                maxY = Math.max(maxY, p.y + offsetY);
                hasContent = true;
            });
        }
    });
    
    if (!hasContent) {
        showToast('‚ö†Ô∏è No content to zoom to', 2000);
        return;
    }
    
    // Add padding
    const padding = 100;
    minX -= padding;
    maxX += padding;
    minY -= padding;
    maxY += padding;
    
    // Calculate required zoom to fit content
    const canvas = document.getElementById('canvas2D');
    const contentWidth = maxX - minX;
    const contentHeight = maxY - minY;
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    
    const zoomX = canvasWidth / contentWidth;
    const zoomY = canvasHeight / contentHeight;
    state.zoom = Math.min(zoomX, zoomY, 2); // Cap at 2x zoom
    
    // Center the content
    const contentCenterX = (minX + maxX) / 2;
    const contentCenterY = (minY + maxY) / 2;
    
    state.panX = canvasWidth / 2 - contentCenterX * state.zoom;
    state.panY = canvasHeight / 2 - contentCenterY * state.zoom;
    
    console.log(`Zoom: ${state.zoom.toFixed(2)}x, Pan: (${state.panX.toFixed(0)}, ${state.panY.toFixed(0)})`);
    
    redraw2D();
    showToast('üîç Zoomed to fit all content', 2000);
}

function startZoomWindow() {
    console.log('‚¨ö Zoom Window - Select area to zoom');
    
    // Clear other modes
    clearActiveToolMode();
    
    // Activate zoom window mode
    state.zoomWindowMode = true;
    state.zoomWindowStart = null;
    state.zoomWindowEnd = null;
    
    // Highlight button
    const zoomBtn = document.getElementById('zoomWindowBtn');
    zoomBtn.classList.add('toolbar-btn-active');
    
    // Update cursor
    const canvas = document.getElementById('canvas2D');
    canvas.style.cursor = 'crosshair';
    
    // Show instruction
    const banner = document.getElementById('instructionBanner');
    if (banner) {
        banner.textContent = '‚¨ö ZOOM WINDOW - Click and drag to select area';
        banner.style.display = 'block';
        banner.style.background = '#9C27B0';
        banner.style.color = 'white';
    }
    
    showToast('‚¨ö Click and drag to select zoom area', 3000);
}

function executeZoomWindow(x1, y1, x2, y2) {
    console.log('Executing zoom window:', x1, y1, x2, y2);
    
    // Convert screen coordinates to world coordinates
    const worldX1 = (x1 - state.panX) / state.zoom;
    const worldY1 = (y1 - state.panY) / state.zoom;
    const worldX2 = (x2 - state.panX) / state.zoom;
    const worldY2 = (y2 - state.panY) / state.zoom;
    
    // Calculate bounding box
    const minX = Math.min(worldX1, worldX2);
    const maxX = Math.max(worldX1, worldX2);
    const minY = Math.min(worldY1, worldY2);
    const maxY = Math.max(worldY1, worldY2);
    
    // Add small padding
    const padding = 20;
    const contentWidth = maxX - minX + padding * 2;
    const contentHeight = maxY - minY + padding * 2;
    
    if (contentWidth < 10 || contentHeight < 10) {
        showToast('‚ùå Selection too small - drag larger area', 2000);
        return;
    }
    
    // Calculate zoom to fit selected area
    const canvas = document.getElementById('canvas2D');
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    
    const zoomX = canvasWidth / contentWidth;
    const zoomY = canvasHeight / contentHeight;
    state.zoom = Math.min(zoomX, zoomY, 5); // Cap at 5x zoom
    
    // Center the selected area
    const contentCenterX = (minX + maxX) / 2;
    const contentCenterY = (minY + maxY) / 2;
    
    state.panX = canvasWidth / 2 - contentCenterX * state.zoom;
    state.panY = canvasHeight / 2 - contentCenterY * state.zoom;
    
    // Clear zoom window mode
    state.zoomWindowMode = false;
    state.zoomWindowStart = null;
    state.zoomWindowEnd = null;
    
    const zoomBtn = document.getElementById('zoomWindowBtn');
    zoomBtn.classList.remove('toolbar-btn-active');
    
    const canvas2d = document.getElementById('canvas2D');
    canvas2d.style.cursor = 'default';
    
    const banner = document.getElementById('instructionBanner');
    if (banner) {
        banner.style.display = 'none';
    }
    
    console.log(`Zoomed to window: ${state.zoom.toFixed(2)}x`);
    
    redraw2D();
    showToast(`üîç Zoomed ${state.zoom.toFixed(1)}x to selected area`, 2000);
}

// Add ESC key handler to clear active tool mode
document.addEventListener('keydown', function(e) {
    // Don't trigger shortcuts if typing in input field
    if (e.target.matches('input, textarea, select')) return;
    
    if (e.key === 'Escape') {
        clearActiveToolMode();
    }
    
    // R key - Add new room (Xactimate)
    if (e.key === 'r' || e.key === 'R') {
        e.preventDefault();
        addNewRoom();
        showToast('üì¶ New room added! Press R anytime to add more.', 2000);
    }
    
    // Ctrl+Z for Undo
    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
    }
    
    // Ctrl+Y or Ctrl+Shift+Z for Redo
    if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        redo();
    }
});

console.log('‚úÖ Xactimate-style toolbar initialized');
console.log('   - Press ESC to exit any active tool or room edit mode');
console.log('   - Press R to add new room (Xactimate)');
console.log('   - CTRL+Drag from edge handle to create adjacent room');
console.log('   - Press Ctrl+Z to undo, Ctrl+Y or Ctrl+Shift+Z to redo');
console.log('   - Click room name to activate resize handles');
console.log('   - Drag edge handles perpendicular to wall (ortho mode)');
console.log('   - Click Wall tool to draw walls');
console.log('   - Click Door/Window/Opening to place features');

</script>

</body>
</html>
